From 22e410359c69a33d03d1ed1cb148e76fe356fd8d Mon Sep 17 00:00:00 2001
From: Miroslav Lichvar <mlichvar@redhat.com>
Date: Thu, 6 Aug 2020 16:16:10 +0200
Subject: [PATCH 08/15] phc2sys: Postpone adding of servo to clock.

commit 194dc845103c783e5f9bd6f9f025eedd6a5f3d36 upstream.

Instead of unconditionally creating a servo for each clock in their
initialization, add the servo later on the first update of the clock,
when it is known the clock needs to be synchronized.

This fixes an issue with phc2sys disrupting the system clock when
it is synchronized by another process and should be used by phc2sys only
as a source. Creating a servo for the system clock caused a reset of its
frequency and status.

Reported-by: Russell King <linux@armlinux.org.uk>
Signed-off-by: Miroslav Lichvar <mlichvar@redhat.com>
Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
---
 phc2sys.c | 24 +++++++++++-------------
 1 file changed, 11 insertions(+), 13 deletions(-)

diff --git a/phc2sys.c b/phc2sys.c
index f75ed2e..78bde32 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -233,9 +233,6 @@ static struct clock *clock_add(struct node *node, char *device)
 		}
 	}
 
-	if (clkid != CLOCK_INVALID)
-		c->servo = servo_add(node, c);
-
 	if (clkid != CLOCK_INVALID && clkid != CLOCK_REALTIME)
 		c->sysoff_method = sysoff_probe(CLOCKID_TO_FD(clkid),
 						node->phc_readings);
@@ -330,7 +327,6 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 	int phc_index = -1, phc_switched = 0;
 	int state, timestamping, ret = -1;
 	struct port *p;
-	struct servo *servo;
 	struct sk_ts_info ts_info;
 	char iface[IFNAMSIZ];
 	clockid_t clkid = CLOCK_INVALID;
@@ -362,10 +358,9 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 			clock->clkid = clkid;
 			clock->phc_index = phc_index;
 
-			servo = servo_add(node, clock);
-			if (servo) {
+			if (clock->servo) {
 				servo_destroy(clock->servo);
-				clock->servo = servo;
+				clock->servo = NULL;
 			}
 
 			phc_switched = 1;
@@ -373,7 +368,8 @@ static void clock_reinit(struct node *node, struct clock *clock, int new_state)
 	}
 
 	if (new_state == PS_MASTER || phc_switched) {
-		servo_reset(clock->servo);
+		if (clock->servo)
+			servo_reset(clock->servo);
 		clock->servo_state = SERVO_UNLOCKED;
 
 		if (clock->offset_stats) {
@@ -632,6 +628,12 @@ static void update_clock(struct node *node, struct clock *clock,
 	enum servo_state state;
 	double ppb;
 
+	if (!clock->servo) {
+		clock->servo = servo_add(node, clock);
+		if (!clock->servo)
+			return;
+	}
+
 	if (clock_handle_leap(node, clock, offset, ts))
 		return;
 
@@ -828,11 +830,6 @@ static int do_loop(struct node *node, int subscriptions)
 			    !strcmp(clock->device, node->master->device))
 				continue;
 
-			if (!clock->servo) {
-				pr_err("cannot update clock without servo");
-				return -1;
-			}
-
 			if (clock->clkid == CLOCK_REALTIME &&
 			    node->master->sysoff_method >= 0) {
 				/* use sysoff */
@@ -2271,6 +2268,7 @@ int main(int argc, char *argv[])
 	if (pps_fd >= 0) {
 		/* only one destination clock allowed with PPS until we
 		 * implement a mean to specify PTP port to PPS mapping */
+		dst->servo = servo_add(&node, dst);
 		servo_sync_interval(dst->servo, 1.0);
 		r = do_pps_loop(&node, dst, pps_fd);
 	} else if (extts_idx >= 0) {
-- 
2.17.1

