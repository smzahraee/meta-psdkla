From 4ff42492650541aa8b679007fba0330e286066e2 Mon Sep 17 00:00:00 2001
From: Grygorii Strashko <grygorii.strashko@ti.com>
Date: Thu, 15 Apr 2021 20:56:47 +0300
Subject: [PATCH 14/15] phc2sys: fix runtime overhead

Due to incorrect master check causing enabling extts for master clock and
missing POLLERR check for poll() results the phc2sys may enter in no delay
loop as poll() will return immediately due to unprocessed extts events or
uncleared file error.

Ensure extts is not enabled for clock selected as master and failed file
descriptor excluded from pool() once error detected.

Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
---
 phc2sys.c | 19 ++++++++++++++-----
 1 file changed, 14 insertions(+), 5 deletions(-)

diff --git a/phc2sys.c b/phc2sys.c
index cda543a..50ea788 100644
--- a/phc2sys.c
+++ b/phc2sys.c
@@ -1228,7 +1228,11 @@ static int autocfg_extts_init_clocks(struct node *node,
 
 	/* enable extts input on all slave clocks */
 	LIST_FOREACH(clock, &node->clocks, list) {
-		if (clock->clkid == master_clkid)
+		/* don't try to init the clock eq master */
+		if (clock->clkid == master_clkid ||
+		    (clock->phc_index >= 0 &&
+		     clock->phc_index == node->master->phc_index) ||
+		    !strcmp(clock->device, node->master->device))
 			continue;
 
 		if (clock->clkid == CLOCK_REALTIME)
@@ -1305,7 +1309,7 @@ static int do_autocfg_extts_loop(struct node *node, int subscriptions)
 		if (!node->master)
 			continue;
 
-		cnt = poll(&node->fds[0], node->num_clocks, 2000);
+		cnt = poll(&node->fds[0], node->num_clocks, 1000);
 		if (cnt < 0) {
 			if (EINTR == errno) {
 				continue;
@@ -1313,10 +1317,8 @@ static int do_autocfg_extts_loop(struct node *node, int subscriptions)
 				pr_emerg("poll failed");
 				break;
 			}
-		} else if (!cnt) {
+		} else if (!cnt)
 			pr_debug("poll returns zero, no events");
-			continue;
-		}
 
 		LIST_FOREACH(clock, &node->dst_clocks, dst_list) {
 			if (!update_needed(clock))
@@ -1343,6 +1345,13 @@ static int do_autocfg_extts_loop(struct node *node, int subscriptions)
 			if (clock->state == PS_UNCALIBRATED)
 				continue;
 
+			if (node->fds[clock->number].revents & POLLERR) {
+				node->fds[clock->number].fd = -1;
+				node->fds[clock->number].revents = 0;
+				pr_err("clockid %s: poll failed. disable", clock->device);
+				continue;
+			}
+
 			if (!(node->fds[clock->number].revents & POLLIN))
 				continue;
 
-- 
2.17.1

