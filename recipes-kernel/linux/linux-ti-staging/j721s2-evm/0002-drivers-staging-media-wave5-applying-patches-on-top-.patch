From fbe18541243ac9a749099767f3dff859f38d407d Mon Sep 17 00:00:00 2001
From: Aniket Limaye <a-limaye@ti.com>
Date: Mon, 1 Aug 2022 23:47:49 +0530
Subject: [PATCH] drivers: staging: media: wave5: applying patches on top
 of v9 - reduced total buffer size of decoder - hardcoded 48 bit addressing

---
 drivers/staging/media/wave5/wave5-hw.c        |   9 +-
 drivers/staging/media/wave5/wave5-vpu-dec.c   |   8 +-
 drivers/staging/media/wave5/wave5-vpu-enc.c   | 426 +++++++++++++++---
 drivers/staging/media/wave5/wave5-vpu.c       |   8 +-
 drivers/staging/media/wave5/wave5-vpuapi.c    |   2 +-
 drivers/staging/media/wave5/wave5-vpuapi.h    |  10 +-
 drivers/staging/media/wave5/wave5-vpuconfig.h |   3 +-
 7 files changed, 382 insertions(+), 84 deletions(-)

diff --git a/drivers/staging/media/wave5/wave5-hw.c b/drivers/staging/media/wave5/wave5-hw.c
index e82d423e0..ea5b97ddc 100644
--- a/drivers/staging/media/wave5/wave5-hw.c
+++ b/drivers/staging/media/wave5/wave5-hw.c
@@ -459,8 +459,11 @@ int wave5_vpu_build_up_dec_param(struct vpu_instance *vpu_inst,
 	bs_endian = wave5_vdi_convert_endian(vpu_inst->dev, param->stream_endian);
 	bs_endian = (~bs_endian & VDI_128BIT_ENDIAN_MASK);
 	vpu_write_reg(vpu_inst->dev, W5_CMD_BS_PARAM, bs_endian);
+//	vpu_write_reg(vpu_inst->dev, W5_CMD_EXT_ADDR, (param->pri_axprot << 20) |
+//			(param->pri_axcache << 16) | (param->pri_ext_addr << 0));
 	vpu_write_reg(vpu_inst->dev, W5_CMD_EXT_ADDR, (param->pri_axprot << 20) |
-			(param->pri_axcache << 16) | (param->pri_ext_addr << 0));
+			(param->pri_axcache << 16) | (WAVE5_PROC_AXI_EXT_ADDR << 0));
+
 	vpu_write_reg(vpu_inst->dev, W5_CMD_NUM_CQ_DEPTH_M1, (COMMAND_QUEUE_DEPTH - 1));
 	vpu_write_reg(vpu_inst->dev, W5_CMD_ERR_CONCEAL, (param->error_conceal_unit << 2) |
 			(param->error_conceal_mode));
@@ -1822,8 +1825,10 @@ int wave5_vpu_build_up_enc_param(struct device *dev, struct vpu_instance *vpu_in
 
 	reg_val = (param->line_buf_int_en << 6) | bs_endian;
 	vpu_write_reg(vpu_inst->dev, W5_CMD_BS_PARAM, reg_val);
+//	vpu_write_reg(vpu_inst->dev, W5_CMD_EXT_ADDR, (param->pri_axprot << 20) |
+//			(param->pri_axcache << 16) | (param->pri_ext_addr << 0));
 	vpu_write_reg(vpu_inst->dev, W5_CMD_EXT_ADDR, (param->pri_axprot << 20) |
-			(param->pri_axcache << 16) | (param->pri_ext_addr << 0));
+			(param->pri_axcache << 16) | (WAVE5_PROC_AXI_EXT_ADDR << 0));
 	vpu_write_reg(vpu_inst->dev, W5_CMD_NUM_CQ_DEPTH_M1, (COMMAND_QUEUE_DEPTH - 1));
 
 	reg_val = 0;
diff --git a/drivers/staging/media/wave5/wave5-vpu-dec.c b/drivers/staging/media/wave5/wave5-vpu-dec.c
index ffcab83fe..e6ea6fce9 100644
--- a/drivers/staging/media/wave5/wave5-vpu-dec.c
+++ b/drivers/staging/media/wave5/wave5-vpu-dec.c
@@ -227,7 +227,7 @@ static void wave5_vpu_dec_start_decode(struct vpu_instance *inst)
 	memset(&pic_param, 0, sizeof(struct dec_param));
 
 	if (inst->state == VPU_INST_STATE_INIT_SEQ) {
-		u32 non_linear_num = inst->dst_buf_count;
+		u32 non_linear_num = inst->min_dst_buf_count;
 		u32 linear_num = inst->dst_buf_count;
 		u32 stride = inst->dst_fmt.width;
 
@@ -876,7 +876,7 @@ static int wave5_vpu_dec_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 			inst->dst_buf_count = *num_buffers;
 
 		*num_buffers = inst->dst_buf_count;
-		non_linear_num = inst->dst_buf_count;
+		non_linear_num = inst->min_dst_buf_count;
 
 		for (i = 0; i < non_linear_num; i++) {
 			struct frame_buffer *frame = &inst->frame_buf[i];
@@ -1054,7 +1054,7 @@ static void wave5_vpu_dec_buf_queue_dst(struct vb2_buffer *vb)
 	if (inst->state == VPU_INST_STATE_INIT_SEQ) {
 		dma_addr_t buf_addr_y = 0, buf_addr_cb = 0, buf_addr_cr = 0;
 		u32 buf_size = 0;
-		u32 non_linear_num = inst->dst_buf_count;
+		u32 non_linear_num = inst->min_dst_buf_count;
 		u32 fb_stride = inst->dst_fmt.width;
 		u32 luma_size = fb_stride * inst->dst_fmt.height;
 		u32 chroma_size = (fb_stride / 2) * (inst->dst_fmt.height / 2);
@@ -1384,7 +1384,7 @@ static int wave5_vpu_dec_release(struct file *filp)
 			dev_warn(inst->dev->dev, "close fail ret=%d\n", ret);
 	}
 
-	for (i = 0; i < inst->dst_buf_count; i++)
+	for (i = 0; i < inst->min_dst_buf_count; i++)
 		wave5_vdi_free_dma_memory(inst->dev, &inst->frame_vbuf[i]);
 
 	wave5_vdi_free_dma_memory(inst->dev, &inst->bitstream_vbuf);
diff --git a/drivers/staging/media/wave5/wave5-vpu-enc.c b/drivers/staging/media/wave5/wave5-vpu-enc.c
index 84cfcfcc6..2532fe532 100644
--- a/drivers/staging/media/wave5/wave5-vpu-enc.c
+++ b/drivers/staging/media/wave5/wave5-vpu-enc.c
@@ -832,6 +832,40 @@ static int wave5_vpu_enc_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_MPEG_VIDEO_VBV_SIZE:
 		inst->vbv_buf_size = ctrl->val;
 		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE_MODE:
+		switch (ctrl->val) {
+		case V4L2_MPEG_VIDEO_BITRATE_MODE_VBR:
+			inst->rc_mode = 0;
+			break;
+		case V4L2_MPEG_VIDEO_BITRATE_MODE_CBR:
+			inst->rc_mode = 1;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_BITRATE:
+		inst->bit_rate = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_GOP_SIZE:
+		inst->enc_param.avc_idr_period = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE:
+		inst->enc_param.independ_slice_mode = ctrl->val;
+		inst->enc_param.avc_slice_mode = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB:
+		inst->enc_param.independ_slice_mode_arg = ctrl->val;
+		inst->enc_param.avc_slice_arg = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE:
+		inst->rc_enable = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE:
+		inst->enc_param.mb_level_rc_enable = ctrl->val;
+		inst->enc_param.cu_level_rc_enable = ctrl->val;
+		inst->enc_param.hvs_qp_enable = ctrl->val;
+		break;
 	case V4L2_CID_MPEG_VIDEO_HEVC_PROFILE:
 		switch (ctrl->val) {
 		case V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN:
@@ -887,14 +921,80 @@ static int wave5_vpu_enc_s_ctrl(struct v4l2_ctrl *ctrl)
 		}
 		break;
 	case V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP:
-		inst->min_qp_i = ctrl->val;
-		inst->min_qp_p = ctrl->val;
-		inst->min_qp_b = ctrl->val;
+		inst->enc_param.min_qp_i = ctrl->val;
+		inst->enc_param.min_qp_p = ctrl->val;
+		inst->enc_param.min_qp_b = ctrl->val;
 		break;
 	case V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP:
-		inst->max_qp_i = ctrl->val;
-		inst->max_qp_p = ctrl->val;
-		inst->max_qp_b = ctrl->val;
+		inst->enc_param.max_qp_i = ctrl->val;
+		inst->enc_param.max_qp_p = ctrl->val;
+		inst->enc_param.max_qp_b = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP:
+		inst->enc_param.intra_qp = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE:
+		switch (ctrl->val) {
+		case V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED:
+			inst->enc_param.disable_deblk = 1;
+			inst->enc_param.sao_enable = 0;
+			inst->enc_param.lf_cross_slice_boundary_enable = 0;
+			break;
+		case V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED:
+			inst->enc_param.disable_deblk = 0;
+			inst->enc_param.sao_enable = 1;
+			inst->enc_param.lf_cross_slice_boundary_enable = 1;
+			break;
+		case V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY:
+			inst->enc_param.disable_deblk = 0;
+			inst->enc_param.sao_enable = 1;
+			inst->enc_param.lf_cross_slice_boundary_enable = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2:
+		inst->enc_param.beta_offset_div2 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2:
+		inst->enc_param.tc_offset_div2 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE:
+		switch (ctrl->val) {
+		case V4L2_MPEG_VIDEO_HEVC_REFRESH_NONE:
+			inst->enc_param.decoding_refresh_type = 0;
+			break;
+		case V4L2_MPEG_VIDEO_HEVC_REFRESH_CRA:
+			inst->enc_param.decoding_refresh_type = 1;
+			break;
+		case V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR:
+			inst->enc_param.decoding_refresh_type = 2;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD:
+		inst->enc_param.intra_period = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU:
+		inst->enc_param.lossless_enable = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED:
+		inst->enc_param.const_intra_pred_flag = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT:
+		inst->enc_param.wpp_enable = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING:
+		inst->enc_param.strong_intra_smooth_enable = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1:
+		inst->enc_param.max_num_merge = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION:
+		inst->enc_param.tmvp_enable = ctrl->val;
 		break;
 	case V4L2_CID_MPEG_VIDEO_H264_PROFILE:
 		switch (ctrl->val) {
@@ -986,14 +1086,57 @@ static int wave5_vpu_enc_s_ctrl(struct v4l2_ctrl *ctrl)
 		}
 		break;
 	case V4L2_CID_MPEG_VIDEO_H264_MIN_QP:
-		inst->min_qp_i = ctrl->val;
-		inst->min_qp_p = ctrl->val;
-		inst->min_qp_b = ctrl->val;
+		inst->enc_param.min_qp_i = ctrl->val;
+		inst->enc_param.min_qp_p = ctrl->val;
+		inst->enc_param.min_qp_b = ctrl->val;
 		break;
 	case V4L2_CID_MPEG_VIDEO_H264_MAX_QP:
-		inst->max_qp_i = ctrl->val;
-		inst->max_qp_p = ctrl->val;
-		inst->max_qp_b = ctrl->val;
+		inst->enc_param.max_qp_i = ctrl->val;
+		inst->enc_param.max_qp_p = ctrl->val;
+		inst->enc_param.max_qp_b = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP:
+		inst->enc_param.intra_qp = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE:
+		switch (ctrl->val) {
+		case V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED:
+			inst->enc_param.disable_deblk = 1;
+			inst->enc_param.lf_cross_slice_boundary_enable = 1;
+			break;
+		case V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED:
+			inst->enc_param.disable_deblk = 0;
+			inst->enc_param.lf_cross_slice_boundary_enable = 1;
+			break;
+		case V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY:
+			inst->enc_param.disable_deblk = 0;
+			inst->enc_param.lf_cross_slice_boundary_enable = 0;
+			break;
+		default:
+			return -EINVAL;
+		}
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA:
+		inst->enc_param.beta_offset_div2 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA:
+		inst->enc_param.tc_offset_div2 = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM:
+		inst->enc_param.transform8x8_enable = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION:
+		inst->enc_param.const_intra_pred_flag = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET:
+		inst->enc_param.chroma_cb_qp_offset = ctrl->val;
+		inst->enc_param.chroma_cr_qp_offset = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_I_PERIOD:
+		inst->enc_param.intra_period = ctrl->val;
+		break;
+	case V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE:
+		inst->enc_param.entropy_coding_mode = ctrl->val;
 		break;
 	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:
 		break;
@@ -1008,49 +1151,102 @@ static const struct v4l2_ctrl_ops wave5_vpu_enc_ctrl_ops = {
 	.s_ctrl = wave5_vpu_enc_s_ctrl,
 };
 
-static void wave5_set_default_enc_openparam(struct enc_open_param *open_param)
+static void wave5_set_enc_openparam(struct enc_open_param *open_param,
+				    struct vpu_instance inst)
 {
-	unsigned int i;
-
-	open_param->stream_endian = VPU_STREAM_ENDIAN;
-	open_param->source_endian = VPU_SOURCE_ENDIAN;
-	open_param->line_buf_int_en = TRUE;
+	struct enc_wave_param input = inst.enc_param;
+	u32 num_ctu_row = ALIGN(inst.dst_fmt.height, 64) / 64;
+	u32 num_mb_row = ALIGN(inst.dst_fmt.height, 16) / 16;
 
 	open_param->wave_param.gop_preset_idx = PRESET_IDX_IPP_SINGLE;
-	open_param->wave_param.decoding_refresh_type = 1;
-	open_param->wave_param.intra_qp = 30;
-	open_param->wave_param.tmvp_enable = 1;
-	open_param->wave_param.max_num_merge = 2;
-	open_param->wave_param.lf_cross_slice_boundary_enable = 1;
-	open_param->wave_param.skip_intra_trans = 1;
-	open_param->wave_param.sao_enable = 1;
-	open_param->wave_param.transform8x8_enable = 1;
-	open_param->wave_param.intra_nx_n_enable = 1;
-	for (i = 0; i < MAX_GOP_NUM; i++)
-		open_param->wave_param.fixed_bit_ratio[i] = 1;
-	open_param->wave_param.cu_level_rc_enable = 1;
-	open_param->wave_param.hvs_qp_enable = 1;
 	open_param->wave_param.hvs_qp_scale = 2;
 	open_param->wave_param.hvs_max_delta_qp = 10;
-	open_param->wave_param.gop_param.custom_gop_size = 1;
-	open_param->wave_param.initial_rc_qp = -1;
+	open_param->wave_param.skip_intra_trans = 1;
+	open_param->wave_param.intra_nx_n_enable = 1;
 	open_param->wave_param.nr_intra_weight_y = 7;
 	open_param->wave_param.nr_intra_weight_cb = 7;
 	open_param->wave_param.nr_intra_weight_cr = 7;
 	open_param->wave_param.nr_inter_weight_y = 4;
 	open_param->wave_param.nr_inter_weight_cb = 4;
 	open_param->wave_param.nr_inter_weight_cr = 4;
-	open_param->wave_param.strong_intra_smooth_enable = 1;
-	open_param->wave_param.bg_thr_diff = 8;
-	open_param->wave_param.bg_thr_mean_diff = 1;
-	open_param->wave_param.bg_lambda_qp = 32;
-	open_param->wave_param.bg_delta_qp = 3;
 	open_param->wave_param.rdo_skip = 1;
-	open_param->wave_param.intra_mb_refresh_arg = 1;
-	open_param->wave_param.entropy_coding_mode = 1;
-	open_param->wave_param.rc_weight_param = 16;
-	open_param->wave_param.rc_weight_buf = 128;
 	open_param->wave_param.lambda_scaling_enable = 1;
+
+	open_param->stream_endian = VPU_STREAM_ENDIAN;
+	open_param->source_endian = VPU_SOURCE_ENDIAN;
+	open_param->line_buf_int_en = TRUE;
+	open_param->pic_width = inst.dst_fmt.width;
+	open_param->pic_height = inst.dst_fmt.height;
+	open_param->frame_rate_info = inst.frame_rate;
+	open_param->rc_enable = inst.rc_enable;
+	if (inst.rc_enable) {
+		open_param->wave_param.initial_rc_qp = -1;
+		open_param->wave_param.rc_weight_param = 16;
+		open_param->wave_param.rc_weight_buf = 128;
+	}
+	open_param->wave_param.mb_level_rc_enable = input.mb_level_rc_enable;
+	open_param->wave_param.cu_level_rc_enable = input.cu_level_rc_enable;
+	open_param->wave_param.hvs_qp_enable = input.hvs_qp_enable;
+	open_param->bit_rate = inst.bit_rate;
+	open_param->vbv_buffer_size = inst.vbv_buf_size;
+	if (inst.rc_mode == 0)
+		open_param->vbv_buffer_size = 3000;
+	open_param->wave_param.profile = inst.profile;
+	open_param->wave_param.level = inst.level;
+	open_param->wave_param.internal_bit_depth = inst.bit_depth;
+	open_param->wave_param.intra_qp = input.intra_qp;
+	open_param->wave_param.min_qp_i = input.min_qp_i;
+	open_param->wave_param.max_qp_i = input.max_qp_i;
+	open_param->wave_param.min_qp_p = input.min_qp_p;
+	open_param->wave_param.max_qp_p = input.max_qp_p;
+	open_param->wave_param.min_qp_b = input.min_qp_b;
+	open_param->wave_param.max_qp_b = input.max_qp_b;
+	open_param->wave_param.disable_deblk = input.disable_deblk;
+	open_param->wave_param.lf_cross_slice_boundary_enable =
+		input.lf_cross_slice_boundary_enable;
+	open_param->wave_param.tc_offset_div2 = input.tc_offset_div2;
+	open_param->wave_param.beta_offset_div2 = input.beta_offset_div2;
+	open_param->wave_param.decoding_refresh_type = input.decoding_refresh_type;
+	open_param->wave_param.intra_period = input.intra_period;
+	if (inst.std == W_HEVC_ENC) {
+		if (input.intra_period == 0) {
+			open_param->wave_param.decoding_refresh_type = 2;
+			open_param->wave_param.intra_period = input.avc_idr_period;
+		}
+	} else {
+		open_param->wave_param.avc_idr_period = input.avc_idr_period;
+	}
+	open_param->wave_param.entropy_coding_mode = input.entropy_coding_mode;
+	open_param->wave_param.lossless_enable = input.lossless_enable;
+	open_param->wave_param.const_intra_pred_flag = input.const_intra_pred_flag;
+	open_param->wave_param.wpp_enable = input.wpp_enable;
+	open_param->wave_param.strong_intra_smooth_enable = input.strong_intra_smooth_enable;
+	open_param->wave_param.max_num_merge = input.max_num_merge;
+	open_param->wave_param.tmvp_enable = input.tmvp_enable;
+	open_param->wave_param.transform8x8_enable = input.transform8x8_enable;
+	open_param->wave_param.const_intra_pred_flag = input.const_intra_pred_flag;
+	open_param->wave_param.chroma_cb_qp_offset = input.chroma_cb_qp_offset;
+	open_param->wave_param.chroma_cr_qp_offset = input.chroma_cr_qp_offset;
+	open_param->wave_param.independ_slice_mode = input.independ_slice_mode;
+	open_param->wave_param.independ_slice_mode_arg = input.independ_slice_mode_arg;
+	open_param->wave_param.avc_slice_mode = input.avc_slice_mode;
+	open_param->wave_param.avc_slice_arg = input.avc_slice_arg;
+	open_param->wave_param.intra_mb_refresh_mode = input.intra_mb_refresh_mode;
+	if (input.intra_mb_refresh_mode != 0) {
+		if (num_mb_row >= input.intra_mb_refresh_arg)
+			open_param->wave_param.intra_mb_refresh_arg =
+				num_mb_row / input.intra_mb_refresh_arg;
+		else
+			open_param->wave_param.intra_mb_refresh_arg = num_mb_row;
+	}
+	open_param->wave_param.intra_refresh_mode = input.intra_refresh_mode;
+	if (input.intra_refresh_mode != 0) {
+		if (num_ctu_row >= input.intra_refresh_arg)
+			open_param->wave_param.intra_refresh_arg =
+				num_ctu_row / input.intra_refresh_arg;
+		else
+			open_param->wave_param.intra_refresh_arg = num_ctu_row;
+	}
 }
 
 static int wave5_vpu_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,
@@ -1093,7 +1289,6 @@ static int wave5_vpu_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 		struct v4l2_ctrl *ctrl;
 
 		memset(&open_param, 0, sizeof(struct enc_open_param));
-		wave5_set_default_enc_openparam(&open_param);
 
 		inst->std = wave5_to_vpu_wavestd(inst->dst_fmt.pixelformat);
 		if (inst->std == STD_UNKNOWN) {
@@ -1101,19 +1296,8 @@ static int wave5_vpu_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 				 (char *)&inst->dst_fmt.pixelformat);
 			return -EINVAL;
 		}
-		open_param.pic_width = inst->dst_fmt.width;
-		open_param.pic_height = inst->dst_fmt.height;
-		open_param.frame_rate_info = inst->frame_rate;
-		open_param.vbv_buffer_size = inst->vbv_buf_size;
-		open_param.wave_param.profile = inst->profile;
-		open_param.wave_param.level = inst->level;
-		open_param.wave_param.internal_bit_depth = inst->bit_depth;
-		open_param.wave_param.min_qp_i = inst->min_qp_i;
-		open_param.wave_param.max_qp_i = inst->max_qp_i;
-		open_param.wave_param.min_qp_p = inst->min_qp_p;
-		open_param.wave_param.max_qp_p = inst->max_qp_p;
-		open_param.wave_param.min_qp_b = inst->min_qp_b;
-		open_param.wave_param.max_qp_b = inst->max_qp_b;
+
+		wave5_set_enc_openparam(&open_param, *inst);
 
 		ret = wave5_vpu_enc_open(inst, &open_param);
 		if (ret) {
@@ -1408,34 +1592,140 @@ static int wave5_vpu_open_enc(struct file *filp)
 		goto err_m2m_release;
 	}
 
-	v4l2_ctrl_handler_init(v4l2_ctrl_hdl, 30);
+	v4l2_ctrl_handler_init(v4l2_ctrl_hdl, 50);
 	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
 			       V4L2_CID_MPEG_VIDEO_HEVC_PROFILE,
 			       V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN_10, 0,
 			       V4L2_MPEG_VIDEO_HEVC_PROFILE_MAIN);
 	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
-			       V4L2_CID_MPEG_VIDEO_HEVC_LEVEL, V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1, 0,
+			       V4L2_CID_MPEG_VIDEO_HEVC_LEVEL,
+			       V4L2_MPEG_VIDEO_HEVC_LEVEL_5_1, 0,
 			       V4L2_MPEG_VIDEO_HEVC_LEVEL_1);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP,
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_MIN_QP,
 			  0, 63, 1, 8);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP,
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_MAX_QP,
 			  0, 63, 1, 51);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_I_FRAME_QP,
+			  0, 63, 1, 30);
+	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE,
+			       V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY, 0,
+			       V4L2_MPEG_VIDEO_HEVC_LOOP_FILTER_MODE_ENABLED);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_LF_BETA_OFFSET_DIV2,
+			  -6, 6, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_LF_TC_OFFSET_DIV2,
+			  -6, 6, 1, 0);
+	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_TYPE,
+			       V4L2_MPEG_VIDEO_HEVC_REFRESH_IDR, 0,
+			       V4L2_MPEG_VIDEO_HEVC_REFRESH_CRA);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_REFRESH_PERIOD,
+			  0, 2047, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_LOSSLESS_CU,
+			  0, 1, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_CONST_INTRA_PRED,
+			  0, 1, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_WAVEFRONT,
+			  0, 1, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_STRONG_SMOOTHING,
+			  0, 1, 1, 1);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_MAX_NUM_MERGE_MV_MINUS1,
+			  1, 2, 1, 2);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_HEVC_TMV_PREDICTION,
+			  0, 1, 1, 1);
+
 	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
 			       V4L2_CID_MPEG_VIDEO_H264_PROFILE,
 			       V4L2_MPEG_VIDEO_H264_PROFILE_HIGH_444_PREDICTIVE, 0,
 			       V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE);
 	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
-			       V4L2_CID_MPEG_VIDEO_H264_LEVEL, V4L2_MPEG_VIDEO_H264_LEVEL_5_1, 0,
+			       V4L2_CID_MPEG_VIDEO_H264_LEVEL,
+			       V4L2_MPEG_VIDEO_H264_LEVEL_5_1, 0,
 			       V4L2_MPEG_VIDEO_H264_LEVEL_1_0);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_H264_MIN_QP,
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_MIN_QP,
 			  0, 63, 1, 8);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_H264_MAX_QP,
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_MAX_QP,
 			  0, 63, 1, 51);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_ROTATE, 0, 270, 90, 0);
-	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_VBV_SIZE, 10,
-			  3000, 1, 3000);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_I_FRAME_QP,
+			  0, 63, 1, 30);
+	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_MODE,
+			       V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_DISABLED_AT_SLICE_BOUNDARY, 0,
+			       V4L2_MPEG_VIDEO_H264_LOOP_FILTER_MODE_ENABLED);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_ALPHA,
+			  -6, 6, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_LOOP_FILTER_BETA,
+			  -6, 6, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_8X8_TRANSFORM,
+			  0, 1, 1, 1);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_CONSTRAINED_INTRA_PREDICTION,
+			  0, 1, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_CHROMA_QP_INDEX_OFFSET,
+			  -12, 12, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_H264_I_PERIOD,
+			  0, 2047, 1, 0);
+	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_H264_ENTROPY_MODE,
+			       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CABAC, 0,
+			       V4L2_MPEG_VIDEO_H264_ENTROPY_MODE_CAVLC);
+
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_HFLIP,
+			  0, 1, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_VFLIP,
+			  0, 1, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_ROTATE,
+			  0, 270, 90, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_VBV_SIZE,
+			  10, 3000, 1, 3000);
+	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_BITRATE_MODE,
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR, 0,
+			       V4L2_MPEG_VIDEO_BITRATE_MODE_CBR);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_BITRATE,
+			  0, 700000000, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_GOP_SIZE,
+			  0, 2047, 1, 0);
+	v4l2_ctrl_new_std_menu(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			       V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MODE,
+			       V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_MAX_MB, 0,
+			       V4L2_MPEG_VIDEO_MULTI_SLICE_MODE_SINGLE);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_MULTI_SLICE_MAX_MB,
+			  0, 0xFFFF, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_FRAME_RC_ENABLE,
+			  0, 1, 1, 0);
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MPEG_VIDEO_MB_RC_ENABLE,
+			  0, 1, 1, 0);
+
 	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
 			  V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 32, 1, 1);
 
diff --git a/drivers/staging/media/wave5/wave5-vpu.c b/drivers/staging/media/wave5/wave5-vpu.c
index 15098426a..b19cd2bc5 100644
--- a/drivers/staging/media/wave5/wave5-vpu.c
+++ b/drivers/staging/media/wave5/wave5-vpu.c
@@ -8,6 +8,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/io.h>
 #include <linux/of_address.h>
 #include <linux/firmware.h>
 #include <linux/interrupt.h>
@@ -183,8 +184,11 @@ static int wave5_vpu_probe(struct platform_device *pdev)
 	}
 
 	/* physical addresses limited to 32 bits */
-	dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
-	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+//	dma_set_mask(&pdev->dev, DMA_BIT_MASK(32));
+//	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
+	dma_set_mask(&pdev->dev, DMA_BIT_MASK(64));
+	dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
+
 
 	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
 	if (!dev)
diff --git a/drivers/staging/media/wave5/wave5-vpuapi.c b/drivers/staging/media/wave5/wave5-vpuapi.c
index fc6eb74e6..a9ac27b5a 100644
--- a/drivers/staging/media/wave5/wave5-vpuapi.c
+++ b/drivers/staging/media/wave5/wave5-vpuapi.c
@@ -726,7 +726,7 @@ int wave5_vpu_dec_give_command(struct vpu_instance *inst, enum codec_command cmd
 	case DEC_RESET_FRAMEBUF_INFO: {
 		int i;
 
-		for (i = 0; i < inst->dst_buf_count; i++) {
+		for (i = 0; i < inst->min_dst_buf_count; i++) {
 			wave5_vdi_free_dma_memory(inst->dev, &inst->frame_vbuf[i]);
 			wave5_vdi_free_dma_memory(inst->dev, &p_dec_info->vb_mv[i]);
 			wave5_vdi_free_dma_memory(inst->dev, &p_dec_info->vb_fbc_y_tbl[i]);
diff --git a/drivers/staging/media/wave5/wave5-vpuapi.h b/drivers/staging/media/wave5/wave5-vpuapi.h
index 05f772c96..6a719fb41 100644
--- a/drivers/staging/media/wave5/wave5-vpuapi.h
+++ b/drivers/staging/media/wave5/wave5-vpuapi.h
@@ -1096,12 +1096,10 @@ struct vpu_instance {
 	unsigned int bit_depth;
 	unsigned int frame_rate;
 	unsigned int vbv_buf_size;
-	unsigned int min_qp_i;
-	unsigned int max_qp_i;
-	unsigned int min_qp_p;
-	unsigned int max_qp_p;
-	unsigned int min_qp_b;
-	unsigned int max_qp_b;
+	unsigned int rc_mode;
+	unsigned int rc_enable;
+	unsigned int bit_rate;
+	struct enc_wave_param enc_param;
 };
 
 void wave5_vdi_write_register(struct vpu_device *vpu_device, unsigned int addr, unsigned int data);
diff --git a/drivers/staging/media/wave5/wave5-vpuconfig.h b/drivers/staging/media/wave5/wave5-vpuconfig.h
index 951ae3a95..fb1b199e1 100644
--- a/drivers/staging/media/wave5/wave5-vpuconfig.h
+++ b/drivers/staging/media/wave5/wave5-vpuconfig.h
@@ -82,7 +82,8 @@
 
 #define WAVE5_PROC_AXI_AXPROT       0x0
 #define WAVE5_PROC_AXI_AXCACHE      0x0
-#define WAVE5_PROC_AXI_EXT_ADDR     0x0
+//#define WAVE5_PROC_AXI_EXT_ADDR     0x0
+#define WAVE5_PROC_AXI_EXT_ADDR     0x8
 #define WAVE5_SEC_AXI_AXPROT        0x0
 #define WAVE5_SEC_AXI_AXCACHE       0x0
 #define WAVE5_SEC_AXI_EXT_ADDR      0x0
-- 
2.17.1

