From 6ea41c4225f92a1acfa8471d83df9e29d98ee757 Mon Sep 17 00:00:00 2001
From: Aniket Limaye <a-limaye@ti.com>
Date: Mon, 1 Aug 2022 23:42:12 +0530
Subject: [PATCH] drivers: staging: media: wave5: updating to patch-set v9

To be upstreamed by 8.5

---
 drivers/staging/media/wave5/TODO             |  26 +-
 drivers/staging/media/wave5/wave5-hw.c       |  43 +-
 drivers/staging/media/wave5/wave5-vpu-dec.c  | 474 +++++++++++--------
 drivers/staging/media/wave5/wave5-vpu-enc.c  | 263 +++++-----
 drivers/staging/media/wave5/wave5-vpu.c      | 153 +++---
 drivers/staging/media/wave5/wave5-vpuapi.c   | 122 +++--
 drivers/staging/media/wave5/wave5-vpuapi.h   |  26 +-
 drivers/staging/media/wave5/wave5-vpuerror.h |   6 +-
 drivers/staging/media/wave5/wave5.h          |   4 +
 9 files changed, 649 insertions(+), 468 deletions(-)

diff --git a/drivers/staging/media/wave5/TODO b/drivers/staging/media/wave5/TODO
index 070a1171b..308954740 100644
--- a/drivers/staging/media/wave5/TODO
+++ b/drivers/staging/media/wave5/TODO
@@ -1,22 +1,18 @@
-* Mutli-stream Test
-
-* Loop Test
-
 * Handle interrupts better
 
-  Currently the interrupt handling uses an unusual design employing a kfifo to
-  transfer irq status to irq thread. This was done as a work around for dropped
-  interrupts seen with IRQF_ONESHOT based handling.
+Currently the interrupt handling uses an unusual design employing a kfifo to
+transfer irq status to irq thread. This was done as a work around for dropped
+interrupts seen with IRQF_ONESHOT based handling.
 
-  This needs further investigation and fixing properly, with the aid of
-  C&M and StarFive engineers.
+This needs further investigation and fixing properly, with the aid of
+C&M and StarFive engineers.
 
-* appropreate error handling:
+* appropriate error handling:
 allocation failure, mutex acquire failure etc.
 
 * remove all unused struct fields
 
-* change struct fields to 'bool' type or bitfield when appropreate
+* change struct fields to 'bool' type or bitfield when appropriate
 Likely good candidates are fields named '*_enable' , '*_on'
 
 * handle vdi_allocate_dma_memory failure , each function has to clean after itself
@@ -31,4 +27,10 @@ and change s32 to u32 when s32 is not required
 * revise logic of wave5_vpu_(dec/enc)_register_framebuffer
 
 * check if the  normal kernel endianness/__swab32 routines are sufficient. (instead of the ones
-  implemented in the driver
+implemented in the driver
+
+* Extended Codec Controls for encoder.
+
+implement extended codec control for HEVC/H264 encoder.
+PROFILE/LEVEL/MIN_QP/MAX_QP/LOOP_FILTER/HFLIP/VFIIP/ROTATE/
+GOP_SIZE/RC_ENABLE/I_PERIOD/BITRATE.
diff --git a/drivers/staging/media/wave5/wave5-hw.c b/drivers/staging/media/wave5/wave5-hw.c
index dd070b149..e82d423e0 100644
--- a/drivers/staging/media/wave5/wave5-hw.c
+++ b/drivers/staging/media/wave5/wave5-hw.c
@@ -409,6 +409,7 @@ int wave5_vpu_build_up_dec_param(struct vpu_instance *vpu_inst,
 	struct dma_vpu_buf *sram_vb;
 	struct vpu_device *vpu_dev = vpu_inst->dev;
 
+	p_dec_info->cycle_per_tick = 256;
 	switch (vpu_inst->std) {
 	case W_HEVC_DEC:
 		p_dec_info->seq_change_mask = SEQ_CHANGE_ENABLE_ALL_HEVC;
@@ -502,8 +503,7 @@ int wave5_vpu_dec_init_seq(struct vpu_instance *vpu_inst)
 	bs_option = 0;
 	switch (p_dec_info->open_param.bitstream_mode) {
 	case BS_MODE_INTERRUPT:
-		if (p_dec_info->seq_init_escape)
-			bs_option = BSOPTION_ENABLE_EXPLICIT_END;
+		bs_option = BSOPTION_ENABLE_EXPLICIT_END;
 		break;
 	case BS_MODE_PIC_END:
 		bs_option = BSOPTION_ENABLE_EXPLICIT_END;
@@ -997,6 +997,7 @@ int wave5_vpu_decode(struct vpu_instance *vpu_inst, struct dec_param *option, u3
 	bs_option = 0;
 	switch (p_open_param->bitstream_mode) {
 	case BS_MODE_INTERRUPT:
+		bs_option = BSOPTION_ENABLE_EXPLICIT_END;
 		break;
 	case BS_MODE_PIC_END:
 		bs_option = BSOPTION_ENABLE_EXPLICIT_END;
@@ -1267,7 +1268,8 @@ int wave5_vpu_dec_get_result(struct vpu_instance *vpu_inst, struct dec_output_in
 		vpu_dev->last_performance_cycles = result->dec_decode_end_tick;
 		if (vpu_dev->last_performance_cycles < result->dec_host_cmd_tick)
 			result->frame_cycle =
-				(result->dec_decode_end_tick - result->dec_host_cmd_tick);
+				(result->dec_decode_end_tick - result->dec_host_cmd_tick) *
+				p_dec_info->cycle_per_tick;
 	}
 	result->seek_cycle =
 		(result->dec_seek_end_tick - result->dec_seek_start_tick) *
@@ -1728,6 +1730,26 @@ int wave5_dec_clr_disp_flag(struct vpu_instance *vpu_inst, unsigned int index)
 	return 0;
 }
 
+int wave5_dec_set_disp_flag(struct vpu_instance *vpu_inst, unsigned int index)
+{
+	int ret;
+
+	vpu_write_reg(vpu_inst->dev, W5_CMD_DEC_CLR_DISP_IDC, 0);
+	vpu_write_reg(vpu_inst->dev, W5_CMD_DEC_SET_DISP_IDC, BIT(index));
+	ret = wave5_send_query(vpu_inst, UPDATE_DISP_FLAG);
+
+	if (ret) {
+		if (ret == -EIO) {
+			u32 reg_val = vpu_read_reg(vpu_inst->dev, W5_RET_FAIL_REASON);
+
+			wave5_print_reg_err(vpu_inst->dev, reg_val);
+		}
+		return ret;
+	}
+
+	return 0;
+}
+
 int wave5_vpu_clear_interrupt(struct vpu_instance *vpu_inst, uint32_t flags)
 {
 	u32 interrupt_reason;
@@ -1751,6 +1773,17 @@ dma_addr_t wave5_vpu_dec_get_rd_ptr(struct vpu_instance *vpu_inst)
 	return vpu_read_reg(vpu_inst->dev, W5_RET_QUERY_DEC_BS_RD_PTR);
 }
 
+int wave5_dec_set_rd_ptr(struct vpu_instance *vpu_inst, dma_addr_t addr)
+{
+	int ret;
+
+	vpu_write_reg(vpu_inst->dev, W5_RET_QUERY_DEC_SET_BS_RD_PTR, addr);
+
+	ret = wave5_send_query(vpu_inst, SET_BS_RD_PTR);
+
+	return ret;
+}
+
 /************************************************************************/
 /* ENCODER functions */
 /************************************************************************/
@@ -1765,6 +1798,7 @@ int wave5_vpu_build_up_enc_param(struct device *dev, struct vpu_instance *vpu_in
 	u32 bs_endian;
 	struct vpu_device *vpu_dev = dev_get_drvdata(dev);
 
+	p_enc_info->cycle_per_tick = 256;
 	sram_vb = &vpu_dev->sram_buf;
 	p_enc_info->sec_axi_info.buf_base = sram_vb->daddr;
 	p_enc_info->sec_axi_info.buf_size = sram_vb->size;
@@ -3225,6 +3259,9 @@ int wave5_vpu_enc_check_open_param(struct vpu_instance *vpu_inst, struct enc_ope
 	pic_width = pop->pic_width;
 	pic_height = pop->pic_height;
 
+	if (vpu_inst->id > MAX_NUM_INSTANCE - 1)
+		return -EOPNOTSUPP;
+
 	if (vpu_inst->std != W_HEVC_ENC && vpu_inst->std != W_AVC_ENC)
 		return -EOPNOTSUPP;
 
diff --git a/drivers/staging/media/wave5/wave5-vpu-dec.c b/drivers/staging/media/wave5/wave5-vpu-dec.c
index f70c1ca9b..ffcab83fe 100644
--- a/drivers/staging/media/wave5/wave5-vpu-dec.c
+++ b/drivers/staging/media/wave5/wave5-vpu-dec.c
@@ -7,8 +7,8 @@
 
 #include "wave5-vpu.h"
 
-#define VPU_DEC_DEV_NAME "C&M VPU decoder"
-#define VPU_DEC_DRV_NAME "vpu-dec"
+#define VPU_DEC_DEV_NAME "C&M Wave5 VPU decoder"
+#define VPU_DEC_DRV_NAME "wave5-dec"
 #define V4L2_CID_VPU_THUMBNAIL_MODE (V4L2_CID_USER_BASE + 0x1001)
 
 static const struct vpu_format wave5_vpu_dec_fmt_list[2][6] = {
@@ -17,14 +17,14 @@ static const struct vpu_format wave5_vpu_dec_fmt_list[2][6] = {
 			.v4l2_pix_fmt = V4L2_PIX_FMT_HEVC,
 			.max_width = 8192,
 			.min_width = 8,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 8,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_H264,
 			.max_width = 8192,
 			.min_width = 32,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 32,
 		},
 	},
@@ -33,42 +33,42 @@ static const struct vpu_format wave5_vpu_dec_fmt_list[2][6] = {
 			.v4l2_pix_fmt = V4L2_PIX_FMT_YUV420,
 			.max_width = 8192,
 			.min_width = 8,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 8,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12,
 			.max_width = 8192,
 			.min_width = 8,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 8,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV21,
 			.max_width = 8192,
 			.min_width = 8,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 8,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_YUV420M,
 			.max_width = 8192,
 			.min_width = 8,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 8,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12M,
 			.max_width = 8192,
 			.min_width = 8,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 8,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV21M,
 			.max_width = 8192,
 			.min_width = 8,
-			.max_height = 8192,
+			.max_height = 4320,
 			.min_height = 8,
 		},
 	}
@@ -111,20 +111,17 @@ static const struct vpu_format *wave5_find_vpu_fmt_by_idx(unsigned int idx, enum
 
 static void wave5_handle_bitstream_buffer(struct vpu_instance *inst)
 {
-	struct v4l2_m2m_buffer *v4l2_m2m_buf = NULL;
-	unsigned long flags;
+	struct v4l2_m2m_buffer *buf, *n;
 	int ret;
 
-	spin_lock_irqsave(&inst->bitstream_lock, flags);
-
-	v4l2_m2m_for_each_src_buf(inst->v4l2_fh.m2m_ctx, v4l2_m2m_buf) {
-		struct vb2_v4l2_buffer *vbuf = &v4l2_m2m_buf->vb;
+	v4l2_m2m_for_each_src_buf_safe(inst->v4l2_fh.m2m_ctx, buf, n) {
+		struct vb2_v4l2_buffer *vbuf = &buf->vb;
 		struct vpu_buffer *vpu_buf = wave5_to_vpu_buf(vbuf);
 		u32 src_size = vb2_get_plane_payload(&vbuf->vb2_buf, 0);
 		void *src_buf = vb2_plane_vaddr(&vbuf->vb2_buf, 0);
-		dma_addr_t bs_rd_ptr = 0;
-		dma_addr_t bs_wr_ptr = 0;
-		u32 bs_remain_size = 0;
+		dma_addr_t rd_ptr = 0;
+		dma_addr_t wr_ptr = 0;
+		u32 remain_size = 0;
 		size_t offset;
 
 		if (vpu_buf->consumed) {
@@ -132,18 +129,18 @@ static void wave5_handle_bitstream_buffer(struct vpu_instance *inst)
 			continue;
 		}
 
-		wave5_vpu_dec_get_bitstream_buffer(inst, &bs_rd_ptr, &bs_wr_ptr, &bs_remain_size);
+		wave5_vpu_dec_get_bitstream_buffer(inst, &rd_ptr, &wr_ptr, &remain_size);
 
-		if (bs_remain_size < src_size) {
+		if (remain_size < src_size) {
 			dev_dbg(inst->dev->dev, "fill next time : remained size < source size.\n");
 			continue;
 		}
 
-		offset = bs_wr_ptr - inst->bitstream_vbuf.daddr;
-		if (bs_wr_ptr + src_size > inst->bitstream_vbuf.daddr + inst->bitstream_vbuf.size) {
+		offset = wr_ptr - inst->bitstream_vbuf.daddr;
+		if (wr_ptr + src_size > inst->bitstream_vbuf.daddr + inst->bitstream_vbuf.size) {
 			int size;
 
-			size = inst->bitstream_vbuf.daddr + inst->bitstream_vbuf.size - bs_wr_ptr;
+			size = inst->bitstream_vbuf.daddr + inst->bitstream_vbuf.size - wr_ptr;
 			wave5_vdi_write_memory(inst->dev, &inst->bitstream_vbuf, offset, src_buf,
 					       size, VDI_128BIT_LITTLE_ENDIAN);
 			wave5_vdi_write_memory(inst->dev, &inst->bitstream_vbuf, 0,
@@ -161,22 +158,13 @@ static void wave5_handle_bitstream_buffer(struct vpu_instance *inst)
 		}
 
 		vpu_buf->consumed = true;
-
-		if (inst->state == VPU_INST_STATE_WAIT_BUF)
-			inst->state = VPU_INST_STATE_PIC_RUN;
 	}
-
-	spin_unlock_irqrestore(&inst->bitstream_lock, flags);
 }
 
 static void wave5_handle_src_buffer(struct vpu_instance *inst)
 {
 	struct vb2_v4l2_buffer *src_buf;
 
-	unsigned long flags;
-
-	spin_lock_irqsave(&inst->bitstream_lock, flags);
-
 	src_buf = v4l2_m2m_next_src_buf(inst->v4l2_fh.m2m_ctx);
 	if (src_buf) {
 		struct vpu_buffer *vpu_buf = wave5_to_vpu_buf(src_buf);
@@ -188,7 +176,6 @@ static void wave5_handle_src_buffer(struct vpu_instance *inst)
 			v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_DONE);
 		}
 	}
-	spin_unlock_irqrestore(&inst->bitstream_lock, flags);
 }
 
 static void wave5_update_pix_fmt(struct v4l2_pix_format_mplane *pix_mp, unsigned int width,
@@ -202,20 +189,16 @@ static void wave5_update_pix_fmt(struct v4l2_pix_format_mplane *pix_mp, unsigned
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[0].sizeimage = width * height * 3 / 2;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
 		break;
 	case V4L2_PIX_FMT_YUV420M:
 		pix_mp->width = round_up(width, 32);
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[0].sizeimage = width * height;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
 		pix_mp->plane_fmt[1].bytesperline = round_up(width, 32) / 2;
 		pix_mp->plane_fmt[1].sizeimage = width * height / 4;
-		memset(&pix_mp->plane_fmt[1].reserved, 0, sizeof(pix_mp->plane_fmt[1].reserved));
 		pix_mp->plane_fmt[2].bytesperline = round_up(width, 32) / 2;
 		pix_mp->plane_fmt[2].sizeimage = width * height / 4;
-		memset(&pix_mp->plane_fmt[2].reserved, 0, sizeof(pix_mp->plane_fmt[2].reserved));
 		break;
 	case V4L2_PIX_FMT_NV12M:
 	case V4L2_PIX_FMT_NV21M:
@@ -223,17 +206,14 @@ static void wave5_update_pix_fmt(struct v4l2_pix_format_mplane *pix_mp, unsigned
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[0].sizeimage = width * height;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
 		pix_mp->plane_fmt[1].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[1].sizeimage = width * height / 2;
-		memset(&pix_mp->plane_fmt[1].reserved, 0, sizeof(pix_mp->plane_fmt[1].reserved));
 		break;
 	default:
 		pix_mp->width = width;
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = 0;
-		pix_mp->plane_fmt[0].sizeimage = width * height / 2;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
+		pix_mp->plane_fmt[0].sizeimage = width * height;
 		break;
 	}
 }
@@ -241,52 +221,45 @@ static void wave5_update_pix_fmt(struct v4l2_pix_format_mplane *pix_mp, unsigned
 static void wave5_vpu_dec_start_decode(struct vpu_instance *inst)
 {
 	struct dec_param pic_param;
-	u32 max_cmd_q = 0;
 	int ret;
+	u32 fail_res = 0;
 
 	memset(&pic_param, 0, sizeof(struct dec_param));
 
-	if (inst->state == VPU_INST_STATE_STOP) {
-		max_cmd_q = 1;
-	} else {
-		max_cmd_q = (inst->min_src_frame_buf_count < COMMAND_QUEUE_DEPTH) ?
-			inst->min_src_frame_buf_count : COMMAND_QUEUE_DEPTH;
-	}
-
-	while (max_cmd_q) {
-		u32 fail_res = 0;
+	if (inst->state == VPU_INST_STATE_INIT_SEQ) {
+		u32 non_linear_num = inst->dst_buf_count;
+		u32 linear_num = inst->dst_buf_count;
+		u32 stride = inst->dst_fmt.width;
 
-		ret = wave5_vpu_dec_start_one_frame(inst, &pic_param, &fail_res);
-		if (ret) {
-			struct vb2_v4l2_buffer *src_buf;
+		ret = wave5_vpu_dec_register_frame_buffer_ex(inst, non_linear_num, linear_num,
+							     stride, inst->dst_fmt.height,
+							     COMPRESSED_FRAME_MAP);
+		if (ret)
+			dev_dbg(inst->dev->dev, "fail vpu_dec_register_frame_buffer_ex %d", ret);
+	}
 
-			if (fail_res == WAVE5_SYSERR_QUEUEING_FAIL)
-				break;
+	ret = wave5_vpu_dec_start_one_frame(inst, &pic_param, &fail_res);
+	if (ret && fail_res != WAVE5_SYSERR_QUEUEING_FAIL) {
+		struct vb2_v4l2_buffer *src_buf;
 
-			src_buf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
-			inst->state = VPU_INST_STATE_STOP;
-			v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);
-			break;
-		}
-		max_cmd_q--;
+		src_buf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+		inst->state = VPU_INST_STATE_STOP;
+		v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);
 	}
 }
 
 static void wave5_vpu_dec_stop_decode(struct vpu_instance *inst)
 {
 	unsigned int i;
-	unsigned long flags;
 
 	inst->state = VPU_INST_STATE_STOP;
 
-	spin_lock_irqsave(&inst->bitstream_lock, flags);
 	wave5_vpu_dec_update_bitstream_buffer(inst, 0);
-	spin_unlock_irqrestore(&inst->bitstream_lock, flags);
 
-	for (i = 0; i < inst->min_dst_frame_buf_count; i++)
+	for (i = 0; i < inst->dst_buf_count; i++)
 		wave5_vpu_dec_clr_disp_flag(inst, i);
 
-	v4l2_m2m_job_finish(inst->dev->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
+	v4l2_m2m_job_finish(inst->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
 }
 
 static void wave5_vpu_dec_finish_decode(struct vpu_instance *inst)
@@ -295,28 +268,17 @@ static void wave5_vpu_dec_finish_decode(struct vpu_instance *inst)
 	int ret;
 	int irq_status;
 
-	if (kfifo_out(&inst->dev->irq_status, &irq_status, sizeof(int)))
+	if (kfifo_out(&inst->irq_status, &irq_status, sizeof(int)))
 		wave5_vpu_clear_interrupt_ex(inst, irq_status);
 
-	if (irq_status & BIT(INT_WAVE5_BSBUF_EMPTY)) {
-		dev_dbg(inst->dev->dev, "bitstream EMPTY!!!!\n");
-		inst->state = VPU_INST_STATE_WAIT_BUF;
-		wave5_handle_src_buffer(inst);
-		wave5_handle_bitstream_buffer(inst);
-	}
-
-	if (!(irq_status & BIT(INT_WAVE5_DEC_PIC)))
-		return;
 	ret = wave5_vpu_dec_get_output_info(inst, &dec_output_info);
 	if (ret) {
-		v4l2_m2m_job_finish(inst->dev->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
+		v4l2_m2m_job_finish(inst->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
 		return;
 	}
 	if (dec_output_info.index_frame_decoded == DECODED_IDX_FLAG_NO_FB &&
 	    dec_output_info.index_frame_display == DISPLAY_IDX_FLAG_NO_FB) {
 		dev_dbg(inst->dev->dev, "no more frame buffer\n");
-		if (inst->state != VPU_INST_STATE_STOP)
-			inst->state = VPU_INST_STATE_WAIT_BUF;
 	} else {
 		wave5_handle_src_buffer(inst);
 
@@ -347,7 +309,10 @@ static void wave5_vpu_dec_finish_decode(struct vpu_instance *inst)
 			dst_buf->vb2_buf.timestamp = inst->timestamp;
 			dst_buf->field = V4L2_FIELD_NONE;
 			v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);
-		} else if (dec_output_info.index_frame_display == DISPLAY_IDX_FLAG_SEQ_END) {
+
+			dev_dbg(inst->dev->dev, "frame_cycle %8d\n", dec_output_info.frame_cycle);
+		} else if (dec_output_info.index_frame_display == DISPLAY_IDX_FLAG_SEQ_END &&
+			   !inst->eos) {
 			static const struct v4l2_event vpu_event_eos = {
 				.type = V4L2_EVENT_EOS
 			};
@@ -379,10 +344,10 @@ static void wave5_vpu_dec_finish_decode(struct vpu_instance *inst)
 			dst_buf->field = V4L2_FIELD_NONE;
 			v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);
 
-			inst->state = VPU_INST_STATE_PIC_RUN;
+			inst->eos = TRUE;
 			v4l2_event_queue_fh(&inst->v4l2_fh, &vpu_event_eos);
 
-			v4l2_m2m_job_finish(inst->dev->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
+			v4l2_m2m_job_finish(inst->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
 		}
 	}
 }
@@ -683,38 +648,19 @@ static int wave5_vpu_dec_s_selection(struct file *file, void *fh, struct v4l2_se
 {
 	struct vpu_instance *inst = wave5_to_vpu_inst(fh);
 
-	dev_dbg(inst->dev->dev, "type : %d | target : %d\n", s->type, s->target);
-
 	if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
 		return -EINVAL;
 
 	if (s->target != V4L2_SEL_TGT_COMPOSE)
 		return -EINVAL;
 
-	dev_dbg(inst->dev->dev, "V4L2_SEL_TGT_COMPOSE w: %d h: %d\n", s->r.width, s->r.height);
-	inst->dst_fmt.width = s->r.width;
-	inst->dst_fmt.height = s->r.height;
-
-	return 0;
-}
+	dev_dbg(inst->dev->dev, "V4L2_SEL_TGT_COMPOSE w: %d h: %d\n",
+		s->r.width, s->r.height);
 
-static int wave5_vpu_dec_try_decoder_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *dc)
-{
-	struct vpu_instance *inst = wave5_to_vpu_inst(fh);
-
-	dev_dbg(inst->dev->dev, "decoder command : %d\n", dc->cmd);
-
-	if (dc->cmd != V4L2_DEC_CMD_STOP && dc->cmd != V4L2_DEC_CMD_START)
-		return -EINVAL;
-
-	dc->flags = 0;
-
-	if (dc->cmd == V4L2_DEC_CMD_STOP) {
-		dc->stop.pts = 0;
-	} else if (dc->cmd == V4L2_DEC_CMD_START) {
-		dc->start.speed = 0;
-		dc->start.format = V4L2_DEC_START_FMT_NONE;
-	}
+	s->r.left = 0;
+	s->r.top = 0;
+	s->r.width = inst->dst_fmt.width;
+	s->r.height = inst->dst_fmt.height;
 
 	return 0;
 }
@@ -723,12 +669,11 @@ static int wave5_vpu_dec_decoder_cmd(struct file *file, void *fh, struct v4l2_de
 {
 	struct vpu_instance *inst = wave5_to_vpu_inst(fh);
 	int ret;
-	unsigned long flags;
 
 	dev_dbg(inst->dev->dev, "decoder command : %d\n", dc->cmd);
 
-	ret = wave5_vpu_dec_try_decoder_cmd(file, fh, dc);
-	if (ret < 0)
+	ret = v4l2_m2m_ioctl_try_decoder_cmd(file, fh, dc);
+	if (ret)
 		return ret;
 
 	if (!wave5_vpu_both_queues_are_streaming(inst))
@@ -738,9 +683,7 @@ static int wave5_vpu_dec_decoder_cmd(struct file *file, void *fh, struct v4l2_de
 	case V4L2_DEC_CMD_STOP:
 		inst->state = VPU_INST_STATE_STOP;
 
-		spin_lock_irqsave(&inst->bitstream_lock, flags);
 		wave5_vpu_dec_update_bitstream_buffer(inst, 0);
-		spin_unlock_irqrestore(&inst->bitstream_lock, flags);
 		break;
 	case V4L2_DEC_CMD_START:
 		break;
@@ -797,33 +740,13 @@ static const struct v4l2_ioctl_ops wave5_vpu_dec_ioctl_ops = {
 	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
 	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
 
-	.vidioc_try_decoder_cmd = wave5_vpu_dec_try_decoder_cmd,
+	.vidioc_try_decoder_cmd = v4l2_m2m_ioctl_try_decoder_cmd,
 	.vidioc_decoder_cmd = wave5_vpu_dec_decoder_cmd,
 
 	.vidioc_subscribe_event = wave5_vpu_dec_subscribe_event,
 	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
 };
 
-static int wave5_vpu_dec_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct vpu_instance *inst = wave5_ctrl_to_vpu_inst(ctrl);
-
-	dev_dbg(inst->dev->dev, "name : %s\n", ctrl->name);
-
-	switch (ctrl->id) {
-	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
-		if (inst->state != VPU_INST_STATE_NONE && inst->state != VPU_INST_STATE_OPEN)
-			ctrl->val = inst->min_dst_frame_buf_count;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	dev_dbg(inst->dev->dev, "value : %d\n", ctrl->val);
-
-	return 0;
-}
-
 static int wave5_vpu_dec_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct vpu_instance *inst = wave5_ctrl_to_vpu_inst(ctrl);
@@ -834,6 +757,8 @@ static int wave5_vpu_dec_s_ctrl(struct v4l2_ctrl *ctrl)
 	case V4L2_CID_VPU_THUMBNAIL_MODE:
 		inst->thumbnail_mode = ctrl->val;
 		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_CAPTURE:
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -842,7 +767,6 @@ static int wave5_vpu_dec_s_ctrl(struct v4l2_ctrl *ctrl)
 }
 
 static const struct v4l2_ctrl_ops wave5_vpu_dec_ctrl_ops = {
-	.g_volatile_ctrl = wave5_vpu_dec_g_volatile_ctrl,
 	.s_ctrl = wave5_vpu_dec_s_ctrl,
 };
 
@@ -867,7 +791,7 @@ static void wave5_set_default_dec_openparam(struct dec_open_param *open_param)
 
 static int wave5_vpu_dec_queue_setup(struct vb2_queue *q, unsigned int *num_buffers,
 				     unsigned int *num_planes, unsigned int sizes[],
-			 struct device *alloc_devs[])
+				     struct device *alloc_devs[])
 {
 	struct vpu_instance *inst = vb2_get_drv_priv(q);
 	struct v4l2_pix_format_mplane inst_format =
@@ -941,14 +865,18 @@ static int wave5_vpu_dec_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 		if (inst->thumbnail_mode)
 			wave5_vpu_dec_give_command(inst, ENABLE_DEC_THUMBNAIL_MODE, NULL);
 
-		inst->min_src_frame_buf_count = *num_buffers;
 	} else if (inst->state == VPU_INST_STATE_INIT_SEQ &&
-		q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
-		u32 non_linear_num = inst->min_dst_frame_buf_count;
+		   q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		u32 non_linear_num;
 		u32 fb_stride, fb_height;
 		u32 luma_size, chroma_size;
 
-		*num_buffers = inst->min_dst_frame_buf_count;
+		if (*num_buffers > inst->min_dst_buf_count &&
+		    *num_buffers < WAVE5_MAX_FBS)
+			inst->dst_buf_count = *num_buffers;
+
+		*num_buffers = inst->dst_buf_count;
+		non_linear_num = inst->dst_buf_count;
 
 		for (i = 0; i < non_linear_num; i++) {
 			struct frame_buffer *frame = &inst->frame_buf[i];
@@ -976,17 +904,21 @@ static int wave5_vpu_dec_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 			frame->map_type = COMPRESSED_FRAME_MAP;
 			frame->update_fb_info = true;
 		}
+	} else if (inst->state == VPU_INST_STATE_STOP &&
+		   q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		*num_buffers = 0;
 	}
 
 	return 0;
 }
 
-static void wave5_vpu_dec_start_streaming_inst_open(struct vb2_queue *q, unsigned int count)
+static void wave5_vpu_dec_start_streaming_open(struct vpu_instance *inst)
 {
 	struct dec_initial_info initial_info;
-	struct vpu_instance *inst = vb2_get_drv_priv(q);
 	int ret;
 
+	memset(&initial_info, 0, sizeof(struct dec_initial_info));
+
 	ret = wave5_vpu_dec_issue_seq_init(inst);
 	if (ret)
 		dev_dbg(inst->dev->dev, "failed wave5_vpu_dec_issue_seq_init %d\n", ret);
@@ -1003,13 +935,20 @@ static void wave5_vpu_dec_start_streaming_inst_open(struct vb2_queue *q, unsigne
 			.type = V4L2_EVENT_SOURCE_CHANGE,
 			.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
 		};
+		struct v4l2_ctrl *ctrl;
 
 		dev_dbg(inst->dev->dev, "width %d height %d profile %d | minbuffer : %u\n",
 			initial_info.pic_width, initial_info.pic_height,
 			initial_info.profile, initial_info.min_frame_buffer_count);
 
 		inst->state = VPU_INST_STATE_INIT_SEQ;
-		inst->min_dst_frame_buf_count = initial_info.min_frame_buffer_count + 1;
+		inst->min_dst_buf_count = initial_info.min_frame_buffer_count + 1;
+		inst->dst_buf_count = inst->min_dst_buf_count;
+
+		ctrl = v4l2_ctrl_find(&inst->v4l2_ctrl_hdl,
+				      V4L2_CID_MIN_BUFFERS_FOR_CAPTURE);
+		if (ctrl)
+			v4l2_ctrl_s_ctrl(ctrl, inst->min_dst_buf_count);
 
 		if (initial_info.pic_width != inst->src_fmt.width ||
 		    initial_info.pic_height != inst->src_fmt.height) {
@@ -1019,37 +958,103 @@ static void wave5_vpu_dec_start_streaming_inst_open(struct vb2_queue *q, unsigne
 					     initial_info.pic_height);
 		}
 		v4l2_event_queue_fh(&inst->v4l2_fh, &vpu_event_src_ch);
+
+		wave5_handle_src_buffer(inst);
 	}
 }
 
-static void wave5_vpu_dec_buf_queue(struct vb2_buffer *vb)
+static void wave5_vpu_dec_start_streaming_seek(struct vpu_instance *inst)
+{
+	struct dec_initial_info initial_info;
+	struct dec_param pic_param;
+	struct dec_output_info dec_output_info;
+	int ret;
+	u32 fail_res = 0;
+
+	memset(&pic_param, 0, sizeof(struct dec_param));
+
+	ret = wave5_vpu_dec_start_one_frame(inst, &pic_param, &fail_res);
+	if (ret && fail_res != WAVE5_SYSERR_QUEUEING_FAIL) {
+		struct vb2_v4l2_buffer *src_buf;
+
+		src_buf = v4l2_m2m_src_buf_remove(inst->v4l2_fh.m2m_ctx);
+		inst->state = VPU_INST_STATE_STOP;
+		v4l2_m2m_buf_done(src_buf, VB2_BUF_STATE_ERROR);
+		dev_dbg(inst->dev->dev, "wave5_vpu_dec_start_one_frame\n");
+		return;
+	}
+
+	if (wave5_vpu_wait_interrupt(inst, VPU_DEC_TIMEOUT) < 0)
+		dev_dbg(inst->dev->dev, "failed to call vpu_wait_interrupt()\n");
+
+	ret = wave5_vpu_dec_get_output_info(inst, &dec_output_info);
+	if (ret) {
+		dev_dbg(inst->dev->dev, "wave5_vpu_dec_get_output_info: %d\n", ret);
+		return;
+	}
+
+	if (dec_output_info.sequence_changed) {
+		static const struct v4l2_event vpu_event_src_ch = {
+			.type = V4L2_EVENT_SOURCE_CHANGE,
+			.u.src_change.changes = V4L2_EVENT_SRC_CH_RESOLUTION,
+		};
+		struct v4l2_ctrl *ctrl;
+
+		wave5_vpu_dec_give_command(inst, DEC_RESET_FRAMEBUF_INFO, NULL);
+		wave5_vpu_dec_give_command(inst, DEC_GET_SEQ_INFO, &initial_info);
+
+		dev_dbg(inst->dev->dev, "width %d height %d profile %d | minbuffer : %u\n",
+			initial_info.pic_width, initial_info.pic_height,
+			initial_info.profile, initial_info.min_frame_buffer_count);
+
+		inst->min_dst_buf_count = initial_info.min_frame_buffer_count + 1;
+		inst->dst_buf_count = inst->min_dst_buf_count;
+
+		ctrl = v4l2_ctrl_find(&inst->v4l2_ctrl_hdl,
+				      V4L2_CID_MIN_BUFFERS_FOR_CAPTURE);
+		if (ctrl)
+			v4l2_ctrl_s_ctrl(ctrl, inst->min_dst_buf_count);
+
+		if (initial_info.pic_width != inst->src_fmt.width ||
+		    initial_info.pic_height != inst->src_fmt.height) {
+			wave5_update_pix_fmt(&inst->src_fmt, initial_info.pic_width,
+					     initial_info.pic_height);
+			wave5_update_pix_fmt(&inst->dst_fmt, initial_info.pic_width,
+					     initial_info.pic_height);
+		}
+		v4l2_event_queue_fh(&inst->v4l2_fh, &vpu_event_src_ch);
+
+		wave5_handle_src_buffer(inst);
+	}
+}
+
+static void wave5_vpu_dec_buf_queue_src(struct vb2_buffer *vb)
 {
 	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
 	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
 	struct vpu_buffer *vpu_buf = wave5_to_vpu_buf(vbuf);
 
-	dev_dbg(inst->dev->dev, "type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
-		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
-		vb2_plane_size(&vbuf->vb2_buf, 1), vb2_plane_size(&vbuf->vb2_buf, 2));
-
-	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
+	vpu_buf->consumed = false;
+	vbuf->sequence = inst->queued_src_buf_num++;
 
-	if (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
-		vpu_buf->consumed = false;
+	if (inst->state == VPU_INST_STATE_PIC_RUN) {
 		wave5_handle_bitstream_buffer(inst);
-		vbuf->sequence = inst->queued_src_buf_num++;
-
-		if (inst->state == VPU_INST_STATE_PIC_RUN)
-			inst->ops->start_process(inst);
+		inst->ops->start_process(inst);
 	}
+}
 
-	if (vb->type != V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
-		return;
+static void wave5_vpu_dec_buf_queue_dst(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
+
+	vbuf->sequence = inst->queued_dst_buf_num++;
+	wave5_vpu_dec_clr_disp_flag(inst, vb->index);
 
 	if (inst->state == VPU_INST_STATE_INIT_SEQ) {
 		dma_addr_t buf_addr_y = 0, buf_addr_cb = 0, buf_addr_cr = 0;
 		u32 buf_size = 0;
-		u32 non_linear_num = inst->min_dst_frame_buf_count;
+		u32 non_linear_num = inst->dst_buf_count;
 		u32 fb_stride = inst->dst_fmt.width;
 		u32 luma_size = fb_stride * inst->dst_fmt.height;
 		u32 chroma_size = (fb_stride / 2) * (inst->dst_fmt.height / 2);
@@ -1083,42 +1088,42 @@ static void wave5_vpu_dec_buf_queue(struct vb2_buffer *vb)
 		inst->frame_buf[vb->index + non_linear_num].update_fb_info = true;
 	}
 
-	if (inst->state == VPU_INST_STATE_PIC_RUN ||
-	    inst->state == VPU_INST_STATE_STOP ||
-	    inst->state == VPU_INST_STATE_WAIT_BUF) {
-		wave5_vpu_dec_clr_disp_flag(inst, vb->index);
-		if (inst->state == VPU_INST_STATE_WAIT_BUF)
-			inst->state = VPU_INST_STATE_PIC_RUN;
-		if (inst->state == VPU_INST_STATE_STOP)
-			inst->ops->start_process(inst);
-	}
-	vbuf->sequence = inst->queued_dst_buf_num++;
+	if (!vb2_is_streaming(vb->vb2_queue))
+		return;
+
+	if (inst->state == VPU_INST_STATE_STOP && inst->eos == FALSE)
+		inst->ops->start_process(inst);
 }
 
-static int wave5_vpu_dec_start_streaming(struct vb2_queue *q, unsigned int count)
+static void wave5_vpu_dec_buf_queue(struct vb2_buffer *vb)
 {
-	struct vpu_instance *inst = vb2_get_drv_priv(q);
-	int ret;
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vpu_instance *inst = vb2_get_drv_priv(vb->vb2_queue);
 
-	dev_dbg(inst->dev->dev, "type : %d\n", q->type);
+	dev_dbg(inst->dev->dev, "type %4d index %4d size[0] %4ld size[1] : %4ld | size[2] : %4ld\n",
+		vb->type, vb->index, vb2_plane_size(&vbuf->vb2_buf, 0),
+		vb2_plane_size(&vbuf->vb2_buf, 1), vb2_plane_size(&vbuf->vb2_buf, 2));
 
-	if (inst->state == VPU_INST_STATE_OPEN)
-		wave5_vpu_dec_start_streaming_inst_open(q, count);
+	v4l2_m2m_buf_queue(inst->v4l2_fh.m2m_ctx, vbuf);
 
-	if (inst->state == VPU_INST_STATE_INIT_SEQ &&
-	    q->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
-		u32 non_linear_num = inst->min_dst_frame_buf_count;
-		u32 linear_num = inst->min_dst_frame_buf_count;
-		u32 stride = inst->dst_fmt.width;
+	if (vb->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE)
+		wave5_vpu_dec_buf_queue_src(vb);
+	else if (vb->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE)
+		wave5_vpu_dec_buf_queue_dst(vb);
+}
 
-		dev_dbg(inst->dev->dev, "stride %d dst height %d\n", stride, inst->dst_fmt.height);
-		ret = wave5_vpu_dec_register_frame_buffer_ex(inst, non_linear_num, linear_num,
-							     stride, inst->dst_fmt.height,
-							    COMPRESSED_FRAME_MAP);
-		if (ret)
-			dev_dbg(inst->dev->dev, "fail vpu_dec_register_frame_buffer_ex %d", ret);
+static int wave5_vpu_dec_start_streaming(struct vb2_queue *q, unsigned int count)
+{
+	struct vpu_instance *inst = vb2_get_drv_priv(q);
 
-		inst->state = VPU_INST_STATE_PIC_RUN;
+	dev_dbg(inst->dev->dev, "type : %d\n", q->type);
+
+	if (q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		wave5_handle_bitstream_buffer(inst);
+		if (inst->state == VPU_INST_STATE_OPEN)
+			wave5_vpu_dec_start_streaming_open(inst);
+		else if (inst->state == VPU_INST_STATE_INIT_SEQ)
+			wave5_vpu_dec_start_streaming_seek(inst);
 	}
 
 	return 0;
@@ -1132,9 +1137,6 @@ static void wave5_vpu_dec_stop_streaming(struct vb2_queue *q)
 
 	dev_dbg(inst->dev->dev, "type : %d\n", q->type);
 
-	if (wave5_vpu_both_queues_are_streaming(inst))
-		inst->state = VPU_INST_STATE_STOP;
-
 	while (check_cmd) {
 		struct queue_status_info q_status;
 		struct dec_output_info dec_output_info;
@@ -1157,7 +1159,11 @@ static void wave5_vpu_dec_stop_streaming(struct vb2_queue *q)
 				buf->vb2_buf.index);
 			v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
 		}
+		inst->queued_src_buf_num = 0;
 	} else {
+		int i;
+		dma_addr_t rd_ptr, wr_ptr;
+
 		while ((buf = v4l2_m2m_dst_buf_remove(inst->v4l2_fh.m2m_ctx))) {
 			u32 plane;
 
@@ -1169,6 +1175,17 @@ static void wave5_vpu_dec_stop_streaming(struct vb2_queue *q)
 
 			v4l2_m2m_buf_done(buf, VB2_BUF_STATE_ERROR);
 		}
+
+		for (i = 0; i < inst->dst_buf_count; i++)
+			wave5_vpu_dec_set_disp_flag(inst, i);
+
+		wave5_vpu_dec_get_bitstream_buffer(inst, &rd_ptr, &wr_ptr, NULL);
+		wave5_vpu_dec_set_rd_ptr(inst, wr_ptr, TRUE);
+		if (inst->eos) {
+			inst->eos = FALSE;
+			inst->state = VPU_INST_STATE_INIT_SEQ;
+		}
+		inst->queued_dst_buf_num = 0;
 	}
 }
 
@@ -1206,13 +1223,11 @@ static int wave5_vpu_dec_queue_init(void *priv, struct vb2_queue *src_vq, struct
 	int ret;
 
 	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
-	src_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
 	src_vq->mem_ops = &vb2_dma_contig_memops;
 	src_vq->ops = &wave5_vpu_dec_vb2_ops;
 	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	src_vq->buf_struct_size = sizeof(struct vpu_buffer);
-	src_vq->allow_zero_bytesused = 1;
-	src_vq->min_buffers_needed = 0;
 	src_vq->drv_priv = inst;
 	src_vq->lock = &inst->dev->dev_lock;
 	src_vq->dev = inst->dev->v4l2_dev.dev;
@@ -1221,13 +1236,11 @@ static int wave5_vpu_dec_queue_init(void *priv, struct vb2_queue *src_vq, struct
 		return ret;
 
 	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
-	dst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
 	dst_vq->mem_ops = &vb2_dma_contig_memops;
 	dst_vq->ops = &wave5_vpu_dec_vb2_ops;
 	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	dst_vq->buf_struct_size = sizeof(struct vpu_buffer);
-	dst_vq->allow_zero_bytesused = 1;
-	dst_vq->min_buffers_needed = 0;
 	dst_vq->drv_priv = inst;
 	dst_vq->lock = &inst->dev->dev_lock;
 	dst_vq->dev = inst->dev->v4l2_dev.dev;
@@ -1244,12 +1257,32 @@ static const struct vpu_instance_ops wave5_vpu_dec_inst_ops = {
 	.finish_process = wave5_vpu_dec_finish_decode,
 };
 
+static void wave5_vpu_dec_device_run(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	inst->ops->start_process(inst);
+
+	inst->state = VPU_INST_STATE_PIC_RUN;
+}
+
+static void wave5_vpu_dec_job_abort(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	inst->ops->stop_process(inst);
+}
+
+static const struct v4l2_m2m_ops wave5_vpu_dec_m2m_ops = {
+	.device_run = wave5_vpu_dec_device_run,
+	.job_abort = wave5_vpu_dec_job_abort,
+};
+
 static int wave5_vpu_open_dec(struct file *filp)
 {
 	struct video_device *vdev = video_devdata(filp);
 	struct vpu_device *dev = video_drvdata(filp);
 	struct vpu_instance *inst = NULL;
-	struct v4l2_ctrl *ctrl;
 	int ret;
 
 	inst = kzalloc(sizeof(*inst), GFP_KERNEL);
@@ -1260,29 +1293,35 @@ static int wave5_vpu_open_dec(struct file *filp)
 	inst->type = VPU_INST_TYPE_DEC;
 	inst->ops = &wave5_vpu_dec_inst_ops;
 
-	spin_lock_init(&inst->bitstream_lock);
-
 	v4l2_fh_init(&inst->v4l2_fh, vdev);
 	filp->private_data = &inst->v4l2_fh;
 	v4l2_fh_add(&inst->v4l2_fh);
 
+	INIT_LIST_HEAD(&inst->list);
+	list_add_tail(&inst->list, &dev->instances);
+
+	inst->v4l2_m2m_dev = v4l2_m2m_init(&wave5_vpu_dec_m2m_ops);
+	if (IS_ERR(inst->v4l2_m2m_dev)) {
+		ret = PTR_ERR(inst->v4l2_m2m_dev);
+		dev_err(inst->dev->dev, "v4l2_m2m_init fail: %d\n", ret);
+		goto free_inst;
+	}
+
 	inst->v4l2_fh.m2m_ctx =
-		v4l2_m2m_ctx_init(dev->v4l2_m2m_dev, inst, wave5_vpu_dec_queue_init);
+		v4l2_m2m_ctx_init(inst->v4l2_m2m_dev, inst, wave5_vpu_dec_queue_init);
 	if (IS_ERR(inst->v4l2_fh.m2m_ctx)) {
 		ret = PTR_ERR(inst->v4l2_fh.m2m_ctx);
-		goto free_inst;
+		goto err_m2m_release;
 	}
 
 	v4l2_ctrl_handler_init(&inst->v4l2_ctrl_hdl, 10);
 	v4l2_ctrl_new_custom(&inst->v4l2_ctrl_hdl, &wave5_vpu_thumbnail_mode, NULL);
-	ctrl = v4l2_ctrl_new_std(&inst->v4l2_ctrl_hdl, &wave5_vpu_dec_ctrl_ops,
-				 V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 1);
-	if (ctrl)
-		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	v4l2_ctrl_new_std(&inst->v4l2_ctrl_hdl, &wave5_vpu_dec_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_CAPTURE, 1, 32, 1, 1);
 
 	if (inst->v4l2_ctrl_hdl.error) {
 		ret = -ENODEV;
-		goto free_inst;
+		goto err_m2m_release;
 	}
 
 	inst->v4l2_fh.ctrl_handler = &inst->v4l2_ctrl_hdl;
@@ -1295,8 +1334,25 @@ static int wave5_vpu_open_dec(struct file *filp)
 	inst->quantization = V4L2_QUANTIZATION_DEFAULT;
 	inst->xfer_func = V4L2_XFER_FUNC_DEFAULT;
 
+	init_completion(&inst->irq_done);
+	if (kfifo_alloc(&inst->irq_status, 16 * sizeof(int), GFP_KERNEL)) {
+		dev_err(inst->dev->dev, "failed to allocate fifo\n");
+		goto err_m2m_release;
+	}
+
+	inst->id = ida_alloc(&inst->dev->inst_ida, GFP_KERNEL);
+	if (inst->id < 0) {
+		dev_warn(inst->dev->dev, "unable to allocate instance ID: %d\n", inst->id);
+		ret = inst->id;
+		goto err_kfifo_free;
+	}
+
 	return 0;
 
+err_kfifo_free:
+	kfifo_free(&inst->irq_status);
+err_m2m_release:
+	v4l2_m2m_release(inst->v4l2_m2m_dev);
 free_inst:
 	kfree(inst);
 	return ret;
@@ -1328,13 +1384,17 @@ static int wave5_vpu_dec_release(struct file *filp)
 			dev_warn(inst->dev->dev, "close fail ret=%d\n", ret);
 	}
 
-	for (i = 0; i < inst->min_dst_frame_buf_count; i++)
+	for (i = 0; i < inst->dst_buf_count; i++)
 		wave5_vdi_free_dma_memory(inst->dev, &inst->frame_vbuf[i]);
 
 	wave5_vdi_free_dma_memory(inst->dev, &inst->bitstream_vbuf);
 	v4l2_ctrl_handler_free(&inst->v4l2_ctrl_hdl);
+	v4l2_m2m_release(inst->v4l2_m2m_dev);
 	v4l2_fh_del(&inst->v4l2_fh);
 	v4l2_fh_exit(&inst->v4l2_fh);
+	list_del_init(&inst->list);
+	kfifo_free(&inst->irq_status);
+	ida_free(&inst->dev->inst_ida, inst->id);
 	kfree(inst);
 
 	return 0;
diff --git a/drivers/staging/media/wave5/wave5-vpu-enc.c b/drivers/staging/media/wave5/wave5-vpu-enc.c
index acd2cb902..84cfcfcc6 100644
--- a/drivers/staging/media/wave5/wave5-vpu-enc.c
+++ b/drivers/staging/media/wave5/wave5-vpu-enc.c
@@ -7,68 +7,68 @@
 
 #include "wave5-vpu.h"
 
-#define VPU_ENC_DEV_NAME "C&M VPU encoder"
-#define VPU_ENC_DRV_NAME "vpu-enc"
+#define VPU_ENC_DEV_NAME "C&M Wave5 VPU encoder"
+#define VPU_ENC_DRV_NAME "wave5-enc"
 
 static const struct vpu_format wave5_vpu_enc_fmt_list[2][6] = {
 	[VPU_FMT_TYPE_CODEC] = {
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_HEVC,
-			.max_width = 8192,
-			.min_width = 8,
-			.max_height = 8192,
-			.min_height = 8,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_H264,
-			.max_width = 8192,
-			.min_width = 32,
-			.max_height = 8192,
-			.min_height = 32,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 	},
 	[VPU_FMT_TYPE_RAW] = {
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_YUV420,
-			.max_width = 8192,
-			.min_width = 8,
-			.max_height = 8192,
-			.min_height = 8,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12,
-			.max_width = 8192,
-			.min_width = 8,
-			.max_height = 8192,
-			.min_height = 8,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV21,
-			.max_width = 8192,
-			.min_width = 8,
-			.max_height = 8192,
-			.min_height = 8,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_YUV420M,
-			.max_width = 8192,
-			.min_width = 8,
-			.max_height = 8192,
-			.min_height = 8,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV12M,
-			.max_width = 8192,
-			.min_width = 8,
-			.max_height = 8192,
-			.min_height = 8,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 		{
 			.v4l2_pix_fmt = V4L2_PIX_FMT_NV21M,
-			.max_width = 8192,
-			.min_width = 8,
-			.max_height = 8192,
-			.min_height = 8,
+			.max_width = W5_MAX_ENC_PIC_WIDTH,
+			.min_width = W5_MIN_ENC_PIC_WIDTH,
+			.max_height = W5_MAX_ENC_PIC_HEIGHT,
+			.min_height = W5_MIN_ENC_PIC_HEIGHT,
 		},
 	}
 };
@@ -156,42 +156,35 @@ static void wave5_update_pix_fmt(struct v4l2_pix_format_mplane *pix_mp, unsigned
 	case V4L2_PIX_FMT_YUV420:
 	case V4L2_PIX_FMT_NV12:
 	case V4L2_PIX_FMT_NV21:
-		pix_mp->width = round_up(width, 32);
+		pix_mp->width = width;
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[0].sizeimage = round_up(width, 32) * height * 3 / 2;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
 		break;
 	case V4L2_PIX_FMT_YUV420M:
-		pix_mp->width = round_up(width, 32);
+		pix_mp->width = width;
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[0].sizeimage = round_up(width, 32) * height;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
 		pix_mp->plane_fmt[1].bytesperline = round_up(width, 32) / 2;
 		pix_mp->plane_fmt[1].sizeimage = round_up(width, 32) * height / 4;
-		memset(&pix_mp->plane_fmt[1].reserved, 0, sizeof(pix_mp->plane_fmt[1].reserved));
 		pix_mp->plane_fmt[2].bytesperline = round_up(width, 32) / 2;
 		pix_mp->plane_fmt[2].sizeimage = round_up(width, 32) * height / 4;
-		memset(&pix_mp->plane_fmt[2].reserved, 0, sizeof(pix_mp->plane_fmt[2].reserved));
 		break;
 	case V4L2_PIX_FMT_NV12M:
 	case V4L2_PIX_FMT_NV21M:
-		pix_mp->width = round_up(width, 32);
+		pix_mp->width = width;
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[0].sizeimage = round_up(width, 32) * height;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
 		pix_mp->plane_fmt[1].bytesperline = round_up(width, 32);
 		pix_mp->plane_fmt[1].sizeimage = round_up(width, 32) * height / 2;
-		memset(&pix_mp->plane_fmt[1].reserved, 0, sizeof(pix_mp->plane_fmt[1].reserved));
 		break;
 	default:
-		pix_mp->width = round_up(width, 32);
+		pix_mp->width = width;
 		pix_mp->height = height;
 		pix_mp->plane_fmt[0].bytesperline = 0;
-		pix_mp->plane_fmt[0].sizeimage = round_up(width, 32) * height;
-		memset(&pix_mp->plane_fmt[0].reserved, 0, sizeof(pix_mp->plane_fmt[0].reserved));
+		pix_mp->plane_fmt[0].sizeimage = width * height;
 		break;
 	}
 }
@@ -201,8 +194,8 @@ static void wave5_vpu_enc_start_encode(struct vpu_instance *inst)
 	int ret;
 	u32 max_cmd_q = 0;
 
-	max_cmd_q = (inst->min_src_frame_buf_count < COMMAND_QUEUE_DEPTH) ?
-		inst->min_src_frame_buf_count : COMMAND_QUEUE_DEPTH;
+	max_cmd_q = (inst->src_buf_count < COMMAND_QUEUE_DEPTH) ?
+		inst->src_buf_count : COMMAND_QUEUE_DEPTH;
 
 	if (inst->state == VPU_INST_STATE_STOP)
 		max_cmd_q = 1;
@@ -214,8 +207,9 @@ static void wave5_vpu_enc_start_encode(struct vpu_instance *inst)
 		struct vpu_buffer *dst_vbuf;
 		struct frame_buffer frame_buf;
 		struct enc_param pic_param;
-		u32 luma_size = (inst->dst_fmt.width * inst->dst_fmt.height);
-		u32 chroma_size = ((inst->dst_fmt.width / 2) * (inst->dst_fmt.height / 2));
+		u32 stride = ALIGN(inst->dst_fmt.width, 32);
+		u32 luma_size = (stride * inst->dst_fmt.height);
+		u32 chroma_size = ((stride / 2) * (inst->dst_fmt.height / 2));
 		u32 fail_res;
 
 		memset(&pic_param, 0, sizeof(struct enc_param));
@@ -262,7 +256,7 @@ static void wave5_vpu_enc_start_encode(struct vpu_instance *inst)
 				frame_buf.buf_cr =
 					vb2_dma_contig_plane_dma_addr(&src_buf->vb2_buf, 2);
 			}
-			frame_buf.stride = inst->dst_fmt.width;
+			frame_buf.stride = stride;
 			pic_param.src_idx = src_buf->vb2_buf.index;
 		}
 
@@ -296,7 +290,7 @@ static void wave5_vpu_enc_stop_encode(struct vpu_instance *inst)
 {
 	inst->state = VPU_INST_STATE_STOP;
 
-	v4l2_m2m_job_finish(inst->dev->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
+	v4l2_m2m_job_finish(inst->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
 }
 
 static void wave5_vpu_enc_finish_encode(struct vpu_instance *inst)
@@ -307,7 +301,7 @@ static void wave5_vpu_enc_finish_encode(struct vpu_instance *inst)
 	struct vb2_v4l2_buffer *dst_buf = NULL;
 	struct v4l2_m2m_buffer *v4l2_m2m_buf = NULL;
 
-	if (kfifo_out(&inst->dev->irq_status, &irq_status, sizeof(int)))
+	if (kfifo_out(&inst->irq_status, &irq_status, sizeof(int)))
 		wave5_vpu_clear_interrupt_ex(inst, irq_status);
 
 	ret = wave5_vpu_enc_get_output_info(inst, &enc_output_info);
@@ -348,7 +342,7 @@ static void wave5_vpu_enc_finish_encode(struct vpu_instance *inst)
 		inst->state = VPU_INST_STATE_PIC_RUN;
 		v4l2_event_queue_fh(&inst->v4l2_fh, &vpu_event_eos);
 
-		v4l2_m2m_job_finish(inst->dev->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
+		v4l2_m2m_job_finish(inst->v4l2_m2m_dev, inst->v4l2_fh.m2m_ctx);
 	} else {
 		vb2_set_plane_payload(&dst_buf->vb2_buf, 0, enc_output_info.bitstream_size);
 
@@ -368,6 +362,8 @@ static void wave5_vpu_enc_finish_encode(struct vpu_instance *inst)
 
 		v4l2_m2m_dst_buf_remove_by_buf(inst->v4l2_fh.m2m_ctx, dst_buf);
 		v4l2_m2m_buf_done(dst_buf, VB2_BUF_STATE_DONE);
+
+		dev_dbg(inst->dev->dev, "frame_cycle %8d\n", enc_output_info.frame_cycle);
 	}
 }
 
@@ -650,8 +646,8 @@ static int wave5_vpu_enc_g_selection(struct file *file, void *fh, struct v4l2_se
 		case V4L2_SEL_TGT_CROP_BOUNDS:
 			s->r.left = 0;
 			s->r.top = 0;
-			s->r.width = inst->src_fmt.width;
-			s->r.height = inst->src_fmt.height;
+			s->r.width = inst->dst_fmt.width;
+			s->r.height = inst->dst_fmt.height;
 			break;
 		case V4L2_SEL_TGT_CROP:
 			s->r.left = 0;
@@ -675,8 +671,6 @@ static int wave5_vpu_enc_s_selection(struct file *file, void *fh, struct v4l2_se
 {
 	struct vpu_instance *inst = wave5_to_vpu_inst(fh);
 
-	dev_dbg(inst->dev->dev, "type : %d | target : %d\n", s->type, s->target);
-
 	if (s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
 		return -EINVAL;
 
@@ -685,18 +679,12 @@ static int wave5_vpu_enc_s_selection(struct file *file, void *fh, struct v4l2_se
 
 	dev_dbg(inst->dev->dev, "V4L2_SEL_TGT_CROP width : %d | height : %d\n",
 		s->r.width, s->r.height);
-	inst->dst_fmt.width = s->r.width;
-	inst->dst_fmt.height = s->r.height;
-
-	return 0;
-}
 
-static int wave5_vpu_enc_try_encoder_cmd(struct file *file, void *fh, struct v4l2_encoder_cmd *ec)
-{
-	if (ec->cmd != V4L2_ENC_CMD_STOP && ec->cmd != V4L2_ENC_CMD_START)
-		return -EINVAL;
+	s->r.left = 0;
+	s->r.top = 0;
+	s->r.width = inst->src_fmt.width;
+	s->r.height = inst->src_fmt.height;
 
-	ec->flags = 0;
 	return 0;
 }
 
@@ -705,8 +693,8 @@ static int wave5_vpu_enc_encoder_cmd(struct file *file, void *fh, struct v4l2_en
 	struct vpu_instance *inst = wave5_to_vpu_inst(fh);
 	int ret;
 
-	ret = wave5_vpu_enc_try_encoder_cmd(file, fh, ec);
-	if (ret < 0)
+	ret = v4l2_m2m_ioctl_try_encoder_cmd(file, fh, ec);
+	if (ret)
 		return ret;
 
 	if (!wave5_vpu_both_queues_are_streaming(inst))
@@ -818,33 +806,13 @@ static const struct v4l2_ioctl_ops wave5_vpu_enc_ioctl_ops = {
 	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
 	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
 
-	.vidioc_try_encoder_cmd = wave5_vpu_enc_try_encoder_cmd,
+	.vidioc_try_encoder_cmd = v4l2_m2m_ioctl_try_encoder_cmd,
 	.vidioc_encoder_cmd = wave5_vpu_enc_encoder_cmd,
 
 	.vidioc_subscribe_event = wave5_vpu_enc_subscribe_event,
 	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
 };
 
-static int wave5_vpu_enc_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
-{
-	struct vpu_instance *inst = wave5_ctrl_to_vpu_inst(ctrl);
-
-	dev_dbg(inst->dev->dev, "name : %s\n", ctrl->name);
-
-	switch (ctrl->id) {
-	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:
-		if (inst->state != VPU_INST_STATE_NONE && inst->state != VPU_INST_STATE_OPEN)
-			ctrl->val = inst->min_src_frame_buf_count;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	dev_dbg(inst->dev->dev, "value : %d\n", ctrl->val);
-
-	return 0;
-}
-
 static int wave5_vpu_enc_s_ctrl(struct v4l2_ctrl *ctrl)
 {
 	struct vpu_instance *inst = wave5_ctrl_to_vpu_inst(ctrl);
@@ -1027,6 +995,8 @@ static int wave5_vpu_enc_s_ctrl(struct v4l2_ctrl *ctrl)
 		inst->max_qp_p = ctrl->val;
 		inst->max_qp_b = ctrl->val;
 		break;
+	case V4L2_CID_MIN_BUFFERS_FOR_OUTPUT:
+		break;
 	default:
 		return -EINVAL;
 	}
@@ -1035,7 +1005,6 @@ static int wave5_vpu_enc_s_ctrl(struct v4l2_ctrl *ctrl)
 }
 
 static const struct v4l2_ctrl_ops wave5_vpu_enc_ctrl_ops = {
-	.g_volatile_ctrl = wave5_vpu_enc_g_volatile_ctrl,
 	.s_ctrl = wave5_vpu_enc_s_ctrl,
 };
 
@@ -1121,6 +1090,7 @@ static int wave5_vpu_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 		u32 fb_height = 0;
 		struct enc_open_param open_param;
 		struct enc_initial_info initial_info;
+		struct v4l2_ctrl *ctrl;
 
 		memset(&open_param, 0, sizeof(struct enc_open_param));
 		wave5_set_default_enc_openparam(&open_param);
@@ -1182,15 +1152,24 @@ static int wave5_vpu_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 		dev_dbg(inst->dev->dev, "min_frame_buffer : %d | min_source_buffer : %d\n",
 			initial_info.min_frame_buffer_count, initial_info.min_src_frame_count);
 		inst->state = VPU_INST_STATE_INIT_SEQ;
-		inst->min_src_frame_buf_count = initial_info.min_src_frame_count +
-						COMMAND_QUEUE_DEPTH;
-		inst->min_dst_frame_buf_count = initial_info.min_frame_buffer_count;
-		*num_buffers = inst->min_src_frame_buf_count;
-		dev_dbg(inst->dev->dev, "source buffer num : %d", *num_buffers);
+		inst->min_src_buf_count = initial_info.min_src_frame_count +
+					  COMMAND_QUEUE_DEPTH;
+
+		ctrl = v4l2_ctrl_find(&inst->v4l2_ctrl_hdl,
+				      V4L2_CID_MIN_BUFFERS_FOR_OUTPUT);
+		if (ctrl)
+			v4l2_ctrl_s_ctrl(ctrl, inst->min_src_buf_count);
+
+		inst->min_dst_buf_count = initial_info.min_frame_buffer_count;
+		inst->src_buf_count = inst->min_src_buf_count;
 
-		non_linear_num = inst->min_dst_frame_buf_count;
+		if (*num_buffers > inst->src_buf_count)
+			inst->src_buf_count = *num_buffers;
 
-		fb_stride = inst->dst_fmt.width;
+		*num_buffers = inst->src_buf_count;
+		non_linear_num = inst->min_dst_buf_count;
+
+		fb_stride = ALIGN(inst->dst_fmt.width, 32);
 		fb_height = ALIGN(inst->dst_fmt.height, 32);
 
 		for (i = 0; i < non_linear_num; i++) {
@@ -1222,7 +1201,7 @@ static int wave5_vpu_enc_queue_setup(struct vb2_queue *q, unsigned int *num_buff
 
 	if (inst->state == VPU_INST_STATE_INIT_SEQ &&
 	    q->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
-		*num_buffers = inst->min_src_frame_buf_count;
+		*num_buffers = inst->src_buf_count;
 		dev_dbg(inst->dev->dev, "source buffer num : %d", *num_buffers);
 	}
 
@@ -1327,13 +1306,11 @@ static int wave5_vpu_enc_queue_init(void *priv, struct vb2_queue *src_vq, struct
 	int ret;
 
 	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
-	src_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
 	src_vq->mem_ops = &vb2_dma_contig_memops;
 	src_vq->ops = &wave5_vpu_enc_vb2_ops;
 	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	src_vq->buf_struct_size = sizeof(struct vpu_buffer);
-	src_vq->allow_zero_bytesused = 1;
-	src_vq->min_buffers_needed = 0;
 	src_vq->drv_priv = inst;
 	src_vq->lock = &inst->dev->dev_lock;
 	src_vq->dev = inst->dev->v4l2_dev.dev;
@@ -1342,13 +1319,11 @@ static int wave5_vpu_enc_queue_init(void *priv, struct vb2_queue *src_vq, struct
 		return ret;
 
 	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
-	dst_vq->io_modes = VB2_MMAP | VB2_USERPTR | VB2_DMABUF;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
 	dst_vq->mem_ops = &vb2_dma_contig_memops;
 	dst_vq->ops = &wave5_vpu_enc_vb2_ops;
 	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
 	dst_vq->buf_struct_size = sizeof(struct vpu_buffer);
-	dst_vq->allow_zero_bytesused = 1;
-	dst_vq->min_buffers_needed = 0;
 	dst_vq->drv_priv = inst;
 	dst_vq->lock = &inst->dev->dev_lock;
 	dst_vq->dev = inst->dev->v4l2_dev.dev;
@@ -1365,13 +1340,42 @@ static const struct vpu_instance_ops wave5_vpu_enc_inst_ops = {
 	.finish_process = wave5_vpu_enc_finish_encode,
 };
 
+static void wave5_vpu_enc_device_run(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	inst->ops->start_process(inst);
+}
+
+static int wave5_vpu_enc_job_ready(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	if (inst->state == VPU_INST_STATE_STOP)
+		return 0;
+
+	return 1;
+}
+
+static void wave5_vpu_enc_job_abort(void *priv)
+{
+	struct vpu_instance *inst = priv;
+
+	inst->ops->stop_process(inst);
+}
+
+static const struct v4l2_m2m_ops wave5_vpu_enc_m2m_ops = {
+	.device_run = wave5_vpu_enc_device_run,
+	.job_ready = wave5_vpu_enc_job_ready,
+	.job_abort = wave5_vpu_enc_job_abort,
+};
+
 static int wave5_vpu_open_enc(struct file *filp)
 {
 	struct video_device *vdev = video_devdata(filp);
 	struct vpu_device *dev = video_drvdata(filp);
 	struct vpu_instance *inst = NULL;
 	struct v4l2_ctrl_handler *v4l2_ctrl_hdl;
-	struct v4l2_ctrl *ctrl;
 	int ret;
 
 	inst = kzalloc(sizeof(*inst), GFP_KERNEL);
@@ -1387,11 +1391,21 @@ static int wave5_vpu_open_enc(struct file *filp)
 	filp->private_data = &inst->v4l2_fh;
 	v4l2_fh_add(&inst->v4l2_fh);
 
+	INIT_LIST_HEAD(&inst->list);
+	list_add_tail(&inst->list, &dev->instances);
+
+	inst->v4l2_m2m_dev = v4l2_m2m_init(&wave5_vpu_enc_m2m_ops);
+	if (IS_ERR(inst->v4l2_m2m_dev)) {
+		ret = PTR_ERR(inst->v4l2_m2m_dev);
+		dev_err(inst->dev->dev, "v4l2_m2m_init fail: %d\n", ret);
+		goto free_inst;
+	}
+
 	inst->v4l2_fh.m2m_ctx =
-		v4l2_m2m_ctx_init(dev->v4l2_m2m_dev, inst, wave5_vpu_enc_queue_init);
+		v4l2_m2m_ctx_init(inst->v4l2_m2m_dev, inst, wave5_vpu_enc_queue_init);
 	if (IS_ERR(inst->v4l2_fh.m2m_ctx)) {
 		ret = PTR_ERR(inst->v4l2_fh.m2m_ctx);
-		goto free_inst;
+		goto err_m2m_release;
 	}
 
 	v4l2_ctrl_handler_init(v4l2_ctrl_hdl, 30);
@@ -1422,14 +1436,12 @@ static int wave5_vpu_open_enc(struct file *filp)
 	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_ROTATE, 0, 270, 90, 0);
 	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops, V4L2_CID_MPEG_VIDEO_VBV_SIZE, 10,
 			  3000, 1, 3000);
-	ctrl = v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
-				 V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 32, 1, 1);
-	if (ctrl)
-		ctrl->flags |= V4L2_CTRL_FLAG_VOLATILE;
+	v4l2_ctrl_new_std(v4l2_ctrl_hdl, &wave5_vpu_enc_ctrl_ops,
+			  V4L2_CID_MIN_BUFFERS_FOR_OUTPUT, 1, 32, 1, 1);
 
 	if (v4l2_ctrl_hdl->error) {
 		ret = -ENODEV;
-		goto free_inst;
+		goto err_m2m_release;
 	}
 
 	inst->v4l2_fh.ctrl_handler = v4l2_ctrl_hdl;
@@ -1443,8 +1455,25 @@ static int wave5_vpu_open_enc(struct file *filp)
 	inst->xfer_func = V4L2_XFER_FUNC_DEFAULT;
 	inst->frame_rate = 30;
 
+	init_completion(&inst->irq_done);
+	if (kfifo_alloc(&inst->irq_status, 16 * sizeof(int), GFP_KERNEL)) {
+		dev_err(inst->dev->dev, "failed to allocate fifo\n");
+		goto err_m2m_release;
+	}
+
+	inst->id = ida_alloc(&inst->dev->inst_ida, GFP_KERNEL);
+	if (inst->id < 0) {
+		dev_warn(inst->dev->dev, "unable to allocate instance ID: %d\n", inst->id);
+		ret = inst->id;
+		goto err_kfifo_free;
+	}
+
 	return 0;
 
+err_kfifo_free:
+	kfifo_free(&inst->irq_status);
+err_m2m_release:
+	v4l2_m2m_release(inst->v4l2_m2m_dev);
 free_inst:
 	kfree(inst);
 	return ret;
@@ -1476,12 +1505,16 @@ static int wave5_vpu_enc_release(struct file *filp)
 			dev_warn(inst->dev->dev, "close fail ret=%d\n", ret);
 	}
 
-	for (i = 0; i < inst->min_dst_frame_buf_count; i++)
+	for (i = 0; i < inst->min_dst_buf_count; i++)
 		wave5_vdi_free_dma_memory(inst->dev, &inst->frame_vbuf[i]);
 
 	v4l2_ctrl_handler_free(&inst->v4l2_ctrl_hdl);
+	v4l2_m2m_release(inst->v4l2_m2m_dev);
 	v4l2_fh_del(&inst->v4l2_fh);
 	v4l2_fh_exit(&inst->v4l2_fh);
+	list_del_init(&inst->list);
+	kfifo_free(&inst->irq_status);
+	ida_free(&inst->dev->inst_ida, inst->id);
 	kfree(inst);
 
 	return 0;
diff --git a/drivers/staging/media/wave5/wave5-vpu.c b/drivers/staging/media/wave5/wave5-vpu.c
index da3d00ef3..15098426a 100644
--- a/drivers/staging/media/wave5/wave5-vpu.c
+++ b/drivers/staging/media/wave5/wave5-vpu.c
@@ -9,7 +9,6 @@
 #include <linux/platform_device.h>
 #include <linux/clk.h>
 #include <linux/of_address.h>
-#include <linux/io.h>
 #include <linux/firmware.h>
 #include <linux/interrupt.h>
 #include "wave5-vpu.h"
@@ -32,28 +31,69 @@ int wave5_vpu_wait_interrupt(struct vpu_instance *inst, unsigned int timeout)
 {
 	int ret;
 
-	ret = wait_for_completion_timeout(&inst->dev->irq_done,
+	ret = wait_for_completion_timeout(&inst->irq_done,
 					  msecs_to_jiffies(timeout));
 	if (!ret)
 		return -ETIMEDOUT;
 
-	reinit_completion(&inst->dev->irq_done);
+	reinit_completion(&inst->irq_done);
 
 	return 0;
 }
 
+static void wave5_vpu_get_interrupt_for_inst(struct vpu_instance *inst, u32 status)
+{
+	struct vpu_device *dev = inst->dev;
+	u32 seq_done;
+	u32 cmd_done;
+	int val;
+
+	seq_done = wave5_vdi_readl(dev, W5_RET_SEQ_DONE_INSTANCE_INFO);
+	cmd_done = wave5_vdi_readl(dev, W5_RET_QUEUE_CMD_DONE_INST);
+
+	if (status & BIT(INT_WAVE5_INIT_SEQ)) {
+		if (seq_done & BIT(inst->id)) {
+			seq_done &= ~BIT(inst->id);
+			wave5_vdi_write_register(dev, W5_RET_SEQ_DONE_INSTANCE_INFO, seq_done);
+			val = BIT(INT_WAVE5_INIT_SEQ);
+			kfifo_in(&inst->irq_status, &val, sizeof(int));
+		}
+	}
+	if (status & BIT(INT_WAVE5_ENC_SET_PARAM)) {
+		if (seq_done & BIT(inst->id)) {
+			seq_done &= ~BIT(inst->id);
+			wave5_vdi_write_register(dev, W5_RET_SEQ_DONE_INSTANCE_INFO, seq_done);
+			val = BIT(INT_WAVE5_ENC_SET_PARAM);
+			kfifo_in(&inst->irq_status, &val, sizeof(int));
+		}
+	}
+	if (status & BIT(INT_WAVE5_DEC_PIC) ||
+	    status & BIT(INT_WAVE5_ENC_PIC)) {
+		if (cmd_done & BIT(inst->id)) {
+			cmd_done &= ~BIT(inst->id);
+			wave5_vdi_write_register(dev, W5_RET_QUEUE_CMD_DONE_INST, cmd_done);
+			val = BIT(INT_WAVE5_DEC_PIC);
+			kfifo_in(&inst->irq_status, &val, sizeof(int));
+		}
+	}
+}
+
 static irqreturn_t wave5_vpu_irq(int irq, void *dev_id)
 {
 	struct vpu_device *dev = dev_id;
-	unsigned int irq_status;
+	struct vpu_instance *inst;
+	u32 irq_status;
 
 	if (wave5_vdi_readl(dev, W5_VPU_VPU_INT_STS)) {
 		irq_status = wave5_vdi_readl(dev, W5_VPU_VINT_REASON);
+
+		list_for_each_entry(inst, &dev->instances, list) {
+			wave5_vpu_get_interrupt_for_inst(inst, irq_status);
+		}
+
 		wave5_vdi_write_register(dev, W5_VPU_VINT_REASON_CLR, irq_status);
 		wave5_vdi_write_register(dev, W5_VPU_VINT_CLEAR, 0x1);
 
-		kfifo_in(&dev->irq_status, &irq_status, sizeof(int));
-
 		return IRQ_WAKE_THREAD;
 	}
 
@@ -64,67 +104,32 @@ static irqreturn_t wave5_vpu_irq_thread(int irq, void *dev_id)
 {
 	struct vpu_device *dev = dev_id;
 	struct vpu_instance *inst;
-	unsigned int irq_status, val;
-	int ret;
-
-	while (kfifo_len(&dev->irq_status)) {
-		inst = v4l2_m2m_get_curr_priv(dev->v4l2_m2m_dev);
-		if (inst) {
-			inst->ops->finish_process(inst);
-		} else {
-			ret = kfifo_out(&dev->irq_status, &irq_status, sizeof(int));
-			if (!ret)
-				break;
-			dev_dbg(dev->dev, "irq_status: 0x%x\n", irq_status);
-			val = wave5_vdi_readl(dev, W5_VPU_VINT_REASON_USR);
-			val &= ~irq_status;
-			wave5_vdi_write_register(dev, W5_VPU_VINT_REASON_USR, val);
-			complete(&dev->irq_done);
+	int irq_status, ret;
+	u32 val;
+
+	list_for_each_entry(inst, &dev->instances, list) {
+		while (kfifo_len(&inst->irq_status)) {
+			struct vpu_instance *curr;
+
+			curr = v4l2_m2m_get_curr_priv(inst->v4l2_m2m_dev);
+			if (curr) {
+				inst->ops->finish_process(inst);
+			} else {
+				ret = kfifo_out(&inst->irq_status, &irq_status, sizeof(int));
+				if (!ret)
+					break;
+
+				val = wave5_vdi_readl(dev, W5_VPU_VINT_REASON_USR);
+				val &= ~irq_status;
+				wave5_vdi_write_register(dev, W5_VPU_VINT_REASON_USR, val);
+				complete(&inst->irq_done);
+			}
 		}
 	}
 
 	return IRQ_HANDLED;
 }
 
-static void wave5_vpu_device_run(void *priv)
-{
-	struct vpu_instance *inst = priv;
-
-	dev_dbg(inst->dev->dev, "inst type=%d state=%d\n",
-		inst->type, inst->state);
-
-	inst->ops->start_process(inst);
-}
-
-static int wave5_vpu_job_ready(void *priv)
-{
-	struct vpu_instance *inst = priv;
-
-	dev_dbg(inst->dev->dev, "inst type=%d state=%d\n",
-		inst->type, inst->state);
-
-	if (inst->state == VPU_INST_STATE_STOP)
-		return 0;
-
-	return 1;
-}
-
-static void wave5_vpu_job_abort(void *priv)
-{
-	struct vpu_instance *inst = priv;
-
-	dev_dbg(inst->dev->dev, "inst type=%d state=%d\n",
-		inst->type, inst->state);
-
-	inst->ops->stop_process(inst);
-}
-
-static const struct v4l2_m2m_ops wave5_vpu_m2m_ops = {
-	.device_run = wave5_vpu_device_run,
-	.job_ready = wave5_vpu_job_ready,
-	.job_abort = wave5_vpu_job_abort,
-};
-
 static int wave5_vpu_load_firmware(struct device *dev, const char *fw_name)
 {
 	const struct firmware *fw;
@@ -192,7 +197,6 @@ static int wave5_vpu_probe(struct platform_device *pdev)
 
 	mutex_init(&dev->dev_lock);
 	mutex_init(&dev->hw_lock);
-	init_completion(&dev->irq_done);
 	dev_set_drvdata(&pdev->dev, dev);
 	dev->dev = &pdev->dev;
 
@@ -236,24 +240,18 @@ static int wave5_vpu_probe(struct platform_device *pdev)
 	}
 	dev->product = wave_vpu_get_product_id(dev);
 
+	INIT_LIST_HEAD(&dev->instances);
 	ret = v4l2_device_register(&pdev->dev, &dev->v4l2_dev);
 	if (ret) {
 		dev_err(&pdev->dev, "v4l2_device_register fail: %d\n", ret);
 		goto err_vdi_release;
 	}
 
-	dev->v4l2_m2m_dev = v4l2_m2m_init(&wave5_vpu_m2m_ops);
-	if (IS_ERR(dev->v4l2_m2m_dev)) {
-		ret = PTR_ERR(dev->v4l2_m2m_dev);
-		dev_err(&pdev->dev, "v4l2_m2m_init fail: %d\n", ret);
-		goto err_v4l2_unregister;
-	}
-
 	if (match_data->flags & WAVE5_IS_DEC) {
 		ret = wave5_vpu_dec_register_device(dev);
 		if (ret) {
 			dev_err(&pdev->dev, "wave5_vpu_dec_register_device fail: %d\n", ret);
-			goto err_m2m_release;
+			goto err_v4l2_unregister;
 		}
 	}
 	if (match_data->flags & WAVE5_IS_ENC) {
@@ -272,22 +270,17 @@ static int wave5_vpu_probe(struct platform_device *pdev)
 	}
 	dev->irq = res->start;
 
-	if (kfifo_alloc(&dev->irq_status, 16 * sizeof(int), GFP_KERNEL)) {
-		dev_err(&pdev->dev, "failed to allocate fifo\n");
-		goto err_enc_unreg;
-	}
-
 	ret = devm_request_threaded_irq(&pdev->dev, dev->irq, wave5_vpu_irq,
 					wave5_vpu_irq_thread, 0, "vpu_irq", dev);
 	if (ret) {
 		dev_err(&pdev->dev, "fail to register interrupt handler: %d\n", ret);
-		goto err_kfifo_free;
+		goto err_enc_unreg;
 	}
 
 	ret = wave5_vpu_load_firmware(&pdev->dev, match_data->fw_name);
 	if (ret) {
 		dev_err(&pdev->dev, "failed to wave5_vpu_load_firmware: %d\n", ret);
-		goto err_kfifo_free;
+		goto err_enc_unreg;
 	}
 
 	dev_dbg(&pdev->dev, "Added wave driver with caps %s %s and product code 0x%x\n",
@@ -296,16 +289,12 @@ static int wave5_vpu_probe(struct platform_device *pdev)
 		dev->product_code);
 	return 0;
 
-err_kfifo_free:
-	kfifo_free(&dev->irq_status);
 err_enc_unreg:
 	if (match_data->flags & WAVE5_IS_ENC)
 		wave5_vpu_enc_unregister_device(dev);
 err_dec_unreg:
 	if (match_data->flags & WAVE5_IS_DEC)
 		wave5_vpu_dec_unregister_device(dev);
-err_m2m_release:
-	v4l2_m2m_release(dev->v4l2_m2m_dev);
 err_v4l2_unregister:
 	v4l2_device_unregister(&dev->v4l2_dev);
 err_vdi_release:
@@ -325,9 +314,7 @@ static int wave5_vpu_remove(struct platform_device *pdev)
 	clk_bulk_disable_unprepare(dev->num_clks, dev->clks);
 	wave5_vpu_enc_unregister_device(dev);
 	wave5_vpu_dec_unregister_device(dev);
-	v4l2_m2m_release(dev->v4l2_m2m_dev);
 	v4l2_device_unregister(&dev->v4l2_dev);
-	kfifo_free(&dev->irq_status);
 	wave5_vdi_release(&pdev->dev);
 	ida_destroy(&dev->inst_ida);
 
diff --git a/drivers/staging/media/wave5/wave5-vpuapi.c b/drivers/staging/media/wave5/wave5-vpuapi.c
index f5bd284f5..fc6eb74e6 100644
--- a/drivers/staging/media/wave5/wave5-vpuapi.c
+++ b/drivers/staging/media/wave5/wave5-vpuapi.c
@@ -76,11 +76,12 @@ int wave5_vpu_get_version_info(struct device *dev, uint32_t *version_info,
 	return ret;
 }
 
-static int wave5_check_dec_open_param(struct vpu_device *dev, struct dec_open_param *param)
+static int wave5_check_dec_open_param(struct vpu_instance *vpu_inst, struct dec_open_param *param)
 {
-	struct vpu_attr *p_attr;
+	struct vpu_attr *p_attr = &vpu_inst->dev->attr;
 
-	p_attr = &dev->attr;
+	if (vpu_inst->id > MAX_NUM_INSTANCE - 1)
+		return -EOPNOTSUPP;
 
 	if (param->bitstream_buffer % 8)
 		return -EINVAL;
@@ -107,7 +108,7 @@ int wave5_vpu_dec_open(struct vpu_instance *vpu_inst, struct dec_open_param *pop
 	int ret;
 	struct vpu_device *vpu_dev = vpu_inst->dev;
 
-	ret = wave5_check_dec_open_param(vpu_dev, pop);
+	ret = wave5_check_dec_open_param(vpu_inst, pop);
 	if (ret)
 		return ret;
 
@@ -115,19 +116,17 @@ int wave5_vpu_dec_open(struct vpu_instance *vpu_inst, struct dec_open_param *pop
 	if (ret)
 		return ret;
 
-	if (!wave5_vpu_is_init(vpu_dev))
+	if (!wave5_vpu_is_init(vpu_dev)) {
+		mutex_unlock(&vpu_dev->hw_lock);
 		return -ENODEV;
+	}
 
 	vpu_inst->codec_info = kzalloc(sizeof(*vpu_inst->codec_info), GFP_KERNEL);
-	if (!vpu_inst->codec_info)
+	if (!vpu_inst->codec_info) {
+		mutex_unlock(&vpu_dev->hw_lock);
 		return -ENOMEM;
-
-	vpu_inst->id = ida_alloc_max(&vpu_inst->dev->inst_ida, MAX_NUM_INSTANCE - 1, GFP_KERNEL);
-	if (vpu_inst->id < 0) {
-		dev_warn(vpu_inst->dev->dev, "unable to allocate instance ID: %d\n", vpu_inst->id);
-		ret = vpu_inst->id;
-		goto free_codec_info;
 	}
+
 	p_dec_info = &vpu_inst->codec_info->dec_info;
 	memcpy(&p_dec_info->open_param, pop, sizeof(struct dec_open_param));
 
@@ -144,14 +143,12 @@ int wave5_vpu_dec_open(struct vpu_instance *vpu_inst, struct dec_open_param *pop
 
 	ret = wave5_vpu_build_up_dec_param(vpu_inst, pop);
 	if (ret)
-		goto free_ida;
+		goto free_codec_info;
 
 	mutex_unlock(&vpu_dev->hw_lock);
 
 	return 0;
 
-free_ida:
-	ida_free(&vpu_inst->dev->inst_ida, vpu_inst->id);
 free_codec_info:
 	kfree(vpu_inst->codec_info);
 	mutex_unlock(&vpu_dev->hw_lock);
@@ -176,7 +173,7 @@ int wave5_vpu_dec_close(struct vpu_instance *inst, u32 *fail_res)
 
 	ret = wave5_vpu_dec_fini_seq(inst, fail_res);
 	if (ret) {
-		dev_warn(inst->dev->dev, "dec sec end timed out\n");
+		dev_warn(inst->dev->dev, "dec seq end timed out\n");
 
 		if (*fail_res == WAVE5_SYSERR_VPU_STILL_RUNNING) {
 			mutex_unlock(&vpu_dev->hw_lock);
@@ -201,8 +198,6 @@ int wave5_vpu_dec_close(struct vpu_instance *inst, u32 *fail_res)
 	if (p_dec_info->vb_task.size)
 		wave5_vdi_free_dma_memory(vpu_dev, &p_dec_info->vb_task);
 
-	ida_free(&inst->dev->inst_ida, inst->id);
-
 	mutex_unlock(&vpu_dev->hw_lock);
 
 	kfree(inst->codec_info);
@@ -407,6 +402,27 @@ int wave5_vpu_dec_start_one_frame(struct vpu_instance *inst, struct dec_param *p
 	return ret;
 }
 
+int wave5_vpu_dec_set_rd_ptr(struct vpu_instance *inst, dma_addr_t addr, int update_wr_ptr)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	int ret;
+	struct vpu_device *vpu_dev = inst->dev;
+
+	ret = mutex_lock_interruptible(&vpu_dev->hw_lock);
+	if (ret)
+		return ret;
+
+	ret = wave5_dec_set_rd_ptr(inst, addr);
+
+	p_dec_info->stream_rd_ptr = addr;
+	if (update_wr_ptr)
+		p_dec_info->stream_wr_ptr = addr;
+
+	mutex_unlock(&vpu_dev->hw_lock);
+
+	return ret;
+}
+
 int wave5_vpu_dec_get_output_info(struct vpu_instance *inst, struct dec_output_info *info)
 {
 	struct dec_info *p_dec_info;
@@ -644,8 +660,11 @@ int wave5_vpu_dec_get_output_info(struct vpu_instance *inst, struct dec_output_i
 	}
 
 	if (info->sequence_changed &&
-	    ((info->sequence_changed & SEQ_CHANGE_INTER_RES_CHANGE) != SEQ_CHANGE_INTER_RES_CHANGE))
+	    !(info->sequence_changed & SEQ_CHANGE_INTER_RES_CHANGE)) {
+		memcpy((void *)&p_dec_info->initial_info, (void *)&p_dec_info->new_seq_info,
+		       sizeof(struct dec_initial_info));
 		p_dec_info->initial_info.sequence_no++;
+	}
 
 err_out:
 	mutex_unlock(&vpu_dev->hw_lock);
@@ -671,20 +690,59 @@ int wave5_vpu_dec_clr_disp_flag(struct vpu_instance *inst, int index)
 	return ret;
 }
 
+int wave5_vpu_dec_set_disp_flag(struct vpu_instance *inst, int index)
+{
+	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
+	int ret = 0;
+	struct vpu_device *vpu_dev = inst->dev;
+
+	if (index >= p_dec_info->num_fbs_for_wtl)
+		return -EINVAL;
+
+	ret = mutex_lock_interruptible(&vpu_dev->hw_lock);
+	if (ret)
+		return ret;
+	ret = wave5_dec_set_disp_flag(inst, index);
+	mutex_unlock(&vpu_dev->hw_lock);
+
+	return ret;
+}
+
 int wave5_vpu_dec_give_command(struct vpu_instance *inst, enum codec_command cmd, void *param)
 {
 	struct dec_info *p_dec_info = &inst->codec_info->dec_info;
-	struct queue_status_info *queue_info = param;
 
 	switch (cmd) {
-	case DEC_GET_QUEUE_STATUS:
+	case DEC_GET_QUEUE_STATUS: {
+		struct queue_status_info *queue_info = param;
+
 		queue_info->instance_queue_count = p_dec_info->instance_queue_count;
 		queue_info->report_queue_count = p_dec_info->report_queue_count;
 		break;
-
+	}
 	case ENABLE_DEC_THUMBNAIL_MODE:
 		p_dec_info->thumbnail_mode = 1;
 		break;
+	case DEC_RESET_FRAMEBUF_INFO: {
+		int i;
+
+		for (i = 0; i < inst->dst_buf_count; i++) {
+			wave5_vdi_free_dma_memory(inst->dev, &inst->frame_vbuf[i]);
+			wave5_vdi_free_dma_memory(inst->dev, &p_dec_info->vb_mv[i]);
+			wave5_vdi_free_dma_memory(inst->dev, &p_dec_info->vb_fbc_y_tbl[i]);
+			wave5_vdi_free_dma_memory(inst->dev, &p_dec_info->vb_fbc_c_tbl[i]);
+		}
+
+		wave5_vdi_free_dma_memory(inst->dev, &p_dec_info->vb_task);
+		break;
+	}
+	case DEC_GET_SEQ_INFO: {
+		struct dec_initial_info *seq_info = param;
+
+		*seq_info = p_dec_info->initial_info;
+		break;
+	}
+
 	default:
 		return -EINVAL;
 	}
@@ -706,31 +764,27 @@ int wave5_vpu_enc_open(struct vpu_instance *vpu_inst, struct enc_open_param *pop
 	if (ret)
 		return ret;
 
-	if (!wave5_vpu_is_init(vpu_dev))
+	if (!wave5_vpu_is_init(vpu_dev)) {
+		mutex_unlock(&vpu_dev->hw_lock);
 		return -ENODEV;
+	}
 
 	vpu_inst->codec_info = kzalloc(sizeof(*vpu_inst->codec_info), GFP_KERNEL);
-	if (!vpu_inst->codec_info)
+	if (!vpu_inst->codec_info) {
+		mutex_unlock(&vpu_dev->hw_lock);
 		return -ENOMEM;
-
-	vpu_inst->id = ida_alloc_max(&vpu_inst->dev->inst_ida, MAX_NUM_INSTANCE - 1, GFP_KERNEL);
-	if (vpu_inst->id < 0) {
-		dev_warn(vpu_inst->dev->dev, "unable to allocate instance ID: %d\n", vpu_inst->id);
-		ret = vpu_inst->id;
-		goto free_codec_info;
 	}
+
 	p_enc_info = &vpu_inst->codec_info->enc_info;
 	p_enc_info->open_param = *pop;
 
 	ret = wave5_vpu_build_up_enc_param(vpu_dev->dev, vpu_inst, pop);
 	if (ret)
-		goto free_ida;
+		goto free_codec_info;
 	mutex_unlock(&vpu_dev->hw_lock);
 
 	return 0;
 
-free_ida:
-	ida_free(&vpu_inst->dev->inst_ida, vpu_inst->id);
 free_codec_info:
 	kfree(vpu_inst->codec_info);
 	mutex_unlock(&vpu_dev->hw_lock);
@@ -785,8 +839,6 @@ int wave5_vpu_enc_close(struct vpu_instance *inst, u32 *fail_res)
 	if (p_enc_info->vb_task.size)
 		wave5_vdi_free_dma_memory(vpu_dev, &p_enc_info->vb_task);
 
-	ida_free(&inst->dev->inst_ida, inst->id);
-
 	mutex_unlock(&vpu_dev->hw_lock);
 
 	kfree(inst->codec_info);
diff --git a/drivers/staging/media/wave5/wave5-vpuapi.h b/drivers/staging/media/wave5/wave5-vpuapi.h
index 5e6dd090d..05f772c96 100644
--- a/drivers/staging/media/wave5/wave5-vpuapi.h
+++ b/drivers/staging/media/wave5/wave5-vpuapi.h
@@ -36,8 +36,7 @@ enum vpu_instance_state {
 	VPU_INST_STATE_OPEN = 1,
 	VPU_INST_STATE_INIT_SEQ = 2,
 	VPU_INST_STATE_PIC_RUN = 3,
-	VPU_INST_STATE_STOP = 4,
-	VPU_INST_STATE_WAIT_BUF = 5
+	VPU_INST_STATE_STOP = 4
 };
 
 #define WAVE5_MAX_FBS 32
@@ -195,6 +194,8 @@ enum codec_command {
 	ENABLE_DEC_THUMBNAIL_MODE,
 	DEC_GET_QUEUE_STATUS,
 	ENC_GET_QUEUE_STATUS,
+	DEC_RESET_FRAMEBUF_INFO,
+	DEC_GET_SEQ_INFO,
 };
 
 enum error_conceal_mode {
@@ -957,7 +958,6 @@ struct dec_info {
 	int rotator_stride;
 	bool initial_info_obtained;
 	struct sec_axi_info sec_axi_info;
-	int seq_init_escape;
 	dma_addr_t user_data_buf_addr;
 	u32 user_data_enable;
 	int user_data_buf_size;
@@ -1020,14 +1020,12 @@ struct enc_info {
 struct vpu_device {
 	struct device *dev;
 	struct v4l2_device v4l2_dev;
-	struct v4l2_m2m_dev *v4l2_m2m_dev;
+	struct list_head instances;
 	struct video_device *video_dev_dec;
 	struct video_device *video_dev_enc;
 	struct mutex dev_lock; /* the lock for the src,dst v4l2 queues */
-	struct mutex	 hw_lock; /* lock hw configurations */
-	struct kfifo irq_status;
+	struct mutex hw_lock; /* lock hw configurations */
 	int irq;
-	struct completion irq_done;
 	enum product_id	 product;
 	struct vpu_attr	 attr;
 	struct vpu_buf common_mem;
@@ -1049,9 +1047,13 @@ struct vpu_instance_ops {
 };
 
 struct vpu_instance {
+	struct list_head list;
 	struct v4l2_fh v4l2_fh;
 	struct v4l2_ctrl_handler v4l2_ctrl_hdl;
 	struct vpu_device *dev;
+	struct v4l2_m2m_dev *v4l2_m2m_dev;
+	struct kfifo irq_status;
+	struct completion irq_done;
 
 	struct v4l2_pix_format_mplane src_fmt;
 	struct v4l2_pix_format_mplane dst_fmt;
@@ -1073,18 +1075,20 @@ struct vpu_instance {
 	} *codec_info;
 	struct frame_buffer frame_buf[MAX_REG_FRAME];
 	struct vpu_buf frame_vbuf[MAX_REG_FRAME];
-	u32 min_dst_frame_buf_count;
+	u32 min_dst_buf_count;
+	u32 dst_buf_count;
 	u32 queued_src_buf_num;
 	u32 queued_dst_buf_num;
 	u64 timestamp;
 	bool cbcr_interleave;
 	bool nv21;
+	bool eos;
 
-	spinlock_t bitstream_lock; /* lock the src buf queue of the m2m ctx */
 	struct vpu_buf bitstream_vbuf;
 	bool thumbnail_mode;
 
-	unsigned int min_src_frame_buf_count;
+	unsigned int min_src_buf_count;
+	unsigned int src_buf_count;
 	unsigned int rot_angle;
 	unsigned int mirror_direction;
 	unsigned int profile;
@@ -1123,11 +1127,13 @@ int wave5_vpu_dec_register_frame_buffer_ex(struct vpu_instance *inst, int num_of
 int wave5_vpu_dec_start_one_frame(struct vpu_instance *inst, struct dec_param *param,
 				  u32 *res_fail);
 int wave5_vpu_dec_get_output_info(struct vpu_instance *inst, struct dec_output_info *info);
+int wave5_vpu_dec_set_rd_ptr(struct vpu_instance *inst, dma_addr_t addr, int update_wr_ptr);
 int wave5_vpu_dec_give_command(struct vpu_instance *inst, enum codec_command cmd, void *parameter);
 int wave5_vpu_dec_get_bitstream_buffer(struct vpu_instance *inst, dma_addr_t *prd_prt,
 				       dma_addr_t *pwr_ptr, uint32_t *size);
 int wave5_vpu_dec_update_bitstream_buffer(struct vpu_instance *inst, int size);
 int wave5_vpu_dec_clr_disp_flag(struct vpu_instance *inst, int index);
+int wave5_vpu_dec_set_disp_flag(struct vpu_instance *inst, int index);
 
 int wave5_vpu_enc_open(struct vpu_instance *vpu_inst, struct enc_open_param *enc_op_param);
 int wave5_vpu_enc_close(struct vpu_instance *inst, u32 *fail_res);
diff --git a/drivers/staging/media/wave5/wave5-vpuerror.h b/drivers/staging/media/wave5/wave5-vpuerror.h
index 0ece5bc51..bef04df1f 100644
--- a/drivers/staging/media/wave5/wave5-vpuerror.h
+++ b/drivers/staging/media/wave5/wave5-vpuerror.h
@@ -393,7 +393,7 @@
 #define AVC_PRESWARN_MISSING_SLICE                                     0x01200000
 
 // AV1
-#define AV1_SPSWARN_OBU_EXTENTION_FLAG_ZERO                            0x00001000
+#define AV1_SPSWARN_OBU_EXTENSION_FLAG_ZERO                            0x00001000
 #define AV1_SPSWARN_DUPLICATE_OPERATING_POINT_IDX                      0x00001001
 #define AV1_SPSWARN_MC_IDENTIY_SUBSAMPLING_X                           0x00001002
 #define AV1_PPSWARN_MC_IDENTIY_SUBSAMPLING_Y                           0x00001003
@@ -411,12 +411,12 @@
 #define AV1_PPSWARN_EXPECTED_FRAME_ID                                  0x00002100
 #define AV1_SPECWARN_OVER_MAX_TILE_AREA_SB                             0x00005000
 #define AV1_SPECWARN_OVER_MAX_PIC_SIZE                                 0x00005001
-#define AV1_ETCWARN_OBU_EXTENTION_FLAG                                 0x00006000
+#define AV1_ETCWARN_OBU_EXTENSION_FLAG                                 0x00006000
 #define AV1_TGWARN_TRAIL_BIT_POS                                       0x00400000
 #define AV1_TGWARN_TRAIL_PAD_BIT                                       0x00800000
 #define AV1_TGWARN_SYM_MAX_OVER                                        0x01000000
 #define AV1_TGWARN_EXP_GOLB_OVER                                       0x02000000
-#define AV1_TGWARN_MV_NOT_VAILD                                        0x04000000
+#define AV1_TGWARN_MV_NOT_VALID                                        0x04000000
 
 // VP9
 #define VP9_PICWARN_COLOR_SPACE_MISMATCH_WITH_REF                      0x00001000
diff --git a/drivers/staging/media/wave5/wave5.h b/drivers/staging/media/wave5/wave5.h
index 7c17b746c..52d3ac6de 100644
--- a/drivers/staging/media/wave5/wave5.h
+++ b/drivers/staging/media/wave5/wave5.h
@@ -53,10 +53,14 @@ int wave5_vpu_dec_fini_seq(struct vpu_instance *vpu_inst, u32 *fail_res);
 
 int wave5_dec_clr_disp_flag(struct vpu_instance *inst, uint32_t index);
 
+int wave5_dec_set_disp_flag(struct vpu_instance *inst, uint32_t index);
+
 int wave5_vpu_clear_interrupt(struct vpu_instance *inst, uint32_t flags);
 
 dma_addr_t wave5_vpu_dec_get_rd_ptr(struct vpu_instance *vpu_inst);
 
+int wave5_dec_set_rd_ptr(struct vpu_instance *vpu_inst, dma_addr_t addr);
+
 /***< WAVE5 encoder >******/
 
 int wave5_vpu_build_up_enc_param(struct device *dev, struct vpu_instance *inst,
-- 
2.17.1

