From dafc2f140a069cebbb931cb529f1970dba716572 Mon Sep 17 00:00:00 2001
From: "x1082265@ti.com" <dharma.b@mistralsolutions.com>
Date: Tue, 2 Nov 2021 13:20:54 +0530
Subject: [PATCH] cpts: latch: split init and adjust

Do init from timer irq
do adjust from cpts irq when both HW_TS and TMP CAP are ready.
---
 drivers/net/ethernet/ti/cpts.c | 84 +++++++++++++++++++++-------------
 drivers/net/ethernet/ti/cpts.h |  2 -
 2 files changed, 51 insertions(+), 35 deletions(-)

diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
index bfba9d1f6047..536b5eb3b3f6 100644
--- a/drivers/net/ethernet/ti/cpts.c
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -113,6 +113,7 @@ static void cpts_tmr_poll(struct cpts *cpts, bool cpts_poll);
 static void cpts_pps_schedule(struct cpts *cpts);
 static inline void cpts_latch_pps_stop(struct cpts *cpts);
 static void cpts_bc_mux_ctrl(void *ctx, int enable);
+static u32 cpts_latch_proc(struct cpts *cpts);
 #endif
 
 
@@ -256,14 +257,8 @@ static int cpts_fifo_read(struct cpts *cpts, int match)
                                list_del_init(&event->list);
                                list_add_tail(&event->list, &cpts->events_pps);
                        } else if (cpts->hw_ts_enable & BIT(pevent.index)) {
-                               pevent.timestamp -= cpts->pps_latch_offset;
-                               if (cpts->pps_latch_receive) {
-                                       ptp_clock_event(cpts->clock, &pevent);
-                                       cpts->pps_latch_receive = false;
-                               } else {
-                                       cpts_latch_pps_stop(cpts);
-                                       dev_info(cpts->dev, "fifo: enter pps_latch INIT state\n");
-                               }
+                               pevent.timestamp -= cpts_latch_proc(cpts);
+                               ptp_clock_event(cpts->clock, &pevent);
                        }
 #else
 			ptp_clock_event(cpts->clock, &pevent);
@@ -1598,7 +1593,6 @@ static void cpts_latch_tmr_init(struct cpts *cpts)
        WRITE_TSICR(cpts->odt2, BIT(2));
 
        cpts->pps_latch_state = INIT;
-       cpts->pps_latch_offset = 0;
 }
 
 static inline void cpts_turn_on_off_1pps_output(struct cpts *cpts, u64 ts)
@@ -1908,8 +1902,6 @@ static inline void cpts_latch_pps_stop(struct cpts *cpts)
        WRITE_TCLR(cpts->odt2, v);
 
        cpts->pps_latch_state = INIT;
-       cpts->pps_latch_offset = 0;
-       cpts->pps_latch_receive = 0;
 }
 
 static inline void cpts_latch_pps_start(struct cpts *cpts)
@@ -1922,25 +1914,22 @@ static inline void cpts_latch_pps_start(struct cpts *cpts)
        WRITE_TCLR(cpts->odt2, v);
 }
 
-static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
+static void cpts_latch_proc_init(struct cpts *cpts)
 {
-       u32 offset = 0xFFFFFFFFUL - latch_cnt + 1;
        u32 reload_cnt = CPTS_LATCH_TMR_RELOAD_CNT;
+	u32 offset, latch_cnt;
 	unsigned long flags;
        static bool skip;
        static int init_cnt;
 
-       if (!cpts)
-               return;
 	spin_lock_irqsave(&cpts->lock, flags);
-       cpts->pps_latch_offset = offset * CPTS_TMR_CLK_PERIOD +
-                                CPTS_TMR_LATCH_DELAY;
-       cpts->pps_latch_receive = true;
-	spin_unlock_irqrestore(&cpts->lock, flags);
 
        /* Timer poll state machine */
        switch (cpts->pps_latch_state) {
        case INIT:
+               latch_cnt = READ_TCAP(cpts->odt2);
+               offset = 0xFFFFFFFFUL - latch_cnt + 1;
+
                if (!skip) {
                        if (offset < CPTS_LATCH_TICK_THRESH_MIN) {
                                reload_cnt -= (CPTS_LATCH_TICK_THRESH_MID -
@@ -1955,9 +1944,11 @@ static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
                                cpts_latch_pps_start(cpts);
                                cpts->pps_latch_state = SYNC;
                                init_cnt = 0;
-                               dev_info(cpts->dev, "%s: enter SYNC state\n",
-                                        __func__);
-                               break;
+                               skip = false;
+                               dev_dbg(cpts->dev, "%s: enter SYNC state offset:%u latch_cnt:%u reload_cnt:%u\n",
+                                       __func__, offset * 10,
+                                       latch_cnt, reload_cnt);
+				break;
                        }
                        init_cnt++;
                        skip = true;
@@ -1975,6 +1966,9 @@ static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
                                cpts_latch_pps_start(cpts);
                                cpts->pps_latch_state = SYNC;
                                init_cnt = 0;
+                               skip = false;
+                               dev_info(cpts->dev, "%s: enter SYNC state\n",
+                                        __func__);
                        }
                }
 
@@ -1988,18 +1982,41 @@ static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
                         */
                        cpts->pps_latch_state = NONADJUST;
                        cpts_latch_pps_start(cpts);
-                       init_cnt = 0;
+                       skip = false;
+			init_cnt = 0;
                        dev_info(cpts->dev, "%s: enter NONADJUST state\n",
                                 __func__);
                }
 
-               if (cpts->pps_latch_state == SYNC)
-                       dev_info(cpts->dev, "%s: enter SYNC state\n", __func__);
-               else
-                       dev_dbg(cpts->dev, "%s: offset = %u, latch_cnt = %u, reload_cnt =%u\n",
-                               __func__, offset * 10, latch_cnt, reload_cnt);
+               dev_dbg(cpts->dev, "%s: init offset:%u latch_cnt:%u reload_cnt:%u\n",
+                       __func__, offset * 10, latch_cnt, reload_cnt);
+
+               break;
+
+       default:
+               /* Error handling */
                break;
+       } /* switch */
+
+       spin_unlock_irqrestore(&cpts->lock, flags);
+}
+
+static u32 cpts_latch_proc(struct cpts *cpts)
+{
+       u32 reload_cnt = CPTS_LATCH_TMR_RELOAD_CNT;
+       u32 offset, latch_cnt;
+       u32 pps_latch_offset;
+
+       latch_cnt = READ_TCAP(cpts->odt2);
+       offset = 0xFFFFFFFFUL - latch_cnt + 1;
 
+       pps_latch_offset = offset * CPTS_TMR_CLK_PERIOD +  CPTS_TMR_LATCH_DELAY;
+
+       /* Timer poll state machine */
+       switch (cpts->pps_latch_state) {
+       case INIT:
+               dev_err(cpts->dev, "%s: invalid INIT state pps_latch_offset:%u latch_cnt:%u reload_cnt:%u\n",
+                       __func__, pps_latch_offset, latch_cnt, reload_cnt);
        case ADJUST:
                /* Restore the LDR value */
                WRITE_TLDR(cpts->odt2, reload_cnt);
@@ -2013,8 +2030,6 @@ static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
                                 * enter INIT (Out of Sync) state
                                 */
                                cpts_latch_pps_stop(cpts);
-                               cpts->pps_latch_state = INIT;
-                               skip = false;
                                dev_info(cpts->dev, "%s: re-enter INIT state due to large_offset %d\n",
                                         __func__, offset);
                                break;
@@ -2044,8 +2059,11 @@ static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
                break;
 
        } /* switch */
-       dev_dbg(cpts->dev, "%s(%d): offset = %u(0x%x)\n",
-               __func__, cpts->pps_latch_state, offset, offset);
+
+       dev_dbg(cpts->dev, "%s: pps_latch_offset:%u latch_cnt:%u reload_cnt:%u\n",
+               __func__, pps_latch_offset, latch_cnt, reload_cnt);
+
+       return pps_latch_offset;
 }
 
 static int int_cnt;
@@ -2072,7 +2072,7 @@ static irqreturn_t cpts_1pps_latch_interrupt(int irq, void *dev_id)
 
        writel_relaxed(OMAP_TIMER_INT_CAPTURE, cpts->odt2->irq_stat);
 
-       cpts_latch_proc(cpts, READ_TCAP(cpts->odt2));
+       cpts_latch_proc_init(cpts);
 
        if (latch_cnt <= 100)
                latch_cnt++;
diff --git a/drivers/net/ethernet/ti/cpts.h b/drivers/net/ethernet/ti/cpts.h
index a71ab65d054e..6379afa7e3a1 100644
--- a/drivers/net/ethernet/ti/cpts.h
+++ b/drivers/net/ethernet/ti/cpts.h
@@ -139,7 +139,6 @@ struct cpts {
        u8 use_1pps_gen;
        u8 use_1pps_latch;
        u8 use_1pps_ref;
-       u8 pps_latch_receive;
        int pps_hw_index;
        int pps_enable;
        int pps_state;
@@ -152,7 +151,6 @@ struct cpts {
        const struct omap_dm_timer_ops *odt2_ops;
        s32 ppb_new;
        u64 hw_timestamp;
-       u32 pps_latch_offset;
        int pps_offset;
        spinlock_t bc_mux_lock; /* protect mux control gpio (pps_enable_gpio) */
 
-- 
2.17.1

