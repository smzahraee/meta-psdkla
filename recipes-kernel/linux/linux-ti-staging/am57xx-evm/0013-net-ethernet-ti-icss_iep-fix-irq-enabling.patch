From a90d0bdab58631084b3daa80a2ae5cc1aad8ee7e Mon Sep 17 00:00:00 2001
From: "x1082265@ti.com" <dharma.b@mistralsolutions.com>
Date: Tue, 2 Nov 2021 13:53:42 +0530
Subject: [PATCH] net: ethernet: ti: icss_iep: fix irq enabling

IEP irq requested before FW is loaded when mapping is not available yet.
Ensure the IRQ is requested and IEP initialized after PRU FW is loaded, so
it will be properly enabled on INTC level.
---
 drivers/net/ethernet/ti/icss_iep.c    | 13 ++++++++++--
 drivers/net/ethernet/ti/prueth_core.c | 30 +++++++++++++--------------
 2 files changed, 26 insertions(+), 17 deletions(-)

diff --git a/drivers/net/ethernet/ti/icss_iep.c b/drivers/net/ethernet/ti/icss_iep.c
index fd4edf748fb9..bae8f7c64665 100644
--- a/drivers/net/ethernet/ti/icss_iep.c
+++ b/drivers/net/ethernet/ti/icss_iep.c
@@ -959,8 +959,6 @@ void icss_iep_put(struct icss_iep *iep)
 	iep->client_np = NULL;
 	device_unlock(iep->dev);
 	put_device(iep->dev);
-	if (iep->cap_cmp_irq)
-		cancel_delayed_work(&iep->sync_work);
        if (iep->pins)
                devm_pinctrl_put(iep->pins);
 }
@@ -1058,6 +1056,12 @@ int icss_iep_init(struct icss_iep *iep, const struct icss_iep_clockops *clkops,
        dev_info(iep->dev, "iep ptp bc clkid %d\n", iep->bc_clkid);
        ptp_bc_mux_ctrl_register(NULL, NULL, NULL);
 
+       if (iep->cap_cmp_irq) {
+               ret = request_irq(iep->cap_cmp_irq, icss_iep_cap_cmp_handler, IRQF_TRIGGER_HIGH,
+                                 "iep_cap_cmp", iep);
+               if (ret)
+                       dev_err(iep->dev, "Request irq failed for cap_cmp %d\n", ret);
+       }
 
 	return ret;
 }
@@ -1065,6 +1069,11 @@ EXPORT_SYMBOL_GPL(icss_iep_init);
 
 int icss_iep_exit(struct icss_iep *iep)
 {
+       if (iep->cap_cmp_irq) {
+               free_irq(iep->cap_cmp_irq, iep);
+               cancel_delayed_work(&iep->sync_work);
+       }
+
 	if (iep->ptp_clock) {
 		ptp_clock_unregister(iep->ptp_clock);
 		iep->ptp_clock = NULL;
diff --git a/drivers/net/ethernet/ti/prueth_core.c b/drivers/net/ethernet/ti/prueth_core.c
index 042dc578eed0..87b5ab479583 100644
--- a/drivers/net/ethernet/ti/prueth_core.c
+++ b/drivers/net/ethernet/ti/prueth_core.c
@@ -1622,25 +1622,26 @@ static int emac_ndo_open(struct net_device *ndev)
 	if (PRUETH_IS_LRE(prueth))
 		prueth_lre_set_stats(prueth, prueth->lre_stats);
 
-	if (!prueth->emac_configured) {
-		icss_ptp_dram_init(emac);
-		ret = icss_iep_init(prueth->iep, NULL, NULL, 0);
-		if (ret) {
-			netdev_err(ndev, "Failed to initialize iep: %d\n", ret);
-			goto free_mem;
-		}
-	}
 
 	if (!PRUETH_IS_EMAC(prueth)) {
 		ret = prueth_sw_boot_prus(prueth, ndev);
 		if (ret)
-			goto iep_exit;
+			goto free_mem;
 	} else {
 		/* boot the PRU */
 		ret = emac_set_boot_pru(emac, ndev);
 		if (ret) {
 			netdev_err(ndev, "failed to boot PRU: %d\n", ret);
-			goto iep_exit;
+			goto free_mem;
+		}
+       }
+
+       if (!prueth->emac_configured) {
+               icss_ptp_dram_init(emac);
+               ret = icss_iep_init(prueth->iep, NULL, NULL, 0);
+               if (ret) {
+                       netdev_err(ndev, "Failed to initialize iep: %d\n", ret);
+                       goto rproc_shutdown;
 		}
 	}
 
@@ -1649,7 +1650,7 @@ static int emac_ndo_open(struct net_device *ndev)
 	else
 		ret = prueth_lre_request_irqs(emac);
 	if (ret)
-		goto rproc_shutdown;
+		goto iep_exit;
 
 	/* start PHY */
 	phy_start(emac->phydev);
@@ -1665,15 +1666,14 @@ static int emac_ndo_open(struct net_device *ndev)
 		dev_notice(&ndev->dev, "started\n");
 
 	return 0;
-
+iep_exit:
+       if (!prueth->emac_configured)
+               icss_iep_exit(prueth->iep);
 rproc_shutdown:
 	if (!PRUETH_IS_EMAC(prueth))
 		prueth_sw_shutdown_prus(emac, ndev);
 	else
 		rproc_shutdown(emac->pru);
-iep_exit:
-	if (!prueth->emac_configured)
-		icss_iep_exit(prueth->iep);
 free_mem:
 	if (PRUETH_IS_SWITCH(prueth))
 		prueth_sw_free_fdb_table(prueth);
-- 
2.17.1

