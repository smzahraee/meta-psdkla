From 664a018e34c469a87da6843034ea98668f00847b Mon Sep 17 00:00:00 2001
From: Dharma B <dharma.b@ti.com>
Date: Tue, 30 Nov 2021 20:40:24 +0530
Subject: [PATCH 17/17] HACK: v2: net: packet: Avoid fragmented SKB

The target RAW Ethernet packets are small (fits the page), but af-packet code
uses fragmented skbs any way tpacket_snd(). This lead to unnecessary fragmented
skb usage and end up calling __skb_linearize() from validate_xmit_skb().

This patch is attempt to allocate and use skb linear skb head space and so,
avoid fragmented skbs.

This reduces the sendto() systemcall duration about 5-6us for six parallel
redundant streams.

Changes in v2:
- do not mark SKB as SKBTX_ZEROCOPY_FRAG if it's linear. This fixes HSR
crashes due to incorrect arguments passed in skb_release_data()->
skb_zcopy_clear()
- account missed hlen during skb alloc
- add alloclen to be clear about functionality

Signed-off-by: Dharma B <dharma.b@ti.com>
---
 net/packet/af_packet.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c
index 3c0c09f70b3f..1fc31b597428 100644
--- a/net/packet/af_packet.c
+++ b/net/packet/af_packet.c
@@ -2523,7 +2523,6 @@ static int tpacket_fill_skb(struct packet_sock *po, struct sk_buff *skb,
	skb->mark = po->sk.sk_mark;
	skb->tstamp = sockc->transmit_time;
	skb_setup_tx_timestamp(skb, sockc->tsflags);
-	skb_zcopy_set_nouarg(skb, ph.raw);

	skb_reserve(skb, hlen);
	skb_reset_network_header(skb);
@@ -2579,6 +2578,11 @@ static int tpacket_fill_skb(struct packet_sock *po, struct sk_buff *skb,
		len = ((to_write > len_max) ? len_max : to_write);
	}

+	if (skb_shinfo(skb)->nr_frags)
+		skb_zcopy_set_nouarg(skb, ph.raw);
+	else
+		skb_shinfo(skb)->destructor_arg = ph.raw;
+
	packet_parse_headers(skb, sock);

	return tp_len;
@@ -2668,7 +2672,7 @@ static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)
	void *data;
	int len_sum = 0;
	int status = TP_STATUS_AVAILABLE;
-	int hlen, tlen, copylen = 0;
+	int hlen, tlen, copylen = 0, alloclen;
	long timeo = 0;

	mutex_lock(&po->pg_vec_lock);
@@ -2762,9 +2766,16 @@ static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)
						    vnet_hdr->hdr_len);
		}
		copylen = max_t(int, copylen, dev->hard_header_len);
+		alloclen = hlen + tlen + sizeof(struct sockaddr_ll) +
+			(copylen - dev->hard_header_len);
+
+		if (copylen + tp_len < PAGE_SIZE) {
+			alloclen += tp_len;
+			copylen = tp_len;
+		}
+
		skb = sock_alloc_send_skb(&po->sk,
-				hlen + tlen + sizeof(struct sockaddr_ll) +
-				(copylen - dev->hard_header_len),
+				alloclen,
				!need_wait, &err);

		if (unlikely(skb == NULL)) {
--
2.17.0
