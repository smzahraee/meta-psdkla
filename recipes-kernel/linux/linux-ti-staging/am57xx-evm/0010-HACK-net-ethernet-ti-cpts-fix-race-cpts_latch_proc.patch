From d9d5e8525e8e608081ce403e9ebafb66234dc037 Mon Sep 17 00:00:00 2001
From: "x1082265@ti.com" <dharma.b@mistralsolutions.com>
Date: Tue, 2 Nov 2021 12:00:48 +0530
Subject: [PATCH] HACK: net: ethernet: ti: cpts: fix race cpts_latch_proc  vs
 cpts_fifo_read

There is shared data used between cpts_latch_proc and cpts_fifo_read
 - pps_latch_offset
 - pps_latch_receive
and on RT Kernel both function are called from threaded IRQ context with
the same priority and so can race.

Add spin_lock section in cpts_latch_proc() to protect shared data.
---
 drivers/net/ethernet/ti/cpts.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
index ccd4a6b7c335..494972de5124 100644
--- a/drivers/net/ethernet/ti/cpts.c
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -1924,15 +1924,17 @@ static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
 {
        u32 offset = 0xFFFFFFFFUL - latch_cnt + 1;
        u32 reload_cnt = CPTS_LATCH_TMR_RELOAD_CNT;
+	unsigned long flags;
        static bool skip;
        static int init_cnt;
 
        if (!cpts)
                return;
-
+	spin_lock_irqsave(&cpts->lock, flags);
        cpts->pps_latch_offset = offset * CPTS_TMR_CLK_PERIOD +
                                 CPTS_TMR_LATCH_DELAY;
        cpts->pps_latch_receive = true;
+	spin_unlock_irqrestore(&cpts->lock, flags);
 
        /* Timer poll state machine */
        switch (cpts->pps_latch_state) {
-- 
2.17.1

