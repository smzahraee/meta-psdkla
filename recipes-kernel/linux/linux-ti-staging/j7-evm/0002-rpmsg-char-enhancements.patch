From 472d1f79e785bc3af7de92e122d707c68558e572 Mon Sep 17 00:00:00 2001
From: Subhajit Paul <subhajit_paul@ti.com>
Date: Tue, 5 Mar 2019 10:13:32 +0530
Subject: [PATCH 2/5] rpmsg-char: enhancements

To be specific, 3 enhancements:
1. use a id.table  in rpmsg-char driver. That way, it
   is automatically probed when the "rpmsg_chrdev"
   announce is recieved. The user is not responsible
   for binding the device to the driver using
   "driver_override".
2. Reserving the endpoint in the CREATE_ENDPT IOCTL, rather
   than waiting till open calls. This way, the users of
   /dev/rpmsg%d are guranteed to get the channel once the
   IOCTL succeeds, and prevents multiple /dev/rpmsg%d nodes
   pointing to the same local endpoint.
   At the same time it uses a atomic variable to ensure that
   only one fd can be opened for /dev/rpmsg%d at any time.
3. Allowing RPMSG_ADDR_ANY to be passed as a requested local
   endpoint. The driver reserves a local endpoint, and returns
   the reserved endpoint to the userspace. The dev.attr file
   is also created accordingly and reflects the created local
   endpoint number. It also modifies the dst address passed
   by userspace to reflect the dst address of the
   associated rpmsg_chrdev announce.

Signed-off-by: Subhajit Paul <subhajit_paul@ti.com>
---
 drivers/rpmsg/rpmsg_char.c | 67 ++++++++++++++++++++++++++++++----------------
 1 file changed, 44 insertions(+), 23 deletions(-)

diff --git a/drivers/rpmsg/rpmsg_char.c b/drivers/rpmsg/rpmsg_char.c
index 4bd9144..b2adb29 100644
--- a/drivers/rpmsg/rpmsg_char.c
+++ b/drivers/rpmsg/rpmsg_char.c
@@ -76,6 +76,8 @@ struct rpmsg_eptdev {
 	spinlock_t queue_lock;
 	struct sk_buff_head queue;
 	wait_queue_head_t readq;
+
+	atomic_t open_count;
 };
 
 static int rpmsg_eptdev_destroy(struct device *dev, void *data)
@@ -123,20 +125,13 @@ static int rpmsg_ept_cb(struct rpmsg_device *rpdev, void *buf, int len,
 static int rpmsg_eptdev_open(struct inode *inode, struct file *filp)
 {
 	struct rpmsg_eptdev *eptdev = cdev_to_eptdev(inode->i_cdev);
-	struct rpmsg_endpoint *ept;
-	struct rpmsg_device *rpdev = eptdev->rpdev;
 	struct device *dev = &eptdev->dev;
 
-	get_device(dev);
+	if(!atomic_add_unless(&eptdev->open_count, 1, 1))
+		return -EBUSY;
 
-	ept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, eptdev->chinfo);
-	if (!ept) {
-		dev_err(dev, "failed to open %s\n", eptdev->chinfo.name);
-		put_device(dev);
-		return -EINVAL;
-	}
+	get_device(dev);
 
-	eptdev->ept = ept;
 	filp->private_data = eptdev;
 
 	return 0;
@@ -148,14 +143,6 @@ static int rpmsg_eptdev_release(struct inode *inode, struct file *filp)
 	struct device *dev = &eptdev->dev;
 	struct sk_buff *skb;
 
-	/* Close the endpoint, if it's not already destroyed by the parent */
-	mutex_lock(&eptdev->ept_lock);
-	if (eptdev->ept) {
-		rpmsg_destroy_ept(eptdev->ept);
-		eptdev->ept = NULL;
-	}
-	mutex_unlock(&eptdev->ept_lock);
-
 	/* Discard all SKBs */
 	while (!skb_queue_empty(&eptdev->queue)) {
 		skb = skb_dequeue(&eptdev->queue);
@@ -164,6 +151,8 @@ static int rpmsg_eptdev_release(struct inode *inode, struct file *filp)
 
 	put_device(dev);
 
+	WARN_ON(atomic_dec_return(&eptdev->open_count));
+
 	return 0;
 }
 
@@ -338,22 +327,32 @@ static void rpmsg_eptdev_release_device(struct device *dev)
 	kfree(eptdev);
 }
 
-static int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,
+static struct rpmsg_eptdev *rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,
 			       struct rpmsg_channel_info chinfo)
 {
 	struct rpmsg_device *rpdev = ctrldev->rpdev;
 	struct rpmsg_eptdev *eptdev;
+	struct rpmsg_endpoint *ept;
 	struct device *dev;
 	int ret;
 
 	eptdev = kzalloc(sizeof(*eptdev), GFP_KERNEL);
 	if (!eptdev)
-		return -ENOMEM;
+		return NULL;
+
+	ept = rpmsg_create_ept(rpdev, rpmsg_ept_cb, eptdev, chinfo);
+	if(!ept)
+		goto free_mem;
+	eptdev->ept = ept;
+	chinfo.src = ept->addr;
+	chinfo.dst = rpdev->dst;
 
 	dev = &eptdev->dev;
 	eptdev->rpdev = rpdev;
 	eptdev->chinfo = chinfo;
 
+	atomic_set(&eptdev->open_count, 0);
+
 	mutex_init(&eptdev->ept_lock);
 	spin_lock_init(&eptdev->queue_lock);
 	skb_queue_head_init(&eptdev->queue);
@@ -390,9 +389,10 @@ static int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,
 	if (ret) {
 		dev_err(dev, "device_add failed: %d\n", ret);
 		put_device(dev);
+		rpmsg_destroy_ept(eptdev->ept);
 	}
 
-	return ret;
+	return ret ? NULL : eptdev;
 
 free_ept_ida:
 	ida_simple_remove(&rpmsg_ept_ida, dev->id);
@@ -400,9 +400,11 @@ static int rpmsg_eptdev_create(struct rpmsg_ctrldev *ctrldev,
 	ida_simple_remove(&rpmsg_minor_ida, MINOR(dev->devt));
 free_eptdev:
 	put_device(dev);
+	rpmsg_destroy_ept(eptdev->ept);
+free_mem:
 	kfree(eptdev);
 
-	return ret;
+	return NULL;
 }
 
 static int rpmsg_ctrldev_open(struct inode *inode, struct file *filp)
@@ -431,6 +433,7 @@ static long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,
 	void __user *argp = (void __user *)arg;
 	struct rpmsg_endpoint_info eptinfo;
 	struct rpmsg_channel_info chinfo;
+	struct rpmsg_eptdev *eptdev;
 
 	if (cmd != RPMSG_CREATE_EPT_IOCTL)
 		return -EINVAL;
@@ -444,7 +447,18 @@ static long rpmsg_ctrldev_ioctl(struct file *fp, unsigned int cmd,
 	chinfo.dst = eptinfo.dst;
 	chinfo.desc[0] = '\0';
 
-	return rpmsg_eptdev_create(ctrldev, chinfo);
+	eptdev = rpmsg_eptdev_create(ctrldev, chinfo);
+	if(!eptdev)
+		return -EINVAL;
+
+	eptinfo.src = eptdev->chinfo.src;
+	eptinfo.dst = eptdev->chinfo.dst;
+	if(copy_to_user(argp, &eptinfo, sizeof(eptinfo))) {
+		rpmsg_eptdev_destroy(&eptdev->dev, NULL);
+		return -EFAULT;
+	}
+
+	return 0;
 };
 
 static const struct file_operations rpmsg_ctrldev_fops = {
@@ -538,12 +552,19 @@ static void rpmsg_chrdev_remove(struct rpmsg_device *rpdev)
 	put_device(&ctrldev->dev);
 }
 
+static struct rpmsg_device_id rpmsg_char_id_table[] = {
+	{ .name	= "rpmsg_chrdev" },
+	{ },
+};
+MODULE_DEVICE_TABLE(rpmsg, rpmsg_char_id_table);
+
 static struct rpmsg_driver rpmsg_chrdev_driver = {
 	.probe = rpmsg_chrdev_probe,
 	.remove = rpmsg_chrdev_remove,
 	.drv = {
 		.name = "rpmsg_chrdev",
 	},
+	.id_table = rpmsg_char_id_table,
 };
 
 static int rpmsg_char_init(void)
-- 
2.7.4

