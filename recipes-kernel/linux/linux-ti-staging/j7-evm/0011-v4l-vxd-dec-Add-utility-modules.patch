From 862eda61f0672677fe22819d0f8ecdd2fa4ca27c Mon Sep 17 00:00:00 2001
From: Sidraya Jayagond <sidraya.bj@pathparntertech.com>
Date: Wed, 30 Jun 2021 16:03:28 +0530
Subject: [PATCH 11/29] v4l: vxd-dec: Add utility modules

Contains utility module for double linked queues and single linked
lists

Signed-off-by: Lakshmi Sankar <lakshmisankar-t@ti.com>
Signed-off-by: Sidraya Jayagond <sidraya.bj@pathparntertech.com>
---
 drivers/media/platform/vxe-vxd/common/dq.c    | 242 ++++++++++
 drivers/media/platform/vxe-vxd/common/dq.h    |  33 ++
 .../media/platform/vxe-vxd/common/idgen_api.c | 442 ++++++++++++++++++
 .../media/platform/vxe-vxd/common/idgen_api.h |  52 +++
 drivers/media/platform/vxe-vxd/common/lst.c   | 116 +++++
 drivers/media/platform/vxe-vxd/common/lst.h   |  29 ++
 6 files changed, 914 insertions(+)
 create mode 100644 drivers/media/platform/vxe-vxd/common/dq.c
 create mode 100644 drivers/media/platform/vxe-vxd/common/dq.h
 create mode 100644 drivers/media/platform/vxe-vxd/common/idgen_api.c
 create mode 100644 drivers/media/platform/vxe-vxd/common/idgen_api.h
 create mode 100644 drivers/media/platform/vxe-vxd/common/lst.c
 create mode 100644 drivers/media/platform/vxe-vxd/common/lst.h

diff --git a/drivers/media/platform/vxe-vxd/common/dq.c b/drivers/media/platform/vxe-vxd/common/dq.c
new file mode 100644
index 000000000000..5393c6efca16
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/dq.c
@@ -0,0 +1,242 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Utility module for doubly linked queues.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include <linux/types.h>
+#include <linux/dma-mapping.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-mem2mem.h>
+
+#include "dq.h"
+#include "img_errors.h"
+
+void dq_init(struct dq_linkage_t *queue)
+{
+	queue->fwd = (struct dq_linkage_t *)queue;
+	queue->back = (struct dq_linkage_t *)queue;
+}
+
+void dq_addhead(struct dq_linkage_t *queue, void *item)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->fwd);
+
+	if (!((struct dq_linkage_t *)queue)->back ||
+	    !((struct dq_linkage_t *)queue)->fwd)
+		return;
+
+	((struct dq_linkage_t *)item)->back = (struct dq_linkage_t *)queue;
+	((struct dq_linkage_t *)item)->fwd =
+					((struct dq_linkage_t *)queue)->fwd;
+	((struct dq_linkage_t *)queue)->fwd->back = (struct dq_linkage_t *)item;
+	((struct dq_linkage_t *)queue)->fwd = (struct dq_linkage_t *)item;
+}
+
+void dq_addtail(struct dq_linkage_t *queue, void *item)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->fwd);
+
+	if (!((struct dq_linkage_t *)queue)->back ||
+	    !((struct dq_linkage_t *)queue)->fwd)
+		return;
+
+	((struct dq_linkage_t *)item)->fwd = (struct dq_linkage_t *)queue;
+	((struct dq_linkage_t *)item)->back =
+					((struct dq_linkage_t *)queue)->back;
+	((struct dq_linkage_t *)queue)->back->fwd = (struct dq_linkage_t *)item;
+	((struct dq_linkage_t *)queue)->back = (struct dq_linkage_t *)item;
+}
+
+int dq_empty(struct dq_linkage_t *queue)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->fwd);
+
+	if (!((struct dq_linkage_t *)queue)->back ||
+	    !((struct dq_linkage_t *)queue)->fwd)
+		return 1;
+
+	return ((queue)->fwd == (struct dq_linkage_t *)(queue));
+}
+
+void *dq_first(struct dq_linkage_t *queue)
+{
+	struct dq_linkage_t *temp = queue->fwd;
+
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->fwd);
+
+	if (!((struct dq_linkage_t *)queue)->back ||
+	    !((struct dq_linkage_t *)queue)->fwd)
+		return NULL;
+
+	return temp == (struct dq_linkage_t *)queue ? NULL : temp;
+}
+
+void *dq_last(struct dq_linkage_t *queue)
+{
+	struct dq_linkage_t *temp = queue->back;
+
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->fwd);
+
+	if (!((struct dq_linkage_t *)queue)->back ||
+	    !((struct dq_linkage_t *)queue)->fwd)
+		return NULL;
+
+	return temp == (struct dq_linkage_t *)queue ? NULL : temp;
+}
+
+void *dq_next(void *item)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)item)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)item)->fwd);
+
+	if (!((struct dq_linkage_t *)item)->back ||
+	    !((struct dq_linkage_t *)item)->fwd)
+		return NULL;
+
+	return ((struct dq_linkage_t *)item)->fwd;
+}
+
+void *dq_previous(void *item)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)item)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)item)->fwd);
+
+	if (!((struct dq_linkage_t *)item)->back ||
+	    !((struct dq_linkage_t *)item)->fwd)
+		return NULL;
+
+	return ((struct dq_linkage_t *)item)->back;
+}
+
+void dq_remove(void *item)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)item)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)item)->fwd);
+
+	if (!((struct dq_linkage_t *)item)->back ||
+	    !((struct dq_linkage_t *)item)->fwd)
+		return;
+
+	((struct dq_linkage_t *)item)->fwd->back =
+					((struct dq_linkage_t *)item)->back;
+	((struct dq_linkage_t *)item)->back->fwd =
+					((struct dq_linkage_t *)item)->fwd;
+
+	/* make item linkages safe for "orphan" removes */
+	((struct dq_linkage_t *)item)->fwd = item;
+	((struct dq_linkage_t *)item)->back = item;
+}
+
+void *dq_removehead(struct dq_linkage_t *queue)
+{
+	struct dq_linkage_t *temp;
+
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->fwd);
+
+	if (!((struct dq_linkage_t *)queue)->back ||
+	    !((struct dq_linkage_t *)queue)->fwd)
+		return NULL;
+
+	if ((queue)->fwd == (struct dq_linkage_t *)(queue))
+		return NULL;
+
+	temp = ((struct dq_linkage_t *)queue)->fwd;
+	temp->fwd->back = temp->back;
+	temp->back->fwd = temp->fwd;
+
+	/* make item linkages safe for "orphan" removes */
+	temp->fwd = temp;
+	temp->back = temp;
+	return temp;
+}
+
+void *dq_removetail(struct dq_linkage_t *queue)
+{
+	struct dq_linkage_t *temp;
+
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)queue)->fwd);
+
+	if (!((struct dq_linkage_t *)queue)->back ||
+	    !((struct dq_linkage_t *)queue)->fwd)
+		return NULL;
+
+	if ((queue)->fwd == (struct dq_linkage_t *)(queue))
+		return NULL;
+
+	temp = ((struct dq_linkage_t *)queue)->back;
+	temp->fwd->back = temp->back;
+	temp->back->fwd = temp->fwd;
+
+	/* make item linkages safe for "orphan" removes */
+	temp->fwd = temp;
+	temp->back = temp;
+
+	return temp;
+}
+
+void dq_addbefore(void *successor, void *item)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)successor)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)successor)->fwd);
+
+	if (!((struct dq_linkage_t *)successor)->back ||
+	    !((struct dq_linkage_t *)successor)->fwd)
+		return;
+
+	((struct dq_linkage_t *)item)->fwd = (struct dq_linkage_t *)successor;
+	((struct dq_linkage_t *)item)->back =
+				((struct dq_linkage_t *)successor)->back;
+	((struct dq_linkage_t *)item)->back->fwd = (struct dq_linkage_t *)item;
+	((struct dq_linkage_t *)successor)->back = (struct dq_linkage_t *)item;
+}
+
+void dq_addafter(void *predecessor, void *item)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)predecessor)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)predecessor)->fwd);
+
+	if (!((struct dq_linkage_t *)predecessor)->back ||
+	    !((struct dq_linkage_t *)predecessor)->fwd)
+		return;
+
+	((struct dq_linkage_t *)item)->fwd =
+				((struct dq_linkage_t *)predecessor)->fwd;
+	((struct dq_linkage_t *)item)->back =
+					(struct dq_linkage_t *)predecessor;
+	((struct dq_linkage_t *)item)->fwd->back = (struct dq_linkage_t *)item;
+	((struct dq_linkage_t *)predecessor)->fwd = (struct dq_linkage_t *)item;
+}
+
+void dq_move(struct dq_linkage_t *from, struct dq_linkage_t *to)
+{
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)from)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)from)->fwd);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)to)->back);
+	IMG_DBG_ASSERT(((struct dq_linkage_t *)to)->fwd);
+
+	if (!((struct dq_linkage_t *)from)->back ||
+	    !((struct dq_linkage_t *)from)->fwd ||
+	    !((struct dq_linkage_t *)to)->back ||
+	    !((struct dq_linkage_t *)to)->fwd)
+		return;
+
+	if ((from)->fwd == (struct dq_linkage_t *)(from)) {
+		dq_init(to);
+	} else {
+		*to = *from;
+		to->fwd->back = (struct dq_linkage_t *)to;
+		to->back->fwd = (struct dq_linkage_t *)to;
+		dq_init(from);
+	}
+}
diff --git a/drivers/media/platform/vxe-vxd/common/dq.h b/drivers/media/platform/vxe-vxd/common/dq.h
new file mode 100644
index 000000000000..70cd7dca4d0b
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/dq.h
@@ -0,0 +1,33 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Utility module for doubly linked queues.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+#ifndef DQ_H
+#define DQ_H
+
+/* dq structure */
+struct dq_linkage_t {
+	struct dq_linkage_t *fwd;
+	struct dq_linkage_t *back;
+};
+
+/* Function Prototypes */
+void dq_addafter(void *predecessor, void *item);
+void dq_addbefore(void *successor, void *item);
+void dq_addhead(struct dq_linkage_t *queue, void *item);
+void dq_addtail(struct dq_linkage_t *queue, void *item);
+int dq_empty(struct dq_linkage_t *queue);
+void *dq_first(struct dq_linkage_t *queue);
+void *dq_last(struct dq_linkage_t *queue);
+void dq_init(struct dq_linkage_t *queue);
+void dq_move(struct dq_linkage_t *from, struct dq_linkage_t *to);
+void *dq_next(void *item);
+void *dq_previous(void *item);
+void dq_remove(void *item);
+void *dq_removehead(struct dq_linkage_t *queue);
+void *dq_removetail(struct dq_linkage_t *queue);
+
+#endif /* #define DQ_H */
diff --git a/drivers/media/platform/vxe-vxd/common/idgen_api.c b/drivers/media/platform/vxe-vxd/common/idgen_api.c
new file mode 100644
index 000000000000..e1c553413ea5
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/idgen_api.c
@@ -0,0 +1,442 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * ID generation manager API.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include <linux/dma-mapping.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-mem2mem.h>
+
+#include "idgen_api.h"
+#include "lst.h"
+
+/*
+ * This structure contains ID context.
+ */
+struct idgen_context {
+	/* List of handle block structures */
+	struct lst_t hdlblklst;
+	/* Max ID - set by IDGEN_CreateContext(). */
+	unsigned int maxid;
+	/*
+	 * The number of handle per block. In case of
+	 * incrementing ids, size of the Hash table.
+	 */
+	unsigned int blksize;
+	/* Next free slot. */
+	unsigned int freeslot;
+	/* Max slot+1 for which we have allocated blocks. */
+	unsigned int maxslotplus1;
+	/* Incrementing ID's */
+	/* API needed to return incrementing IDs */
+	int incids;
+	/* Latest ID given back */
+	unsigned int latestincnumb;
+	/* Array of list to hold IDGEN_sHdlId */
+	struct lst_t *incidlist;
+};
+
+/*
+ * This structure represents internal representation of an Incrementing ID.
+ */
+struct idgen_id {
+	void **link; /* to be part of single linked list */
+	/* Incrementing ID returned */
+	unsigned int incid;
+	void *hid;
+};
+
+/*
+ * Structure contains the ID context.
+ */
+struct idgen_hdblk {
+	void **link; /* to be part of single linked list */
+	/* Array of handles in this block. */
+	void *ahhandles[1];
+};
+
+/*
+ * A hashing function could go here. Currently just makes a circular list of
+ * max number of concurrent Ids (idgen_context->blksize) in the system.
+ */
+static unsigned int idgen_func(struct idgen_context *idcontext, unsigned int id)
+{
+	return ((id - 1) % idcontext->blksize);
+}
+
+int idgen_createcontext(unsigned int maxid, unsigned int blksize,
+			int incid, void **idgenhandle)
+{
+	struct idgen_context *idcontext;
+
+	/* Create context structure */
+	idcontext = kzalloc(sizeof(*idcontext), GFP_KERNEL);
+	if (!idcontext)
+		return IMG_ERROR_OUT_OF_MEMORY;
+
+	/* InitIalise the context */
+	lst_init(&idcontext->hdlblklst);
+	idcontext->maxid   = maxid;
+	idcontext->blksize = blksize;
+
+	/* If we need incrementing Ids */
+	idcontext->incids = incid;
+	idcontext->latestincnumb = 0;
+	idcontext->incidlist  = NULL;
+	if (idcontext->incids) {
+		unsigned int i = 0;
+		/* Initialise the hash table of lists of length ui32BlkSize */
+		idcontext->incidlist = kzalloc((sizeof(*idcontext->incidlist) *
+				idcontext->blksize), GFP_KERNEL);
+		if (!idcontext->incidlist) {
+			kfree(idcontext);
+			return IMG_ERROR_OUT_OF_MEMORY;
+		}
+
+		/* Initialise all the lists in the hash table */
+		for (i = 0; i < idcontext->blksize; i++)
+			lst_init(&idcontext->incidlist[i]);
+	}
+
+	/* Return context structure as handle */
+	*idgenhandle = idcontext;
+
+	return IMG_SUCCESS;
+}
+
+int idgen_destroycontext(void *idgenhandle)
+{
+	struct idgen_context *idcontext = (struct idgen_context *)idgenhandle;
+	struct idgen_hdblk *hdblk;
+
+	if (!idcontext)
+		return IMG_ERROR_INVALID_PARAMETERS;
+
+	/* If incrementing Ids, free the List of Incrementing Ids */
+	if (idcontext->incids) {
+		struct idgen_id *id;
+		unsigned int i = 0;
+
+		for (i = 0; i < idcontext->blksize; i++) {
+			id = lst_removehead(&idcontext->incidlist[i]);
+			while (id) {
+				kfree(id);
+				id = lst_removehead(&idcontext->incidlist[i]);
+			}
+		}
+		kfree(idcontext->incidlist);
+	}
+
+	/* Remove and free all handle blocks */
+	hdblk = (struct idgen_hdblk *)lst_removehead(&idcontext->hdlblklst);
+	while (hdblk) {
+		kfree(hdblk);
+		hdblk = (struct idgen_hdblk *)
+				lst_removehead(&idcontext->hdlblklst);
+	}
+
+	/* Free context structure */
+	kfree(idcontext);
+
+	return IMG_SUCCESS;
+}
+
+static int idgen_findnextfreeslot(void *idgenhandle, unsigned int prevfreeslot)
+{
+	struct idgen_context *idcontext = (struct idgen_context *)idgenhandle;
+	struct idgen_hdblk *hdblk;
+	unsigned int freslotblk;
+	unsigned int freeslot;
+
+	if (!idcontext)
+		return IMG_ERROR_INVALID_PARAMETERS;
+
+	/* Find the block containing the current free slot */
+	freeslot	= prevfreeslot;
+	freslotblk = prevfreeslot;
+	hdblk = (struct idgen_hdblk *)lst_first(&idcontext->hdlblklst);
+	if (!hdblk)
+		return IMG_ERROR_FATAL;
+
+	while (freslotblk >= idcontext->blksize) {
+		freslotblk -= idcontext->blksize;
+		hdblk = (struct idgen_hdblk *)lst_next(hdblk);
+	}
+
+	/* Locate the next free slot */
+	while (hdblk) {
+		while (freslotblk < idcontext->blksize) {
+			if (!hdblk->ahhandles[freslotblk]) {
+				/* Found */
+				idcontext->freeslot = freeslot;
+				return IMG_SUCCESS;
+			}
+			freeslot++;
+			freslotblk++;
+		}
+		freslotblk = 0;
+		hdblk = (struct idgen_hdblk *)lst_next(hdblk);
+	}
+
+	/* Beyond the last block */
+	idcontext->freeslot = freeslot;
+	return IMG_SUCCESS;
+}
+
+/*
+ * This function returns ID structure (
+ */
+static struct idgen_id *idgen_getid(struct lst_t *idlist, unsigned int id)
+{
+	struct idgen_id *idstruct;
+
+	idstruct = lst_first(idlist);
+	while (idstruct) {
+		if (idstruct->incid == id)
+			break;
+
+		idstruct = lst_next(idstruct);
+	}
+	return idstruct;
+}
+
+/*
+ * This function does IDGEN allocation.
+ */
+int idgen_allocid(void *idgenhandle, void *handle, unsigned int *id)
+{
+	struct idgen_context *idcontext = (struct idgen_context *)idgenhandle;
+	struct idgen_hdblk *hdblk;
+	unsigned int size = 0;
+	unsigned int freeslot = 0;
+	unsigned int result = 0;
+
+	if (!idcontext || !handle)
+		return IMG_ERROR_INVALID_PARAMETERS;
+
+	if (!idcontext->incids) {
+		/* If the free slot is >= to the max id */
+		if (idcontext->freeslot >= idcontext->maxid) {
+			result = IMG_ERROR_INVALID_ID;
+			goto error;
+		}
+
+		/* If all of the allocated Ids have been used */
+		if (idcontext->freeslot >= idcontext->maxslotplus1) {
+			/* Allocate a stream context */
+			size = sizeof(*hdblk) + (sizeof(void *) *
+				(idcontext->blksize - 1));
+			hdblk = kzalloc(size, GFP_KERNEL);
+			if (!hdblk) {
+				result = IMG_ERROR_OUT_OF_MEMORY;
+				goto error;
+			}
+
+			lst_add(&idcontext->hdlblklst, hdblk);
+			idcontext->maxslotplus1 += idcontext->blksize;
+		}
+
+		/* Find the block containing the next free slot */
+		freeslot = idcontext->freeslot;
+		hdblk = (struct idgen_hdblk *)lst_first(&idcontext->hdlblklst);
+		if (!hdblk) {
+			result = IMG_ERROR_FATAL;
+			goto error;
+		}
+		while (freeslot >= idcontext->blksize) {
+			freeslot -= idcontext->blksize;
+			hdblk = (struct idgen_hdblk *)lst_next(hdblk);
+			if (!hdblk) {
+				result = IMG_ERROR_FATAL;
+				goto error;
+			}
+		}
+
+		/* Put handle in the next free slot */
+		hdblk->ahhandles[freeslot] = handle;
+
+		*id = idcontext->freeslot + 1;
+
+		/* Find a new free slot */
+		result = idgen_findnextfreeslot(idcontext, idcontext->freeslot);
+		if (result != 0)
+			goto error;
+	/*
+	 * If incrementing IDs, just add the ID node to the correct hash table
+	 * list.
+	 */
+	} else {
+		struct idgen_id *psid;
+		unsigned int currentincnum, funcid;
+		/*
+		 * If incrementing IDs, increment the id for returning back,and
+		 * save the ID node in the list of ids, indexed by hash function
+		 * (idgen_func). We might want to use a better hashing function
+		 */
+		currentincnum = (idcontext->latestincnumb + 1) %
+				idcontext->maxid;
+
+		/* Increment the id. Wraps if greater then Max Id */
+		if (currentincnum == 0)
+			currentincnum++;
+
+		idcontext->latestincnumb = currentincnum;
+
+		result = IMG_ERROR_INVALID_ID;
+		do {
+			/* Add to list in the correct hash table entry */
+			funcid = idgen_func(idcontext, idcontext->latestincnumb);
+			if (idgen_getid(&idcontext->incidlist[funcid],
+					idcontext->latestincnumb) == NULL) {
+				psid = kmalloc(sizeof(*psid), GFP_KERNEL);
+				if (!psid) {
+					result = IMG_ERROR_OUT_OF_MEMORY;
+					goto error;
+				}
+
+				psid->incid = idcontext->latestincnumb;
+				psid->hid = handle;
+
+				funcid = idgen_func(idcontext,
+						    idcontext->latestincnumb);
+				lst_add(&idcontext->incidlist[funcid],
+					psid);
+
+				result = IMG_SUCCESS;
+			} else {
+				idcontext->latestincnumb =
+					(idcontext->latestincnumb + 1) %
+						idcontext->maxid;
+				if (idcontext->latestincnumb == 0) {
+					/* Do not want to have zero as pic id */
+					idcontext->latestincnumb++;
+				}
+				/*
+				 * We have reached a point where we have wrapped
+				 * allowed Ids (MaxId) and we want to overwrite
+				 * ID still not released
+				 */
+				if (idcontext->latestincnumb == currentincnum)
+					goto error;
+			}
+		} while (result != IMG_SUCCESS);
+
+		*id = psid->incid;
+	}
+	return IMG_SUCCESS;
+error:
+	return result;
+}
+
+int idgen_freeid(void *idgenhandle, unsigned int id)
+{
+	struct idgen_context *idcontext = (struct idgen_context *)idgenhandle;
+	struct idgen_hdblk *hdblk;
+	unsigned int origslot;
+	unsigned int slot;
+
+	if (idcontext->incids) {
+		/*
+		 * Find the slot in the correct hash table entry, and
+		 * remove the ID.
+		 */
+		struct idgen_id *psid;
+
+		psid = idgen_getid(&idcontext->incidlist
+				[idgen_func(idcontext, id)], id);
+		if (psid) {
+			lst_remove(&idcontext->incidlist
+					[idgen_func(idcontext, id)], psid);
+			kfree(psid);
+		} else {
+			return IMG_ERROR_INVALID_ID;
+		}
+	} else {
+		/* If not incrementing id */
+		slot = id - 1;
+		origslot = slot;
+
+		if (slot >= idcontext->maxslotplus1)
+			return IMG_ERROR_INVALID_ID;
+
+		/* Find the block containing the id */
+		hdblk = (struct idgen_hdblk *)lst_first(&idcontext->hdlblklst);
+		if (!hdblk)
+			return IMG_ERROR_FATAL;
+
+		while (slot >= idcontext->blksize) {
+			slot -= idcontext->blksize;
+			hdblk = (struct idgen_hdblk *)lst_next(hdblk);
+			if (!hdblk)
+				return IMG_ERROR_FATAL;
+		}
+
+		/* Slot should be occupied */
+		if (!hdblk->ahhandles[slot])
+			return IMG_ERROR_INVALID_ID;
+
+		/* Free slot */
+		hdblk->ahhandles[slot] = NULL;
+
+		/* If this slot is before the previous free slot */
+		if ((origslot) < idcontext->freeslot)
+			idcontext->freeslot = origslot;
+	}
+	return IMG_SUCCESS;
+}
+
+int idgen_gethandle(void *idgenhandle, unsigned int id, void **handle)
+{
+	struct idgen_context *idcontext = (struct idgen_context *)idgenhandle;
+	struct idgen_hdblk *hdblk;
+	unsigned int slot;
+
+	if (!idcontext)
+		return IMG_ERROR_INVALID_PARAMETERS;
+
+	if (idcontext->incids) {
+		/*
+		 * Find the slot in the correct hash table entry, and return
+		 * the handles.
+		 */
+		struct idgen_id *psid;
+
+		psid = idgen_getid(&idcontext->incidlist
+				[idgen_func(idcontext, id)], id);
+		if (psid)
+			*handle = psid->hid;
+
+		else
+			return IMG_ERROR_INVALID_ID;
+	} else {
+		/* If not incrementing IDs */
+		slot = id - 1;
+		if (slot >= idcontext->maxslotplus1)
+			return IMG_ERROR_INVALID_ID;
+
+		/* Find the block containing the id */
+		hdblk = (struct idgen_hdblk *)lst_first(&idcontext->hdlblklst);
+		if (!hdblk)
+			return IMG_ERROR_INVALID_PARAMETERS;
+
+		while (slot >= idcontext->blksize) {
+			slot -= idcontext->blksize;
+			hdblk = (struct idgen_hdblk *)lst_next(hdblk);
+			if (!hdblk)
+				return IMG_ERROR_INVALID_PARAMETERS;
+		}
+
+		/* Slot should be occupied */
+		if (!hdblk->ahhandles[slot])
+			return IMG_ERROR_INVALID_ID;
+
+		/* Return the handle */
+		*handle = hdblk->ahhandles[slot];
+		}
+
+	return IMG_SUCCESS;
+}
diff --git a/drivers/media/platform/vxe-vxd/common/idgen_api.h b/drivers/media/platform/vxe-vxd/common/idgen_api.h
new file mode 100644
index 000000000000..e8a6400a6f5e
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/idgen_api.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * ID generation manager API.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+#ifndef __IDGENAPI_H__
+#define __IDGENAPI_H__
+
+#include <linux/types.h>
+
+#include "img_errors.h"
+
+/*
+ * This function is used to create Id generation context.
+ * NOTE: Should only be called once to setup the context structure.
+ * NOTE: The client is responsible for providing thread/process safe locks on
+ * the context structure to maintain coherence.
+ */
+int idgen_createcontext(unsigned int maxid, unsigned int blksize,
+			int incid, void **idgenhandle);
+
+/*
+ * This function is used to destroy an Id generation context.  This function
+ * discards any handle blocks associated with the context.
+ * NOTE: The client is responsible for providing thread/process safe locks on
+ * the context structure to maintain coherence.
+ */
+int idgen_destroycontext(void *idgenhandle);
+
+/*
+ * This function is used to associate a handle with an Id.
+ * NOTE: The client is responsible for providing thread/process safe locks on
+ * the context structure to maintain coherency.
+ */
+int idgen_allocid(void *idgenhandle, void *handle, unsigned int *id);
+
+/*
+ * This function is used to free an Id.
+ * NOTE: The client is responsible for providing thread/process safe locks on
+ * the context structure to maintain coherency.
+ */
+int idgen_freeid(void *idgenhandle, unsigned int id);
+
+/*
+ * This function is used to get the handle associated with an Id.
+ * NOTE: The client is responsible for providing thread/process safe locks on
+ * the context structure to maintain coherency.
+ */
+int idgen_gethandle(void *idgenhandle, unsigned int id, void **handle);
+#endif /* __IDGENAPI_H__ */
diff --git a/drivers/media/platform/vxe-vxd/common/lst.c b/drivers/media/platform/vxe-vxd/common/lst.c
new file mode 100644
index 000000000000..56a026e430c0
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/lst.c
@@ -0,0 +1,116 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * List processing primitives.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include "lst.h"
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+void lst_add(struct lst_t *list, void *item)
+{
+	if (!list->first) {
+		list->first = item;
+		list->last = item;
+	} else {
+		*list->last = item;
+		list->last = item;
+	}
+	*((void **)item) = NULL;
+}
+
+void lst_addhead(struct lst_t *list, void *item)
+{
+	if (!list->first) {
+		list->first = item;
+		list->last = item;
+		*((void **)item) = NULL;
+	} else {
+		*((void **)item) = list->first;
+		list->first = item;
+	}
+}
+
+int lst_empty(struct lst_t *list)
+{
+	if (!list->first)
+		return 1;
+	else
+		return 0;
+}
+
+void *lst_first(struct lst_t *list)
+{
+	return list->first;
+}
+
+void lst_init(struct lst_t *list)
+{
+	list->first = NULL;
+	list->last = NULL;
+}
+
+void *lst_last(struct lst_t *list)
+{
+	return list->last;
+}
+
+void *lst_next(void *item)
+{
+	return *((void **)item);
+}
+
+void *lst_removehead(struct lst_t *list)
+{
+	void **temp = list->first;
+
+	if (temp) {
+		list->first = *temp;
+		if (!list->first)
+			list->last = NULL;
+	}
+	return temp;
+}
+
+void *lst_remove(struct lst_t *list, void *item)
+{
+	void **p;
+	void **q;
+
+	p = (void **)list;
+	q = *p;
+	while (q) {
+		if (q == item) {
+			*p = *q;
+			if (list->last == q)
+				list->last = p;
+			return item;
+		}
+		p = q;
+		q = *p;
+	}
+
+	return NULL;
+}
+
+int lst_check(struct lst_t *list, void *item)
+{
+	void **p;
+	void **q;
+
+	p = (void **)list;
+	q = *p;
+	while (q) {
+		if (q == item)
+			return 1;
+		p = q;
+		q = *p;
+	}
+
+	return 0;
+}
diff --git a/drivers/media/platform/vxe-vxd/common/lst.h b/drivers/media/platform/vxe-vxd/common/lst.h
new file mode 100644
index 000000000000..63ee2da5bd4f
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/lst.h
@@ -0,0 +1,29 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * List processing primitives.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+#ifndef __LIST_H__
+#define __LIST_H__
+
+#include <linux/types.h>
+
+struct lst_t {
+	void **first;
+	void **last;
+};
+
+void lst_add(struct lst_t *list, void *item);
+void lst_addhead(struct lst_t *list, void *item);
+int  lst_empty(struct lst_t *list);
+void *lst_first(struct lst_t *list);
+void lst_init(struct lst_t *list);
+void *lst_last(struct lst_t *list);
+void *lst_next(void *item);
+void *lst_remove(struct lst_t *list, void *item);
+void *lst_removehead(struct lst_t *list);
+int lst_check(struct lst_t *list, void *item);
+
+#endif /* __LIST_H__ */
-- 
2.17.1

