From e94f800c083748e74d8eb0cdc79ce0870d0d4210 Mon Sep 17 00:00:00 2001
From: Prasanth Babu Mantena <p-mantena@ti.com>
Date: Tue, 1 Feb 2022 13:11:04 +0530
Subject: [PATCH] vxe-vxd: decoder: Add seek functionality

Add seek functionality, which is a series of stop and start streaming
calls, handling interrupts and flags in between. Clean logs on Cntrl+C.
Clean mutex locks and flags implemented.

Signed-off-by: Prasanth Babu Mantena <p-mantena@ti.com>
---
 .../media/platform/vxe-vxd/decoder/vxd_dec.h  |  6 +-
 .../media/platform/vxe-vxd/decoder/vxd_v4l2.c | 72 +++++++++----------
 2 files changed, 34 insertions(+), 44 deletions(-)

diff --git a/drivers/media/platform/vxe-vxd/decoder/vxd_dec.h b/drivers/media/platform/vxe-vxd/decoder/vxd_dec.h
index 4814b49e7..1c87906b3 100644
--- a/drivers/media/platform/vxe-vxd/decoder/vxd_dec.h
+++ b/drivers/media/platform/vxe-vxd/decoder/vxd_dec.h
@@ -268,6 +268,7 @@ struct vxd_dev {
 	struct platform_device *plat_dev;
 	struct v4l2_m2m_dev *m2m_dev;
 	struct mutex  *mutex; /* Per device mutex */
+	struct mutex  *mutex_queue; /* Mutex for ioctl synchronization on queue */
 	int module_irq;
 	void __iomem *reg_base;
 	struct vxd_core_props props;
@@ -297,7 +298,6 @@ struct vxd_dev {
 	unsigned long long dwr_start;
 	struct time_prof time_fw[MAX_BUF_TRACE];
 	struct time_prof time_drv[MAX_BUF_TRACE];
-	unsigned char map_info_flag;
 
 	/* The variables defined below are used in RTOS only. */
 	/* This variable holds queue handler */
@@ -429,10 +429,6 @@ struct vxd_dec_ctx {
 	struct bspp_ddbuf_array_info fw_pps[MAX_PPSS];
 	decode_cb cb;
 	struct mutex *mutex; /* Per stream mutex */
-	struct vxd_buffer *curr_src;
-	struct vxd_buffer *curr_dst;
-	unsigned char call_back_no;
-	unsigned char unmap_flag;
 
 	/* The below variable used only in Rtos */
 	void *mm_return_resource; /* Place holder for CB to application */
diff --git a/drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c b/drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c
index 97e6dd909..811d898bb 100644
--- a/drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c
+++ b/drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c
@@ -401,11 +401,6 @@ static void vxd_return_resource(void *ctx_handle, enum vxd_cb_type type,
 	int i;
 	struct vxd_dec_q_data *q_data;
 
-	if (ctx->aborting) {
-		v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
-		return;
-	}
-
 	switch (type) {
 	case VXD_CB_STRUNIT_PROCESSED:
 
@@ -425,7 +420,6 @@ static void vxd_return_resource(void *ctx_handle, enum vxd_cb_type type,
 					      ctx->pict_bufcfg.plane_size[i]);
 
 		v4l2_m2m_buf_done(&buf->buffer.vb, VB2_BUF_STATE_DONE);
-		ctx->call_back_no++;
 		break;
 	case VXD_CB_SPS_RELEASE:
 		break;
@@ -445,7 +439,6 @@ static void vxd_return_resource(void *ctx_handle, enum vxd_cb_type type,
 
 		schedule_work(res->work);
 
-		ctx->call_back_no++;
 		break;
 	case VXD_CB_PICT_DISPLAY:
 		buf = find_buffer(buf_map_id, &ctx->cap_buffers);
@@ -465,7 +458,6 @@ static void vxd_return_resource(void *ctx_handle, enum vxd_cb_type type,
 					      ctx->pict_bufcfg.plane_size[i]);
 
 		v4l2_m2m_buf_done(&buf->buffer.vb, VB2_BUF_STATE_DONE);
-		ctx->call_back_no++;
 		break;
 	case VXD_CB_PICT_RELEASE:
 		buf = find_buffer(buf_map_id, &ctx->reuse_queue);
@@ -826,8 +818,6 @@ static int vxd_dec_start_streaming(struct vb2_queue *vq, unsigned int count)
 			return ret;
 		}
 		ctx->core_streaming = TRUE;
-		ctx->unmap_flag = FALSE;
-		ctx->dev->map_info_flag = FALSE;
 		ctx->aborting = 0;
 	}
 
@@ -850,17 +840,21 @@ static void vxd_dec_stop_streaming(struct vb2_queue *vq)
 		vxd_dec_return_all_buffers(ctx, vq, VB2_BUF_STATE_ERROR);
 		return;
 	}
+
 	if (ctx->core_streaming) {
 		core_stream_stop(ctx->res_str_id);
 		ctx->core_streaming = FALSE;
 
 		core_stream_flush(ctx->res_str_id, TRUE);
 	}
-	ctx->aborting = 1;
+
 	/* unmap all the output and capture plane buffers */
 	if (V4L2_TYPE_IS_OUTPUT(vq->type)) {
 		list_for_each(list, &ctx->out_buffers) {
 			buf = list_entry(list, struct vxd_buffer, list);
+			core_stream_unmap_buf_sg(buf->buf_map_id);
+			buf->mapped = FALSE;
+			__list_del_entry(&buf->list);
 		}
 	} else {
 		list_for_each_safe(list, temp, &ctx->reuse_queue) {
@@ -871,10 +865,13 @@ static void vxd_dec_stop_streaming(struct vb2_queue *vq)
 
 		list_for_each(list, &ctx->cap_buffers) {
 			buf = list_entry(list, struct vxd_buffer, list);
+			core_stream_unmap_buf_sg(buf->buf_map_id);
+			buf->mapped = FALSE;
+			__list_del_entry(&buf->list);
 		}
 	}
-	ctx->unmap_flag = TRUE;
-	ctx->dev->map_info_flag = TRUE;
+
+	ctx->flag_last = FALSE;
 	vxd_dec_return_all_buffers(ctx, vq, VB2_BUF_STATE_ERROR);
 }
 
@@ -903,7 +900,7 @@ static int queue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *ds
 	src_vq->ops = &vxd_dec_video_ops;
 	src_vq->mem_ops = &vb2_dma_sg_memops;
 	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
-	src_vq->lock = vxd->mutex;
+	src_vq->lock = vxd->mutex_queue;
 	src_vq->dev = vxd->v4l2_dev.dev;
 	ret = vb2_queue_init(src_vq);
 	if (ret)
@@ -922,7 +919,7 @@ static int queue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *ds
 	dst_vq->mem_ops = &vb2_dma_sg_memops;
 #endif
 	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
-	dst_vq->lock = vxd->mutex;
+	dst_vq->lock = vxd->mutex_queue;
 	dst_vq->dev = vxd->v4l2_dev.dev;
 	ret = vb2_queue_init(dst_vq);
 	if (ret) {
@@ -1040,17 +1037,23 @@ static int vxd_dec_open(struct file *file)
 
 static int vxd_dec_release(struct file *file)
 {
-	struct list_head *list;
-	struct list_head *temp;
-	struct vxd_buffer *buf = NULL;
 	struct vxd_dev *vxd = video_drvdata(file);
 	struct vxd_dec_ctx *ctx = file2ctx(file);
 	struct bspp_ddbuf_array_info *fw_sequ = ctx->fw_sequ;
 	struct bspp_ddbuf_array_info *fw_pps = ctx->fw_pps;
 	int i, ret = 0;
 	struct vxd_dec_q_data *s_q_data;
+	struct list_head *list;
+	struct list_head *temp;
+	struct vxd_buffer *buf = NULL;
 
 	s_q_data = &ctx->q_data[Q_DATA_SRC];
+	if (ctx->core_streaming) {
+		core_stream_stop(ctx->res_str_id);
+		ctx->core_streaming = FALSE;
+
+		core_stream_flush(ctx->res_str_id, TRUE);
+	}
 
 	list_for_each(list, &ctx->out_buffers) {
 		buf = list_entry(list, struct vxd_buffer, list);
@@ -1709,9 +1712,6 @@ static void device_run(void *priv)
 	    (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) == 0))
 		ctx->eos = TRUE;
 
-	ctx->curr_src = src_vxdb;
-	ctx->curr_dst = dst_vxdb;
-	ctx->call_back_no = 0;
 	mutex_unlock(ctx->mutex);
 
 	ret = bspp_stream_preparse_buffers(ctx->bspp_context, NULL, 0, &ctx->seg_list,
@@ -1822,25 +1822,9 @@ static int job_ready(void *priv)
 static void job_abort(void *priv)
 {
 	struct vxd_dec_ctx *ctx = priv;
-	mutex_lock_nested(ctx->mutex, SUBCLASS_VXD_CORE);
-	if (ctx->core_streaming) {
-		core_stream_stop(ctx->res_str_id);
-		ctx->core_streaming = FALSE;
 
-		core_stream_flush(ctx->res_str_id, TRUE);
-	}
-	if (ctx->call_back_no == 0) {
-		vxd_return_resource((void *)ctx, VXD_CB_PICT_DECODED,
-				    ctx->curr_dst->buf_map_id);
-		vxd_return_resource((void *)ctx, VXD_CB_PICT_DISPLAY,
-				    ctx->curr_dst->buf_map_id);
-		vxd_return_resource((void *)ctx, VXD_CB_PICT_RELEASE,
-				    ctx->curr_dst->buf_map_id);
-		vxd_return_resource((void *)ctx, VXD_CB_STRUNIT_PROCESSED,
-				    ctx->curr_src->buf_map_id);
-		v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
-	}
-	mutex_unlock(ctx->mutex);
+	/* Cancel the transaction at next callback */
+	ctx->aborting = 1;
 }
 
 static const struct v4l2_m2m_ops m2m_ops = {
@@ -1906,6 +1890,13 @@ static int vxd_dec_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	mutex_init(vxd->mutex);
+
+	vxd->mutex_queue = kzalloc(sizeof(*vxd->mutex_queue), GFP_KERNEL);
+	if (!vxd->mutex_queue)
+		return -ENOMEM;
+
+	mutex_init(vxd->mutex_queue);
+
 	platform_set_drvdata(pdev, vxd);
 
 	pm_runtime_enable(&pdev->dev);
@@ -2121,8 +2112,11 @@ static int vxd_dec_remove(struct platform_device *pdev)
 	pm_runtime_disable(&pdev->dev);
 	kfree(vxd->dwork);
 	mutex_destroy(vxd->mutex);
+	mutex_destroy(vxd->mutex_queue);
 	kfree(vxd->mutex);
+	kfree(vxd->mutex_queue);
 	vxd->mutex = NULL;
+	vxd->mutex_queue = NULL;
 
 	video_unregister_device(vxd->vfd_dec);
 	v4l2_m2m_release(vxd->m2m_dev);
-- 
2.17.1

