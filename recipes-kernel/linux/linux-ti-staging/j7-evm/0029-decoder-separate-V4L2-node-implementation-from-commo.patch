From e846b63bb42b99ff6f8587e66b8e6e3a91df3a49 Mon Sep 17 00:00:00 2001
From: Sidraya Jayagond <sidraya.bj@pathparntertech.com>
Date: Wed, 30 Jun 2021 17:19:52 +0530
Subject: [PATCH 29/29] decoder: separate V4L2 node implementation from common
 driver

To make common driver OS agnostic, some of the interface logic
has been split between common driver and linux specific.
And moved all Linux specific implementation from decoder folder
to linux/decoder.

Signed-off-by: Amit Makani <amit.makani@ti.com>
Signed-off-by: Sunita Nadampalli <sunitan@ti.com>
Signed-off-by: Sidraya Jayagond <sidraya.bj@pathparntertech.com>
---
 .../media/platform/vxe-vxd/common/vid_buf.h   |   36 +
 .../platform/vxe-vxd/common/work_queue.c      |  175 +
 .../platform/vxe-vxd/common/work_queue.h      |   60 +
 .../media/platform/vxe-vxd/decoder/h264_idx.h |   58 +
 .../media/platform/vxe-vxd/decoder/h264_vlc.h |  602 ++++
 .../vxe-vxd/decoder/hevc_secure_parser.c      | 2888 +++++++++++++++++
 .../vxe-vxd/decoder/hevc_secure_parser.h      |  445 +++
 .../platform/vxe-vxd/decoder/hevcfw_data.h    |  469 +++
 .../vxe-vxd/decoder/hevcfw_data_shared.h      |  761 +++++
 .../vxe-vxd/decoder/pvdec_entropy_regs.h      | 1579 +++++++++
 .../vxe-vxd/decoder/pvdec_vec_be_hevc_regs.h  | 1456 +++++++++
 .../vxe-vxd/decoder/pvdec_vec_be_regs.h       | 1001 ++++++
 .../media/platform/vxe-vxd/decoder/vxd_v4l2.c | 2125 ++++++++++++
 13 files changed, 11655 insertions(+)
 create mode 100644 drivers/media/platform/vxe-vxd/common/vid_buf.h
 create mode 100644 drivers/media/platform/vxe-vxd/common/work_queue.c
 create mode 100644 drivers/media/platform/vxe-vxd/common/work_queue.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/h264_idx.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/h264_vlc.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.c
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/hevcfw_data.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/hevcfw_data_shared.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/pvdec_entropy_regs.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_hevc_regs.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_regs.h
 create mode 100644 drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c

diff --git a/drivers/media/platform/vxe-vxd/common/vid_buf.h b/drivers/media/platform/vxe-vxd/common/vid_buf.h
new file mode 100644
index 000000000000..df334a1abda9
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/vid_buf.h
@@ -0,0 +1,36 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Low-level VXD interface component
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef _VID_BUF_H
+#define _VID_BUF_H
+
+/*
+ * struct vidio_ddbufinfo - contains information about virtual address
+ * @buf_size: the size of the buffer (in bytes).
+ * @cpu_virt: the cpu virtual address  (mapped into the local cpu mmu)
+ * @dev_virt: device virtual address (pages mapped into IMG H/W mmu)
+ * @hndl_memory: handle to device mmu mapping
+ * @buff_id: buffer id used in communication with interface
+ * @is_internal: true, if the buffer is allocated internally
+ * @ref_count: reference count (number of users)
+ * @kmstr_id: stream id
+ * @core_id: core id
+ */
+struct vidio_ddbufinfo {
+	unsigned int buf_size;
+	void *cpu_virt;
+	unsigned int dev_virt;
+	void *hndl_memory;
+	unsigned int buff_id;
+	unsigned int is_internal;
+	unsigned int ref_count;
+	unsigned int kmstr_id;
+	unsigned int core_id;
+};
+
+#endif /* _VID_BUF_H */
diff --git a/drivers/media/platform/vxe-vxd/common/work_queue.c b/drivers/media/platform/vxe-vxd/common/work_queue.c
new file mode 100644
index 000000000000..4d1d7b787c5c
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/work_queue.c
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Work Queue Handling for Linux
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include <linux/slab.h>
+#include <linux/printk.h>
+#include <linux/mutex.h>
+
+#include "work_queue.h"
+/* Defining and initilizing mutex
+ */
+DEFINE_MUTEX(mutex);
+
+#define false 0
+#define true 1
+
+struct node {
+	void **key;
+	struct node *next;
+};
+
+struct node *work_head;
+struct node *delayed_work_head;
+
+void init_work(void **work_args, void *work_fn, uint8_t hwa_id)
+{
+	struct work_struct **work = (struct work_struct **)work_args;
+	//create a link
+	struct node *link = kmalloc(sizeof(*link), GFP_KERNEL);
+
+	*work = kzalloc(sizeof(*work), GFP_KERNEL);
+	if (!(*work)) {
+		pr_err("Memory allocation failed for work_queue\n");
+		return;
+	}
+	INIT_WORK(*work, work_fn);
+
+	link->key = (void **)work;
+	mutex_lock(&mutex);
+	//point it to old first node
+	link->next = work_head;
+
+	//point first to new first node
+	work_head = link;
+	mutex_unlock(&mutex);
+}
+
+void init_delayed_work(void **work_args, void *work_fn, uint8_t hwa_id)
+{
+	struct delayed_work **work = (struct delayed_work **)work_args;
+	//create a link
+	struct node *link = kmalloc(sizeof(*link), GFP_KERNEL);
+
+	*work = kzalloc(sizeof(*work), GFP_KERNEL);
+	if (!(*work)) {
+		pr_err("Memory allocation failed for delayed_work_queue\n");
+		return;
+	}
+	INIT_DELAYED_WORK(*work, work_fn);
+
+	link->key = (void **)work;
+	mutex_lock(&mutex);
+	//point it to old first node
+	link->next = delayed_work_head;
+
+	//point first to new first node
+	delayed_work_head = link;
+	mutex_unlock(&mutex);
+}
+
+void *get_work_buff(void *key, signed char flag)
+{
+	struct node *data = NULL;
+	void *work_new = NULL;
+	struct node *temp = NULL;
+	struct node *previous = NULL;
+	struct work_struct **work = NULL;
+
+	//start from the first link
+	mutex_lock(&mutex);
+	temp = work_head;
+
+	//if list is empty
+	if (!work_head) {
+		mutex_unlock(&mutex);
+		return NULL;
+	}
+
+	work = ((struct work_struct **)(temp->key));
+	//navigate through list
+	while (*work != key) {
+		//if it is last node
+		if (!temp->next) {
+			mutex_unlock(&mutex);
+			return NULL;
+		}
+			//store reference to current link
+			previous = temp;
+			//move to next link
+			temp = temp->next;
+			work = ((struct work_struct **)(temp->key));
+	}
+
+	if (flag) {
+		//found a match, update the link
+		if (temp == work_head) {
+			//change first to point to next link
+			work_head = work_head->next;
+		} else {
+			//bypass the current link
+			previous->next = temp->next;
+		}
+	}
+
+	mutex_unlock(&mutex);
+	//return temp;
+	data = temp;
+	if (data) {
+		work_new = data->key;
+		if (flag)
+			kfree(data);
+	}
+	return work_new;
+}
+
+void *get_delayed_work_buff(void *key, signed char flag)
+{
+	struct node *data = NULL;
+	void *dwork_new = NULL;
+	struct node *temp = NULL;
+	struct node *previous = NULL;
+	struct delayed_work **dwork = NULL;
+
+	if (flag) {
+		/* This Condition is true when kernel module is removed */
+		return delayed_work_head;
+	}
+	//start from the first link
+	mutex_lock(&mutex);
+	temp = delayed_work_head;
+
+	//if list is empty
+	if (!delayed_work_head) {
+		mutex_unlock(&mutex);
+		return NULL;
+	}
+
+	dwork = ((struct delayed_work **)(temp->key));
+	//navigate through list
+	while (&(*dwork)->work != key) {
+		//if it is last node
+		if (!temp->next) {
+			mutex_unlock(&mutex);
+			return NULL;
+		}
+			//store reference to current link
+			previous = temp;
+			//move to next link
+			temp = temp->next;
+			dwork = ((struct delayed_work **)(temp->key));
+	}
+
+	mutex_unlock(&mutex);
+	data = temp;
+	if (data) {
+		dwork_new = data->key;
+		if (flag)
+			kfree(data);
+	}
+	return dwork_new;
+}
diff --git a/drivers/media/platform/vxe-vxd/common/work_queue.h b/drivers/media/platform/vxe-vxd/common/work_queue.h
new file mode 100644
index 000000000000..28e0d752b2f6
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/common/work_queue.h
@@ -0,0 +1,60 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Work Queue Related Definitions
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef WORKQUEUE_H_
+#define WORKQUEUE_H_
+
+#include <linux/types.h>
+
+enum {
+	HWA_DECODER   = 0,
+	HWA_ENCODER    = 1,
+	HWA_FORCE32BITS = 0x7FFFFFFFU
+};
+
+/**
+ * init_work - This function provides the necessary initialization
+ * and saving given pointer(work_args) in linked list.
+ * @work_args: structure for the initialization
+ * @work_fn: work function pointer
+ *
+ * This function provides the necessary initialization
+ * and setting of the handler function (passed by the user).
+ */
+void init_work(void **work_args, void *work_fn, uint8_t hwa_id);
+
+/**
+ * init_delayed_work - This function provides the necessary initialization.
+ * and saving given pointer(work_args) in linked list.
+ * @work_args: structure for the initialization
+ * @work_fn: work function pointer
+ *
+ * This function provides the necessary initialization
+ * and setting of the handler function (passed by the user).
+ */
+void init_delayed_work(void **work_args, void *work_fn, uint8_t hwa_id);
+
+/**
+ * get_delayed_work_buff - This function return base address of given pointer
+ * @key: The given work struct pointer
+ * @flag: If TRUE, delete the node from the linked list.
+ *
+ * Return: Base address of the given input buffer.
+ */
+void *get_delayed_work_buff(void *key, signed char flag);
+
+/**
+ * get_work_buff - This function return base address of given pointer
+ * @key: The given work struct pointer
+ * @flag: If TRUE, delete the node from the linked list.
+ *
+ * Return: Base address of the given input buffer.
+ */
+void *get_work_buff(void *key, signed char flag);
+
+#endif /* WORKQUEUE_H_ */
diff --git a/drivers/media/platform/vxe-vxd/decoder/h264_idx.h b/drivers/media/platform/vxe-vxd/decoder/h264_idx.h
new file mode 100644
index 000000000000..c5ed80790f7b
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/h264_idx.h
@@ -0,0 +1,58 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * h264 idx table definitions
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef __H264_IDX_H__
+#define __H264_IDX_H__
+
+#include <linux/types.h>
+
+static unsigned short h264_vlc_index_data[38][3] = {
+	{ 2, 5, 0   },  /* NumCoeffTrailingOnes_Table9-5_nC_0-1.out */
+	{ 0, 3, 76  },  /* NumCoeffTrailingOnes_Table9-5_nC_2-3.out */
+	{ 0, 3, 160 },  /* NumCoeffTrailingOnes_Table9-5_nC_4-7.out */
+	{ 0, 2, 231 },  /* NumCoeffTrailingOnesFixedLen.out */
+	{ 2, 2, 244 },  /* NumCoeffTrailingOnesChromaDC_YUV420.out */
+	{ 2, 5, 261 },  /* NumCoeffTrailingOnesChromaDC_YUV422.out */
+	{ 2, 5, 301 },  /* TotalZeros_00.out */
+	{ 0, 2, 326 },  /* TotalZeros_01.out */
+	{ 0, 2, 345 },  /* TotalZeros_02.out */
+	{ 0, 2, 363 },  /* TotalZeros_03.out */
+	{ 0, 2, 379 },  /* TotalZeros_04.out */
+	{ 0, 2, 394 },  /* TotalZeros_05.out */
+	{ 0, 2, 406 },  /* TotalZeros_06.out */
+	{ 0, 1, 418 },  /* TotalZeros_07.out */
+	{ 0, 1, 429 },  /* TotalZeros_08.out */
+	{ 0, 1, 438 },  /* TotalZeros_09.out */
+	{ 2, 2, 446 },  /* TotalZeros_10.out */
+	{ 2, 2, 452 },  /* TotalZeros_11.out */
+	{ 2, 1, 456 },  /* TotalZeros_12.out */
+	{ 0, 0, 459 },  /* TotalZeros_13.out */
+	{ 0, 0, 461 },  /* TotalZeros_14.out */
+	{ 2, 2, 463 },  /* TotalZerosChromaDC_YUV420_00.out */
+	{ 2, 1, 467 },  /* TotalZerosChromaDC_YUV420_01.out */
+	{ 0, 0, 470 },  /* TotalZerosChromaDC_YUV420_02.out */
+	{ 0, 0, 472 },  /* Run_00.out */
+	{ 2, 1, 474 },  /* Run_01.out */
+	{ 0, 1, 477 },  /* Run_02.out */
+	{ 0, 1, 481 },  /* Run_03.out */
+	{ 1, 1, 487 },  /* Run_04.out */
+	{ 0, 2, 494 },  /* Run_05.out */
+	{ 0, 2, 502 },  /* Run_06.out */
+	{ 2, 4, 520 },  /* TotalZerosChromaDC_YUV422_00.out */
+	{ 2, 2, 526 },  /* TotalZerosChromaDC_YUV422_01.out */
+	{ 0, 1, 530 },  /* TotalZerosChromaDC_YUV422_02.out */
+	{ 1, 2, 534 },  /* TotalZerosChromaDC_YUV422_03.out */
+	{ 0, 0, 538 },  /* TotalZerosChromaDC_YUV422_04.out */
+	{ 0, 0, 540 },  /* TotalZerosChromaDC_YUV422_05.out */
+	{ 0, 0, 542 },  /* TotalZerosChromaDC_YUV422_06.out */
+};
+
+static const unsigned char h264_vlc_index_size = 38;
+
+#endif
+
diff --git a/drivers/media/platform/vxe-vxd/decoder/h264_vlc.h b/drivers/media/platform/vxe-vxd/decoder/h264_vlc.h
new file mode 100644
index 000000000000..1d28264c5ee5
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/h264_vlc.h
@@ -0,0 +1,602 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * h264 vlc table definitions
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef __H264_VLC_H__
+#define __H264_VLC_H__
+
+#include <linux/types.h>
+
+static unsigned short h264_vlc_table_data[] = {
+/* NumCoeffTrailingOnes_Table9-5_nC_0-1.out */
+	4, 0, 0,
+	4, 1, 5,
+	4, 2, 10,
+	2, 1, 4,
+	2, 1, 6,
+	0, 1, 8,
+	0, 2, 11,
+	4, 0, 15,
+	4, 1, 4,
+	4, 1, 9,
+	4, 0, 19,
+	4, 1, 14,
+	4, 1, 23,
+	4, 1, 27,
+	4, 1, 18,
+	4, 1, 13,
+	4, 1, 8,
+	2, 5, 8,
+	0, 1, 50,
+	0, 0, 53,
+	0, 0, 54,
+	4, 2, 31,
+	4, 2, 22,
+	4, 2, 17,
+	4, 2, 12,
+	0, 2, 7,
+	0, 2, 14,
+	0, 2, 21,
+	0, 2, 28,
+	0, 1, 35,
+	4, 5, 53,
+	3, 5, 0,
+	4, 2, 32,
+	4, 2, 38,
+	4, 2, 33,
+	4, 2, 28,
+	4, 2, 43,
+	4, 2, 34,
+	4, 2, 29,
+	4, 2, 24,
+	4, 2, 51,
+	4, 2, 46,
+	4, 2, 41,
+	4, 2, 40,
+	4, 2, 47,
+	4, 2, 42,
+	4, 2, 37,
+	4, 2, 36,
+	4, 2, 59,
+	4, 2, 54,
+	4, 2, 49,
+	4, 2, 48,
+	4, 2, 55,
+	4, 2, 50,
+	4, 2, 45,
+	4, 2, 44,
+	4, 2, 67,
+	4, 2, 62,
+	4, 2, 61,
+	4, 2, 56,
+	4, 2, 63,
+	4, 2, 58,
+	4, 2, 57,
+	4, 2, 52,
+	4, 1, 64,
+	4, 1, 66,
+	4, 1, 65,
+	4, 1, 60,
+	4, 1, 39,
+	4, 1, 30,
+	4, 1, 25,
+	4, 1, 20,
+	4, 0, 35,
+	4, 0, 26,
+	4, 0, 21,
+	4, 0, 16,
+/* NumCoeffTrailingOnes_Table9-5_nC_2-3.out */
+	0, 2, 16,
+	0, 1, 73,
+	0, 1, 76,
+	0, 0, 79,
+	4, 3, 19,
+	4, 3, 15,
+	4, 2, 10,
+	4, 2, 10,
+	4, 1, 5,
+	4, 1, 5,
+	4, 1, 5,
+	4, 1, 5,
+	4, 1, 0,
+	4, 1, 0,
+	4, 1, 0,
+	4, 1, 0,
+	2, 5, 8,
+	0, 1, 49,
+	0, 0, 52,
+	0, 0, 53,
+	4, 2, 35,
+	4, 2, 22,
+	4, 2, 21,
+	4, 2, 12,
+	0, 2, 7,
+	0, 2, 14,
+	0, 2, 21,
+	1, 1, 28,
+	0, 1, 34,
+	4, 5, 63,
+	3, 5, 0,
+	4, 2, 47,
+	4, 2, 38,
+	4, 2, 37,
+	4, 2, 32,
+	4, 2, 43,
+	4, 2, 34,
+	4, 2, 33,
+	4, 2, 28,
+	4, 2, 44,
+	4, 2, 46,
+	4, 2, 45,
+	4, 2, 40,
+	4, 2, 51,
+	4, 2, 42,
+	4, 2, 41,
+	4, 2, 36,
+	4, 2, 59,
+	4, 2, 54,
+	4, 2, 53,
+	4, 2, 52,
+	4, 2, 55,
+	4, 2, 50,
+	4, 2, 49,
+	4, 2, 48,
+	0, 1, 3,
+	4, 1, 58,
+	4, 1, 56,
+	4, 1, 61,
+	4, 1, 60,
+	4, 1, 62,
+	4, 1, 57,
+	4, 1, 67,
+	4, 1, 66,
+	4, 1, 65,
+	4, 1, 64,
+	4, 1, 39,
+	4, 1, 30,
+	4, 1, 29,
+	4, 1, 24,
+	4, 0, 20,
+	4, 0, 26,
+	4, 0, 25,
+	4, 0, 16,
+	4, 1, 31,
+	4, 1, 18,
+	4, 1, 17,
+	4, 1, 8,
+	4, 1, 27,
+	4, 1, 14,
+	4, 1, 13,
+	4, 1, 4,
+	4, 0, 23,
+	4, 0, 9,
+/* NumCoeffTrailingOnes_Table9-5_nC_4-7.out */
+	2, 1, 16,
+	0, 2, 50,
+	0, 1, 57,
+	0, 1, 60,
+	6, 0, 10,
+	6, 0, 8,
+	0, 0, 61,
+	0, 0, 62,
+	4, 3, 31,
+	4, 3, 27,
+	4, 3, 23,
+	4, 3, 19,
+	4, 3, 15,
+	4, 3, 10,
+	4, 3, 5,
+	4, 3, 0,
+	0, 2, 3,
+	0, 2, 10,
+	0, 3, 17,
+	4, 2, 51,
+	4, 2, 46,
+	4, 2, 41,
+	4, 2, 36,
+	4, 2, 47,
+	4, 2, 42,
+	4, 2, 37,
+	4, 2, 32,
+	4, 2, 48,
+	4, 2, 54,
+	4, 2, 49,
+	4, 2, 44,
+	4, 2, 55,
+	4, 2, 50,
+	4, 2, 45,
+	4, 2, 40,
+	3, 3, 0,
+	4, 3, 64,
+	4, 3, 67,
+	4, 3, 66,
+	4, 3, 65,
+	4, 3, 60,
+	4, 3, 63,
+	4, 3, 62,
+	4, 3, 61,
+	4, 3, 56,
+	4, 3, 59,
+	4, 3, 58,
+	4, 3, 57,
+	4, 3, 52,
+	4, 2, 53,
+	4, 2, 53,
+	4, 2, 28,
+	4, 2, 24,
+	4, 2, 38,
+	4, 2, 20,
+	4, 2, 43,
+	4, 2, 34,
+	4, 2, 33,
+	4, 2, 16,
+	4, 1, 12,
+	4, 1, 30,
+	4, 1, 29,
+	4, 1, 8,
+	4, 1, 39,
+	4, 1, 26,
+	4, 1, 25,
+	4, 1, 4,
+	4, 0, 13,
+	4, 0, 35,
+	4, 0, 14,
+	4, 0, 9,
+/* NumCoeffTrailingOnesFixedLen.out */
+	2, 1, 8,
+	5, 2, 6,
+	5, 2, 10,
+	5, 2, 14,
+	5, 2, 18,
+	5, 2, 22,
+	5, 2, 26,
+	5, 2, 30,
+	5, 1, 4,
+	0, 0, 2,
+	5, 0, 2,
+	3, 0, 0,
+	4, 0, 0,
+/* NumCoeffTrailingOnesChromaDC_YUV420.out */
+	4, 0, 5,
+	4, 1, 0,
+	4, 2, 10,
+	0, 2, 1,
+	1, 1, 8,
+	0, 0, 10,
+	4, 2, 16,
+	4, 2, 12,
+	4, 2, 8,
+	4, 2, 15,
+	4, 2, 9,
+	4, 2, 4,
+	4, 0, 19,
+	4, 1, 18,
+	4, 1, 17,
+	4, 0, 14,
+	4, 0, 13,
+/* NumCoeffTrailingOnesChromaDC_YUV422.out */
+	4, 0, 0,
+	4, 1, 5,
+	4, 2, 10,
+	0, 2, 4,
+	4, 4, 15,
+	4, 5, 19,
+	2, 3, 9,
+	4, 2, 27,
+	4, 2, 23,
+	4, 2, 18,
+	4, 2, 14,
+	4, 2, 13,
+	4, 2, 9,
+	4, 2, 8,
+	4, 2, 4,
+	0, 1, 5,
+	0, 1, 8,
+	0, 1, 11,
+	0, 1, 14,
+	1, 2, 17,
+	4, 1, 22,
+	4, 1, 17,
+	4, 1, 16,
+	4, 1, 12,
+	4, 1, 31,
+	4, 1, 26,
+	4, 1, 21,
+	4, 1, 20,
+	4, 1, 35,
+	4, 1, 30,
+	4, 1, 25,
+	4, 1, 24,
+	4, 1, 34,
+	4, 1, 33,
+	4, 1, 29,
+	4, 1, 28,
+	3, 2, 0,
+	3, 2, 0,
+	3, 2, 0,
+	4, 2, 32,
+/* TotalZeros_00.out */
+	4, 0, 0,
+	0, 0, 6,
+	0, 0, 7,
+	0, 0, 8,
+	0, 0, 9,
+	0, 0, 10,
+	0, 2, 11,
+	4, 0, 2,
+	4, 0, 1,
+	4, 0, 4,
+	4, 0, 3,
+	4, 0, 6,
+	4, 0, 5,
+	4, 0, 8,
+	4, 0, 7,
+	4, 0, 10,
+	4, 0, 9,
+	3, 2, 0,
+	4, 2, 15,
+	4, 2, 14,
+	4, 2, 13,
+	4, 1, 12,
+	4, 1, 12,
+	4, 1, 11,
+	4, 1, 11,
+/* TotalZeros_01.out */
+	1, 1, 8,
+	0, 0, 14,
+	0, 0, 15,
+	4, 2, 4,
+	4, 2, 3,
+	4, 2, 2,
+	4, 2, 1,
+	4, 2, 0,
+	0, 1, 3,
+	4, 1, 10,
+	4, 1, 9,
+	4, 1, 14,
+	4, 1, 13,
+	4, 1, 12,
+	4, 1, 11,
+	4, 0, 8,
+	4, 0, 7,
+	4, 0, 6,
+	4, 0, 5,
+/* TotalZeros_02.out */
+	0, 1, 8,
+	0, 0, 13,
+	0, 0, 14,
+	4, 2, 7,
+	4, 2, 6,
+	4, 2, 3,
+	4, 2, 2,
+	4, 2, 1,
+	0, 0, 4,
+	4, 1, 12,
+	4, 1, 10,
+	4, 1, 9,
+	4, 0, 13,
+	4, 0, 11,
+	4, 0, 8,
+	4, 0, 5,
+	4, 0, 4,
+	4, 0, 0,
+/* TotalZeros_03.out */
+	0, 1, 8,
+	0, 0, 11,
+	0, 0, 12,
+	4, 2, 8,
+	4, 2, 6,
+	4, 2, 5,
+	4, 2, 4,
+	4, 2, 1,
+	4, 1, 12,
+	4, 1, 11,
+	4, 1, 10,
+	4, 1, 0,
+	4, 0, 9,
+	4, 0, 7,
+	4, 0, 3,
+	4, 0, 2,
+/* TotalZeros_04.out */
+	2, 1, 8,
+	0, 0, 10,
+	0, 0, 11,
+	4, 2, 7,
+	4, 2, 6,
+	4, 2, 5,
+	4, 2, 4,
+	4, 2, 3,
+	4, 0, 10,
+	4, 1, 9,
+	4, 1, 11,
+	4, 0, 8,
+	4, 0, 2,
+	4, 0, 1,
+	4, 0, 0,
+/* TotalZeros_05.out */
+	2, 2, 8,
+	4, 2, 9,
+	4, 2, 7,
+	4, 2, 6,
+	4, 2, 5,
+	4, 2, 4,
+	4, 2, 3,
+	4, 2, 2,
+	4, 0, 8,
+	4, 1, 1,
+	4, 2, 0,
+	4, 2, 10,
+/* TotalZeros_06.out */
+	2, 2, 8,
+	4, 2, 8,
+	4, 2, 6,
+	4, 2, 4,
+	4, 2, 3,
+	4, 2, 2,
+	4, 1, 5,
+	4, 1, 5,
+	4, 0, 7,
+	4, 1, 1,
+	4, 2, 0,
+	4, 2, 9,
+/* TotalZeros_07.out */
+	2, 3, 4,
+	0, 0, 8,
+	4, 1, 5,
+	4, 1, 4,
+	4, 0, 7,
+	4, 1, 1,
+	4, 2, 2,
+	4, 3, 0,
+	4, 3, 8,
+	4, 0, 6,
+	4, 0, 3,
+/* TotalZeros_08.out */
+	2, 3, 4,
+	4, 1, 6,
+	4, 1, 4,
+	4, 1, 3,
+	4, 0, 5,
+	4, 1, 2,
+	4, 2, 7,
+	4, 3, 0,
+	4, 3, 1,
+/* TotalZeros_09.out */
+	2, 2, 4,
+	4, 1, 5,
+	4, 1, 4,
+	4, 1, 3,
+	4, 0, 2,
+	4, 1, 6,
+	4, 2, 0,
+	4, 2, 1,
+/* TotalZeros_10.out */
+	4, 0, 4,
+	0, 0, 3,
+	4, 2, 2,
+	5, 0, 0,
+	4, 0, 3,
+	4, 0, 5,
+/* TotalZeros_11.out */
+	4, 0, 3,
+	4, 1, 2,
+	4, 2, 4,
+	5, 0, 0,
+/* TotalZeros_12.out */
+	4, 0, 2,
+	4, 1, 3,
+	5, 0, 0,
+/* TotalZeros_13.out */
+	5, 0, 0,
+	4, 0, 2,
+/* TotalZeros_14.out */
+	4, 0, 0,
+	4, 0, 1,
+/* TotalZerosChromaDC_YUV420_00.out */
+	4, 0, 0,
+	4, 1, 1,
+	4, 2, 2,
+	4, 2, 3,
+/* TotalZerosChromaDC_YUV420_01.out */
+	4, 0, 0,
+	4, 1, 1,
+	4, 1, 2,
+/* TotalZerosChromaDC_YUV420_02.out */
+	4, 0, 1,
+	4, 0, 0,
+/* Run_00.out */
+	4, 0, 1,
+	4, 0, 0,
+/* Run_01.out */
+	4, 0, 0,
+	4, 1, 1,
+	4, 1, 2,
+/* Run_02.out */
+	4, 1, 3,
+	4, 1, 2,
+	4, 1, 1,
+	4, 1, 0,
+/* Run_03.out */
+	0, 0, 4,
+	4, 1, 2,
+	4, 1, 1,
+	4, 1, 0,
+	4, 0, 4,
+	4, 0, 3,
+/* Run_04.out */
+	0, 1, 3,
+	4, 1, 1,
+	4, 1, 0,
+	4, 1, 5,
+	4, 1, 4,
+	4, 1, 3,
+	4, 1, 2,
+/* Run_05.out */
+	4, 2, 1,
+	4, 2, 2,
+	4, 2, 4,
+	4, 2, 3,
+	4, 2, 6,
+	4, 2, 5,
+	4, 1, 0,
+	4, 1, 0,
+/* Run_06.out */
+	2, 5, 8,
+	4, 2, 6,
+	4, 2, 5,
+	4, 2, 4,
+	4, 2, 3,
+	4, 2, 2,
+	4, 2, 1,
+	4, 2, 0,
+	4, 0, 7,
+	4, 1, 8,
+	4, 2, 9,
+	4, 3, 10,
+	4, 4, 11,
+	4, 5, 12,
+	2, 1, 1,
+	4, 0, 13,
+	4, 1, 14,
+	3, 1, 0,
+/* TotalZerosChromaDC_YUV422_00.out */
+	4, 0, 0,
+	6, 0, 0,
+	6, 0, 1,
+	4, 3, 5,
+	4, 4, 6,
+	4, 4, 7,
+/* TotalZerosChromaDC_YUV422_01.out */
+	6, 1, 1,
+	4, 1, 1,
+	4, 2, 2,
+	4, 2, 0,
+/* TotalZerosChromaDC_YUV422_02.out */
+	5, 0, 0,
+	4, 1, 2,
+	4, 1, 3,
+	5, 0, 2,
+/* TotalZerosChromaDC_YUV422_03.out */
+	6, 0, 0,
+	4, 1, 3,
+	4, 2, 0,
+	4, 2, 4,
+/* TotalZerosChromaDC_YUV422_04.out */
+	5, 0, 0,
+	5, 0, 1,
+/* TotalZerosChromaDC_YUV422_05.out */
+	5, 0, 0,
+	4, 0, 2,
+/* TotalZerosChromaDC_YUV422_06.out */
+	4, 0, 0,
+	4, 0, 1
+};
+
+static const unsigned short h264_vlc_table_size = 544;
+
+#endif
+
diff --git a/drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.c b/drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.c
new file mode 100644
index 000000000000..eb2048dec440
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.c
@@ -0,0 +1,2888 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * hevc secure data unit parsing API.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include <linux/dma-mapping.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-mem2mem.h>
+
+#include "bspp_int.h"
+#include "hevc_secure_parser.h"
+#include "hevcfw_data.h"
+#include "pixel_api.h"
+#include "swsr.h"
+#include "vdec_defs.h"
+#include "vdecdd_utils.h"
+
+#if defined(DEBUG_DECODER_DRIVER)
+#define BSPP_HEVC_SYNTAX(fmt, ...)      pr_info("[hevc] " fmt, ## __VA_ARGS__)
+
+#else
+
+#define BSPP_HEVC_SYNTAX(fmt, ...)
+#endif
+
+static void HEVC_SWSR_U1(unsigned char *what, unsigned char *where, void *swsr_ctx)
+{
+	*where = swsr_read_bits(swsr_ctx, 1);
+#ifdef DEBUG_DECODER_DRIVER
+	pr_info("%s, u(1) : %u", what, *where);
+#endif
+}
+
+static void HEVC_SWSR_UN(unsigned char *what, unsigned int *where,
+			 unsigned char numbits, void *swsr_ctx)
+{
+	*where = swsr_read_bits(swsr_ctx, numbits);
+#ifdef DEBUG_DECODER_DRIVER
+	pr_info("%s, u(%u) : %u", what, numbits, *where);
+#endif
+}
+
+static void HEVC_SWSR_UE(unsigned char *what, unsigned int *where, void *swsr_ctx)
+{
+	*where = swsr_read_unsigned_expgoulomb(swsr_ctx);
+#ifdef DEBUG_DECODER_DRIVER
+	pr_info("%s, ue(v) : %u", what, *where);
+#endif
+}
+
+static void HEVC_SWSR_SE(unsigned char *what, int *where, void *swsr_ctx)
+{
+	*where = swsr_read_signed_expgoulomb(swsr_ctx);
+#ifdef DEBUG_DECODER_DRIVER
+	pr_info("%s, se(v) : %u", what, *where);
+#endif
+}
+
+static void HEVC_SWSR_FN(unsigned char *what, unsigned char *where,
+			 unsigned char numbits, unsigned char pattern,
+			 enum bspp_error_type *bspperror, void *swsr_ctx)
+{
+	*where = swsr_read_bits(swsr_ctx, numbits);
+#ifdef DEBUG_DECODER_DRIVER
+	pr_info("%s, f(%u) : %u", what, numbits, *where);
+#endif
+	if (*where != pattern) {
+		*bspperror |= BSPP_ERROR_INVALID_VALUE;
+		pr_warn("Invalid value of %s (f(%u), expected: %u, got: %u)",
+			what, numbits, pattern, *where);
+	}
+}
+
+static void HEVC_UCHECK(unsigned char *what, unsigned int val,
+			unsigned int expected,
+			enum bspp_error_type *bspperror)
+{
+	if (val != expected) {
+		*bspperror |= BSPP_ERROR_INVALID_VALUE;
+		pr_warn("Invalid value of %s (expected: %u, got: %u)",
+			what, expected, val);
+	}
+}
+
+static void HEVC_RANGEUCHECK(unsigned char *what, unsigned int val,
+			     unsigned int min, unsigned int max,
+	enum bspp_error_type *bspperror)
+{
+	if ((min > 0 && val < min) || val > max) {
+		*bspperror |= BSPP_ERROR_INVALID_VALUE;
+		pr_warn("Value of %s out of range (expected: [%u, %u], got: %u)",
+			what, min, max, val);
+	}
+}
+
+static void HEVC_RANGESCHECK(unsigned char *what, int val, int min, int max,
+			     enum bspp_error_type *bspperror)
+{
+	if (val < min || val > max) {
+		*bspperror |= BSPP_ERROR_INVALID_VALUE;
+		pr_warn("Value of %s out of range (expected: [%d, %d], got: %d)",
+			what, min, max, val);
+	}
+}
+
+#define HEVC_STATIC_ASSERT(expr) ((void)sizeof(unsigned char[1 - 2 * !(expr)]))
+
+#define HEVC_MIN(a, b, type) ({ \
+		type __a = a; \
+		type __b = b; \
+		(((__a) <= (__b)) ? (__a) : (__b)); })
+#define HEVC_MAX(a, b, type) ({ \
+		type __a = a; \
+		type __b = b; \
+		(((__a) >= (__b)) ? (__a) : (__b)); })
+#define HEVC_ALIGN(_val, _alignment, type) ({ \
+		type val = _val; \
+		type alignment = _alignment; \
+		(((val) + (alignment) - 1) & ~((alignment) - 1)); })
+
+static const enum pixel_fmt_idc pixelformat_idc[] = {
+	PIXEL_FORMAT_MONO,
+	PIXEL_FORMAT_420,
+	PIXEL_FORMAT_422,
+	PIXEL_FORMAT_444
+};
+
+static enum bspp_error_type bspp_hevc_parse_vps(void *sr_ctx, struct bspp_hevc_vps *vps);
+
+static void bspp_hevc_sublayhrdparams(void *sr_ctx,
+				      struct bspp_hevc_hrd_parameters *hrdparams,
+				      unsigned char sublayer_id);
+
+static void bspp_hevc_parsehrdparams(void *sr_ctx,
+				     struct bspp_hevc_hrd_parameters *hrdparams,
+				     unsigned char common_infpresent,
+				     unsigned char max_numsublayers_minus1);
+
+static enum bspp_error_type bspp_hevc_parsesps(void *sr_ctx,
+					       void *str_res,
+					       struct bspp_hevc_sps *sps);
+
+static enum bspp_error_type bspp_hevc_parsepps(void *sr_ctx, void *str_res,
+					       struct bspp_hevc_pps *pps);
+
+static int bspp_hevc_reset_ppsinfo(void *secure_ppsinfo);
+
+static void bspp_hevc_dotilecalculations(struct bspp_hevc_sps *sps,
+					 struct bspp_hevc_pps *pps);
+
+static enum bspp_error_type bspp_hevc_parse_slicesegmentheader
+		(void *sr_ctx, void *str_res,
+		 struct bspp_hevc_slice_segment_header *ssh,
+		 unsigned char nalunit_type,
+		 struct bspp_vps_info **vpsinfo,
+		 struct bspp_sequence_hdr_info **spsinfo,
+		 struct bspp_pps_info **ppsinfo);
+
+static enum bspp_error_type bspp_hevc_parse_profiletierlevel
+			(void *sr_ctx,
+			 struct bspp_hevc_profile_tierlevel *ptl,
+			 unsigned char vps_maxsublayers_minus1);
+
+static void bspp_hevc_getdefault_scalinglist(unsigned char size_id, unsigned char matrix_id,
+					     const unsigned char **default_scalinglist,
+					     unsigned int *size);
+
+static enum bspp_error_type bspp_hevc_parse_scalinglistdata
+				(void *sr_ctx,
+				 struct bspp_hevc_scalinglist_data *scaling_listdata);
+
+static void bspp_hevc_usedefault_scalinglists(struct bspp_hevc_scalinglist_data *scaling_listdata);
+
+static enum bspp_error_type bspp_hevc_parse_shortterm_refpicset
+		(void *sr_ctx,
+		 struct bspp_hevc_shortterm_refpicset *st_refpicset,
+		 unsigned char st_rps_idx,
+		 unsigned char in_slice_header);
+
+static void bspp_hevc_fillcommonseqhdr(struct bspp_hevc_sps *sps,
+				       struct vdec_comsequ_hdrinfo *common_seq);
+
+static void bspp_hevc_fillpicturehdr(struct vdec_comsequ_hdrinfo *common_seq,
+				     enum hevc_nalunittype nalunit_type,
+				     struct bspp_pict_hdr_info *picture_hdr,
+				     struct bspp_hevc_sps *sps,
+				     struct bspp_hevc_pps *pps,
+				     struct bspp_hevc_vps *vps);
+
+static void bspp_hevc_fill_fwsps(struct bspp_hevc_sps *sps,
+				 struct hevcfw_sequence_ps *fwsps);
+
+static void bspp_hevc_fill_fwst_rps(struct bspp_hevc_shortterm_refpicset *strps,
+				    struct hevcfw_short_term_ref_picset *fwstrps);
+
+static void bspp_hevc_fill_fwpps(struct bspp_hevc_pps *pps,
+				 struct hevcfw_picture_ps *fw_pps);
+
+static void bspp_hevc_fill_fw_scaling_lists(struct bspp_hevc_pps *pps,
+					    struct bspp_hevc_sps *sps,
+					    struct hevcfw_picture_ps *fw_pps);
+
+static unsigned int bspp_ceil_log2(unsigned int linear_val);
+
+static unsigned char bspp_hevc_picture_is_irap(enum hevc_nalunittype nalunit_type);
+
+static unsigned char bspp_hevc_picture_is_cra(enum hevc_nalunittype nalunit_type);
+
+static unsigned char bspp_hevc_picture_is_idr(enum hevc_nalunittype nalunit_type);
+
+static unsigned char bspp_hevc_picture_is_bla(enum hevc_nalunittype nalunit_type);
+
+static unsigned char bspp_hevc_picture_getnorasl_outputflag
+						(enum hevc_nalunittype nalunit_type,
+						 struct bspp_hevc_inter_pict_ctx *inter_pict_ctx);
+
+static unsigned char bspp_hevc_range_extensions_is_enabled
+					(struct bspp_hevc_profile_tierlevel *profile_tierlevel);
+
+static int bspp_hevc_unitparser(void *swsr_ctx, struct bspp_unit_data *unitdata)
+{
+	void *sr_ctx = swsr_ctx;
+	int result = 0;
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+	struct bspp_inter_pict_data *inter_pict_ctx =
+				unitdata->parse_state->inter_pict_ctx;
+	unsigned char forbidden_zero_bit = 0;
+	unsigned char nal_unit_type = 0;
+	unsigned char nuh_layer_id = 0;
+	unsigned char nuh_temporal_id_plus1 = 0;
+
+	HEVC_SWSR_FN("forbidden_zero_bit", &forbidden_zero_bit, 1, 0, &parse_err, sr_ctx);
+	HEVC_SWSR_UN("nal_unit_type", (unsigned int *)&nal_unit_type, 6, sr_ctx);
+	/* for current version of HEVC nuh_layer_id "shall be equal to 0" */
+	HEVC_SWSR_FN("nuh_layer_id", &nuh_layer_id, 6, 0, &parse_err, sr_ctx);
+	HEVC_SWSR_UN("nuh_temporal_id_plus1", (unsigned int *)&nuh_temporal_id_plus1, 3, sr_ctx);
+
+	switch (unitdata->unit_type) {
+	case BSPP_UNIT_VPS:
+	{
+		struct bspp_hevc_vps *vps =
+			(struct bspp_hevc_vps *)unitdata->out.vps_info->secure_vpsinfo;
+
+		unitdata->parse_error |= bspp_hevc_parse_vps(sr_ctx, vps);
+		unitdata->out.vps_info->vps_id =
+			vps->vps_video_parameter_set_id;
+	}
+	break;
+
+	case BSPP_UNIT_SEQUENCE:
+	{
+		struct bspp_ddbuf_array_info *tmp;
+		struct hevcfw_sequence_ps *fwsps;
+		struct vdec_comsequ_hdrinfo *common_seq;
+		struct bspp_hevc_sps *sps =
+			(struct bspp_hevc_sps *)unitdata->out.sequ_hdr_info->secure_sequence_info;
+
+		unitdata->parse_error |= bspp_hevc_parsesps(sr_ctx,
+				unitdata->str_res_handle,
+				sps);
+		unitdata->out.sequ_hdr_info->sequ_hdr_info.sequ_hdr_id =
+			sps->sps_seq_parameter_set_id;
+
+		tmp = &unitdata->out.sequ_hdr_info->fw_sequence;
+		/* handle firmware headers */
+		fwsps =
+		(struct hevcfw_sequence_ps *)((unsigned char *)tmp->ddbuf_info.cpu_virt_addr +
+			tmp->buf_offset);
+
+		bspp_hevc_fill_fwsps(sps, fwsps);
+
+		/* handle common sequence header */
+		common_seq =
+			&unitdata->out.sequ_hdr_info->sequ_hdr_info.com_sequ_hdr_info;
+
+		bspp_hevc_fillcommonseqhdr(sps, common_seq);
+	}
+	break;
+
+	case BSPP_UNIT_PPS:
+	{
+		struct bspp_ddbuf_array_info *tmp;
+		struct hevcfw_picture_ps *fw_pps;
+		struct bspp_hevc_pps *pps =
+			(struct bspp_hevc_pps *)unitdata->out.pps_info->secure_pps_info;
+
+		unitdata->parse_error |= bspp_hevc_parsepps(sr_ctx,
+				unitdata->str_res_handle,
+				pps);
+		unitdata->out.pps_info->pps_id = pps->pps_pic_parameter_set_id;
+
+		tmp = &unitdata->out.pps_info->fw_pps;
+		/* handle firmware headers */
+		fw_pps =
+		(struct hevcfw_picture_ps *)((unsigned char *)tmp->ddbuf_info.cpu_virt_addr +
+			tmp->buf_offset);
+		bspp_hevc_fill_fwpps(pps, fw_pps);
+	}
+	break;
+
+	case BSPP_UNIT_PICTURE:
+	{
+		struct bspp_hevc_slice_segment_header ssh;
+		struct bspp_vps_info *vps_info = NULL;
+		struct bspp_sequence_hdr_info *sequ_hdr_info = NULL;
+		struct bspp_hevc_sps *hevc_sps = NULL;
+		struct bspp_pps_info *ppsinfo = NULL;
+		enum bspp_error_type parse_error;
+		struct bspp_ddbuf_array_info *tmp;
+		struct hevcfw_picture_ps *fw_pps;
+		struct bspp_pict_data *pictdata;
+		struct bspp_hevc_pps *pps;
+
+		/*
+		 * EOS has to be attached to picture data, so it can be used
+		 * for NoRaslOutputFlag calculation in FW
+		 */
+		inter_pict_ctx->hevc_ctx.eos_detected = 0;
+		if (nal_unit_type == HEVC_NALTYPE_EOS) {
+			inter_pict_ctx->hevc_ctx.eos_detected = 1;
+			break;
+		}
+
+		parse_error = bspp_hevc_parse_slicesegmentheader(sr_ctx,
+								 unitdata->str_res_handle,
+								 &ssh,
+								 nal_unit_type,
+								 &vps_info,
+								 &sequ_hdr_info,
+								 &ppsinfo);
+		unitdata->parse_error |= parse_error;
+		unitdata->slice = 1;
+
+		if (parse_error != BSPP_ERROR_NONE &&
+		    parse_error != BSPP_ERROR_CORRECTION_VALIDVALUE) {
+			result = IMG_ERROR_CANCELLED;
+			break;
+		}
+
+		/* if we just started new picture. */
+		if (ssh.first_slice_segment_in_pic_flag) {
+			tmp = &ppsinfo->fw_pps;
+			/* handle firmware headers */
+			fw_pps =
+			(struct hevcfw_picture_ps *)((unsigned char *)tmp->ddbuf_info.cpu_virt_addr
+				+ tmp->buf_offset);
+
+			inter_pict_ctx->hevc_ctx.first_after_eos = 0;
+			if (inter_pict_ctx->hevc_ctx.eos_detected) {
+				inter_pict_ctx->hevc_ctx.first_after_eos = 1;
+				inter_pict_ctx->hevc_ctx.eos_detected = 0;
+			}
+
+			/* fill common picture header */
+			bspp_hevc_fillpicturehdr(&sequ_hdr_info->sequ_hdr_info.com_sequ_hdr_info,
+						 (enum hevc_nalunittype)nal_unit_type,
+						 unitdata->out.pict_hdr_info,
+						 (struct bspp_hevc_sps *)
+						 sequ_hdr_info->secure_sequence_info,
+						 (struct bspp_hevc_pps *)ppsinfo->secure_pps_info,
+						 (struct bspp_hevc_vps *)vps_info->secure_vpsinfo);
+
+			bspp_hevc_fill_fw_scaling_lists(ppsinfo->secure_pps_info,
+							sequ_hdr_info->secure_sequence_info,
+							fw_pps);
+
+			pictdata = &unitdata->out.pict_hdr_info->pict_aux_data;
+			/*
+			 * We have no container for the PPS that passes down
+			 * to the kernel, for this reason the hevc secure parser
+			 * needs to populate that info into the picture
+			 * header PictAuxData.
+			 */
+			pictdata->bufmap_id = ppsinfo->bufmap_id;
+			pictdata->buf_offset = ppsinfo->buf_offset;
+			pictdata->pic_data = fw_pps;
+			pictdata->id = fw_pps->pps_pic_parameter_set_id;
+			pictdata->size = sizeof(*fw_pps);
+
+			ppsinfo->ref_count++;
+
+			/* new Coded Video Sequence indication */
+			if (nal_unit_type == HEVC_NALTYPE_IDR_W_RADL ||
+			    nal_unit_type == HEVC_NALTYPE_IDR_N_LP ||
+			    nal_unit_type == HEVC_NALTYPE_BLA_N_LP ||
+			    nal_unit_type == HEVC_NALTYPE_BLA_W_RADL ||
+			    nal_unit_type == HEVC_NALTYPE_BLA_W_LP ||
+			    nal_unit_type == HEVC_NALTYPE_CRA) {
+				unitdata->new_closed_gop = 1;
+				inter_pict_ctx->hevc_ctx.seq_pic_count = 0;
+			}
+
+			/* Attach SEI data to the picture. */
+			if (!inter_pict_ctx->hevc_ctx.sei_info_attached_to_pic) {
+				/*
+				 *  If there is already a non-empty SEI list
+				 *  available
+				 */
+				if (inter_pict_ctx->hevc_ctx.sei_rawdata_list) {
+					/* attach it to the picture header. */
+					unitdata->out.pict_hdr_info->hevc_pict_hdr_info.raw_sei_datalist_firstfield =
+						(void *)inter_pict_ctx->hevc_ctx.sei_rawdata_list;
+					inter_pict_ctx->hevc_ctx.sei_info_attached_to_pic = 1;
+				} else {
+					/* Otherwise expose a handle a picture header field to
+					 * attach SEI list later.
+					 */
+					inter_pict_ctx->hevc_ctx.hndl_pichdr_sei_rawdata_list =
+		&unitdata->out.pict_hdr_info->hevc_pict_hdr_info.raw_sei_datalist_firstfield;
+				}
+			}
+
+			/* Attach raw VUI data to the picture header. */
+			hevc_sps = (struct bspp_hevc_sps *)sequ_hdr_info->secure_sequence_info;
+			if (hevc_sps->vui_raw_data) {
+				hevc_sps->vui_raw_data->ref_count++;
+				unitdata->out.pict_hdr_info->hevc_pict_hdr_info.raw_vui_data =
+					(void *)hevc_sps->vui_raw_data;
+			}
+
+			inter_pict_ctx->hevc_ctx.seq_pic_count++;
+
+			/* NoOutputOfPriorPicsFlag */
+			inter_pict_ctx->not_dpb_flush = 0;
+			if (unitdata->new_closed_gop &&
+			    bspp_hevc_picture_is_irap((enum hevc_nalunittype)nal_unit_type) &&
+			    bspp_hevc_picture_getnorasl_outputflag((enum hevc_nalunittype)
+								   nal_unit_type,
+								   &inter_pict_ctx->hevc_ctx)) {
+				if (bspp_hevc_picture_is_cra((enum hevc_nalunittype)nal_unit_type))
+					inter_pict_ctx->not_dpb_flush = 1;
+				else
+					inter_pict_ctx->not_dpb_flush =
+						ssh.no_output_of_prior_pics_flag;
+			}
+
+			unitdata->parse_state->next_pic_is_new = 0;
+		}
+
+		pps = (struct bspp_hevc_pps *)ppsinfo->secure_pps_info;
+		unitdata->pict_sequ_hdr_id = pps->pps_seq_parameter_set_id;
+	}
+	break;
+
+	case BSPP_UNIT_UNCLASSIFIED:
+	case BSPP_UNIT_NON_PICTURE:
+	case BSPP_UNIT_UNSUPPORTED:
+		break;
+
+	default:
+		VDEC_ASSERT("Unknown BSPP Unit Type" == NULL);
+		break;
+	}
+
+	return result;
+}
+
+static void bspp_hevc_initialiseparsing(struct bspp_parse_state *parse_state)
+{
+	/* Indicate that SEI info has not yet been attached to this picture. */
+	parse_state->inter_pict_ctx->hevc_ctx.sei_info_attached_to_pic = 0;
+}
+
+static void bspp_hevc_finaliseparsing(void *str_alloc, struct bspp_parse_state *parse_state)
+{
+	/*
+	 * If SEI info has not yet been attached to the picture and
+	 * there is anything to be attached.
+	 */
+	if (!parse_state->inter_pict_ctx->hevc_ctx.sei_info_attached_to_pic &&
+	    parse_state->inter_pict_ctx->hevc_ctx.sei_rawdata_list) {
+		/* attach the SEI list if there is a handle provided for that. */
+		if (parse_state->inter_pict_ctx->hevc_ctx.hndl_pichdr_sei_rawdata_list) {
+			/* Attach the raw SEI list to the picture. */
+			*parse_state->inter_pict_ctx->hevc_ctx.hndl_pichdr_sei_rawdata_list =
+				(void *)parse_state->inter_pict_ctx->hevc_ctx.sei_rawdata_list;
+			/* Reset the inter-picture data. */
+			parse_state->inter_pict_ctx->hevc_ctx.hndl_pichdr_sei_rawdata_list = NULL;
+		} else {
+			/* Nowhere to attach the raw SEI list, so just free it. */
+			bspp_freeraw_sei_datalist
+				(str_alloc, parse_state->inter_pict_ctx->hevc_ctx.sei_rawdata_list);
+		}
+	}
+
+	/* Indicate that SEI info has been attached to the picture. */
+	parse_state->inter_pict_ctx->hevc_ctx.sei_info_attached_to_pic = 1;
+	/* Reset the inter-picture SEI list. */
+	parse_state->inter_pict_ctx->hevc_ctx.sei_rawdata_list = NULL;
+}
+
+static enum bspp_error_type bspp_hevc_parse_vps(void *sr_ctx, struct bspp_hevc_vps *vps)
+{
+	unsigned int parse_err = BSPP_ERROR_NONE;
+	unsigned int i, j;
+
+	VDEC_ASSERT(vps);
+	VDEC_ASSERT(sr_ctx);
+
+	memset(vps, 0, sizeof(struct bspp_hevc_vps));
+
+	HEVC_SWSR_UN("vps_video_parameter_set_id",
+		     (unsigned int *)&vps->vps_video_parameter_set_id, 4, sr_ctx);
+	HEVC_SWSR_UN("vps_reserved_three_2bits",
+		     (unsigned int *)&vps->vps_reserved_three_2bits, 2, sr_ctx);
+	HEVC_SWSR_UN("vps_max_layers_minus1",
+		     (unsigned int *)&vps->vps_max_layers_minus1, 6, sr_ctx);
+	HEVC_SWSR_UN("vps_max_sub_layers_minus1",
+		     (unsigned int *)&vps->vps_max_sub_layers_minus1, 3, sr_ctx);
+	HEVC_RANGEUCHECK("vps_max_sub_layers_minus1", vps->vps_max_sub_layers_minus1, 0,
+			 HEVC_MAX_NUM_SUBLAYERS - 1, &parse_err);
+	HEVC_SWSR_U1("vps_temporal_id_nesting_flag",
+		     &vps->vps_temporal_id_nesting_flag, sr_ctx);
+	HEVC_SWSR_UN("vps_reserved_0xffff_16bits",
+		     (unsigned int *)&vps->vps_reserved_0xffff_16bits, 16, sr_ctx);
+
+	if (vps->vps_max_sub_layers_minus1 == 0)
+		HEVC_UCHECK("vps_temporal_id_nesting_flag",
+			    vps->vps_temporal_id_nesting_flag, 1, &parse_err);
+
+	parse_err |= bspp_hevc_parse_profiletierlevel(sr_ctx, &vps->profiletierlevel,
+						      vps->vps_max_sub_layers_minus1);
+
+	HEVC_SWSR_U1("vps_sub_layer_ordering_info_present_flag",
+		     &vps->vps_sub_layer_ordering_info_present_flag, sr_ctx);
+	for (i = vps->vps_sub_layer_ordering_info_present_flag ?
+		0 : vps->vps_max_sub_layers_minus1;
+		i <= vps->vps_max_sub_layers_minus1; ++i) {
+		HEVC_SWSR_UE("vps_max_dec_pic_buffering_minus1",
+			     (unsigned int *)&vps->vps_max_dec_pic_buffering_minus1[i], sr_ctx);
+		HEVC_SWSR_UE("vps_max_num_reorder_pics",
+			     (unsigned int *)&vps->vps_max_num_reorder_pics[i], sr_ctx);
+		HEVC_SWSR_UE("vps_max_latency_increase_plus1",
+			     (unsigned int *)&vps->vps_max_latency_increase_plus1[i], sr_ctx);
+	}
+
+	HEVC_SWSR_UN("vps_max_layer_id", (unsigned int *)&vps->vps_max_layer_id, 6, sr_ctx);
+	HEVC_SWSR_UE("vps_num_layer_sets_minus1",
+		     (unsigned int *)&vps->vps_num_layer_sets_minus1, sr_ctx);
+
+	for (i = 1; i <= vps->vps_num_layer_sets_minus1; ++i) {
+		for (j = 0; j <= vps->vps_max_layer_id; ++j) {
+			HEVC_SWSR_U1("layer_id_included_flag",
+				     &vps->layer_id_included_flag[i][j], sr_ctx);
+		}
+	}
+
+	HEVC_SWSR_U1("vps_timing_info_present_flag", &vps->vps_timing_info_present_flag, sr_ctx);
+	if (vps->vps_timing_info_present_flag) {
+		HEVC_SWSR_UN("vps_num_units_in_tick",
+			     (unsigned int *)&vps->vps_num_units_in_tick, 32, sr_ctx);
+		HEVC_SWSR_UN("vps_time_scale",
+			     (unsigned int *)&vps->vps_time_scale, 32, sr_ctx);
+		HEVC_SWSR_U1("vps_poc_proportional_to_timing_flag",
+			     &vps->vps_poc_proportional_to_timing_flag, sr_ctx);
+		if (vps->vps_poc_proportional_to_timing_flag)
+			HEVC_SWSR_UE("vps_num_ticks_poc_diff_one_minus1",
+				     (unsigned int *)&vps->vps_num_ticks_poc_diff_one_minus1,
+				     sr_ctx);
+
+		HEVC_SWSR_UE("vps_num_hrd_parameters",
+			     (unsigned int *)&vps->vps_num_hrd_parameters, sr_ctx);
+
+		/* consume hrd_parameters */
+		for (i = 0; i < vps->vps_num_hrd_parameters; i++) {
+			unsigned short hrd_layer_set_idx;
+			unsigned char cprms_present_flag = 1;
+			struct bspp_hevc_hrd_parameters hrdparams;
+
+			HEVC_SWSR_UE("hrd_layer_set_idx",
+				     (unsigned int *)&hrd_layer_set_idx, sr_ctx);
+			if (i > 0)
+				HEVC_SWSR_U1("cprms_present_flag", &cprms_present_flag, sr_ctx);
+
+			bspp_hevc_parsehrdparams(sr_ctx, &hrdparams,
+						 cprms_present_flag,
+						 vps->vps_max_sub_layers_minus1);
+		}
+	}
+	HEVC_SWSR_U1("vps_extension_flag", &vps->vps_extension_flag, sr_ctx);
+
+	return (enum bspp_error_type)parse_err;
+}
+
+static void bspp_hevc_sublayhrdparams(void *sr_ctx,
+				      struct bspp_hevc_hrd_parameters *hrdparams,
+				      unsigned char sublayer_id)
+{
+	unsigned char i;
+	unsigned char cpb_cnt = hrdparams->cpb_cnt_minus1[sublayer_id];
+	struct bspp_hevc_sublayer_hrd_parameters *sublay_hrdparams =
+		&hrdparams->sublayhrdparams[sublayer_id];
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(hrdparams);
+	VDEC_ASSERT(cpb_cnt < HEVC_MAX_CPB_COUNT);
+	VDEC_ASSERT(sublayer_id < HEVC_MAX_NUM_SUBLAYERS);
+
+	for (i = 0; i <= cpb_cnt; i++) {
+		HEVC_SWSR_UE("bit_rate_value_minus1",
+			     (unsigned int *)&sublay_hrdparams->bit_rate_value_minus1[i], sr_ctx);
+		HEVC_SWSR_UE("cpb_size_value_minus1",
+			     (unsigned int *)&sublay_hrdparams->cpb_size_value_minus1[i], sr_ctx);
+		if (hrdparams->sub_pic_hrd_params_present_flag) {
+			HEVC_SWSR_UE("cpb_size_du_value_minus1",
+				     (unsigned int *)
+				     &sublay_hrdparams->cpb_size_du_value_minus1[i],
+				     sr_ctx);
+			HEVC_SWSR_UE("bit_rate_du_value_minus1",
+				     (unsigned int *)
+				     &sublay_hrdparams->bit_rate_du_value_minus1[i],
+				     sr_ctx);
+		}
+		HEVC_SWSR_U1("cbr_flag", &sublay_hrdparams->cbr_flag[i], sr_ctx);
+	}
+}
+
+static void bspp_hevc_parsehrdparams(void *sr_ctx,
+				     struct bspp_hevc_hrd_parameters *hrdparams,
+				     unsigned char common_infpresent,
+				     unsigned char max_numsublayers_minus1)
+{
+	unsigned char i;
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(hrdparams);
+	VDEC_ASSERT(max_numsublayers_minus1 < HEVC_MAX_NUM_SUBLAYERS);
+
+	memset(hrdparams, 0, sizeof(struct bspp_hevc_hrd_parameters));
+
+	if (common_infpresent) {
+		HEVC_SWSR_U1("nal_hrd_parameters_present_flag",
+			     &hrdparams->nal_hrd_parameters_present_flag, sr_ctx);
+		HEVC_SWSR_U1("vcl_hrd_parameters_present_flag",
+			     &hrdparams->vcl_hrd_parameters_present_flag, sr_ctx);
+		if (hrdparams->nal_hrd_parameters_present_flag ||
+		    hrdparams->vcl_hrd_parameters_present_flag) {
+			HEVC_SWSR_U1("sub_pic_hrd_params_present_flag",
+				     &hrdparams->sub_pic_hrd_params_present_flag,
+				     sr_ctx);
+			if (hrdparams->sub_pic_hrd_params_present_flag) {
+				HEVC_SWSR_UN("tick_divisor_minus2",
+					     (unsigned int *)&hrdparams->tick_divisor_minus2,
+					     8, sr_ctx);
+				HEVC_SWSR_UN
+				("du_cpb_removal_delay_increment_length_minus1",
+				 (unsigned int *)
+				 &hrdparams->du_cpb_removal_delay_increment_length_minus1,
+				 5, sr_ctx);
+				HEVC_SWSR_U1("sub_pic_cpb_params_in_pic_timing_sei_flag",
+					     &hrdparams->sub_pic_cpb_params_in_pic_timing_sei_flag,
+					     sr_ctx);
+				HEVC_SWSR_UN("dpb_output_delay_du_length_minus1",
+					     (unsigned int *)
+					     &hrdparams->dpb_output_delay_du_length_minus1,
+					     5, sr_ctx);
+			}
+			HEVC_SWSR_UN("bit_rate_scale",
+				     (unsigned int *)&hrdparams->bit_rate_scale, 4, sr_ctx);
+			HEVC_SWSR_UN("cpb_size_scale",
+				     (unsigned int *)&hrdparams->cpb_size_scale, 4, sr_ctx);
+			if (hrdparams->sub_pic_hrd_params_present_flag)
+				HEVC_SWSR_UN("cpb_size_du_scale",
+					     (unsigned int *)&hrdparams->cpb_size_du_scale,
+					     4, sr_ctx);
+
+			HEVC_SWSR_UN("initial_cpb_removal_delay_length_minus1",
+				     (unsigned int *)
+				     &hrdparams->initial_cpb_removal_delay_length_minus1,
+				     5, sr_ctx);
+			HEVC_SWSR_UN("au_cpb_removal_delay_length_minus1",
+				     (unsigned int *)&hrdparams->au_cpb_removal_delay_length_minus1,
+				     5, sr_ctx);
+			HEVC_SWSR_UN("dpb_output_delay_length_minus1",
+				     (unsigned int *)&hrdparams->dpb_output_delay_length_minus1,
+				     5, sr_ctx);
+		}
+	}
+	for (i = 0; i <= max_numsublayers_minus1; i++) {
+		HEVC_SWSR_U1("fixed_pic_rate_general_flag",
+			     &hrdparams->fixed_pic_rate_general_flag[i], sr_ctx);
+		hrdparams->fixed_pic_rate_within_cvs_flag[i] =
+			hrdparams->fixed_pic_rate_general_flag[i];
+		if (!hrdparams->fixed_pic_rate_general_flag[i])
+			HEVC_SWSR_U1("fixed_pic_rate_within_cvs_flag",
+				     &hrdparams->fixed_pic_rate_within_cvs_flag[i],
+				     sr_ctx);
+
+		if (hrdparams->fixed_pic_rate_within_cvs_flag[i])
+			HEVC_SWSR_UE("elemental_duration_in_tc_minus1",
+				     (unsigned int *)&hrdparams->elemental_duration_in_tc_minus1[i],
+				     sr_ctx);
+		else
+			HEVC_SWSR_U1("low_delay_hrd_flag",
+				     &hrdparams->low_delay_hrd_flag[i], sr_ctx);
+
+		if (!hrdparams->low_delay_hrd_flag[i])
+			HEVC_SWSR_UE("cpb_cnt_minus1",
+				     (unsigned int *)&hrdparams->cpb_cnt_minus1[i], sr_ctx);
+
+		if (hrdparams->nal_hrd_parameters_present_flag)
+			bspp_hevc_sublayhrdparams(sr_ctx, hrdparams, i);
+
+		if (hrdparams->vcl_hrd_parameters_present_flag)
+			bspp_hevc_sublayhrdparams(sr_ctx, hrdparams, i);
+	}
+}
+
+static enum bspp_error_type bspp_hevc_parsevui_parameters
+			(void *sr_ctx,
+			 struct bspp_hevc_vui_params *vui_params,
+			 unsigned char sps_max_sub_layers_minus1)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(vui_params);
+
+	memset(vui_params, 0, sizeof(struct bspp_hevc_vui_params));
+
+	HEVC_SWSR_U1("aspect_ratio_info_present_flag",
+		     &vui_params->aspect_ratio_info_present_flag, sr_ctx);
+	if (vui_params->aspect_ratio_info_present_flag) {
+		HEVC_SWSR_UN("aspect_ratio_idc",
+			     (unsigned int *)&vui_params->aspect_ratio_idc, 8, sr_ctx);
+		if (vui_params->aspect_ratio_idc == HEVC_EXTENDED_SAR) {
+			HEVC_SWSR_UN("sar_width",
+				     (unsigned int *)&vui_params->sar_width, 16, sr_ctx);
+			HEVC_SWSR_UN("sar_height",
+				     (unsigned int *)&vui_params->sar_height, 16, sr_ctx);
+		}
+	}
+	HEVC_SWSR_U1("overscan_info_present_flag",
+		     &vui_params->overscan_info_present_flag, sr_ctx);
+
+	if (vui_params->overscan_info_present_flag)
+		HEVC_SWSR_U1("overscan_appropriate_flag",
+			     &vui_params->overscan_appropriate_flag, sr_ctx);
+
+	HEVC_SWSR_U1("video_signal_type_present_flag",
+		     &vui_params->video_signal_type_present_flag, sr_ctx);
+
+	if (vui_params->video_signal_type_present_flag) {
+		HEVC_SWSR_UN("video_format",
+			     (unsigned int *)&vui_params->video_format, 3, sr_ctx);
+		HEVC_SWSR_U1("video_full_range_flag",
+			     &vui_params->video_full_range_flag, sr_ctx);
+		HEVC_SWSR_U1("colour_description_present_flag",
+			     &vui_params->colour_description_present_flag,
+			     sr_ctx);
+		if (vui_params->colour_description_present_flag) {
+			HEVC_SWSR_UN("colour_primaries",
+				     (unsigned int *)&vui_params->colour_primaries, 8, sr_ctx);
+			HEVC_SWSR_UN("transfer_characteristics",
+				     (unsigned int *)&vui_params->transfer_characteristics,
+				     8, sr_ctx);
+			HEVC_SWSR_UN("matrix_coeffs",
+				     (unsigned int *)&vui_params->matrix_coeffs, 8, sr_ctx);
+		}
+	}
+
+	HEVC_SWSR_U1("chroma_loc_info_present_flag",
+		     &vui_params->chroma_loc_info_present_flag, sr_ctx);
+	if (vui_params->chroma_loc_info_present_flag) {
+		HEVC_SWSR_UE("chroma_sample_loc_type_top_field",
+			     (unsigned int *)&vui_params->chroma_sample_loc_type_top_field,
+			     sr_ctx);
+		HEVC_RANGEUCHECK("chroma_sample_loc_type_top_field",
+				 vui_params->chroma_sample_loc_type_top_field,
+				 0, 5, &parse_err);
+		HEVC_SWSR_UE("chroma_sample_loc_type_bottom_field",
+			     (unsigned int *)&vui_params->chroma_sample_loc_type_bottom_field,
+			     sr_ctx);
+		HEVC_RANGEUCHECK("chroma_sample_loc_type_bottom_field",
+				 vui_params->chroma_sample_loc_type_bottom_field,
+				 0, 5, &parse_err);
+	}
+	HEVC_SWSR_U1("neutral_chroma_indication_flag",
+		     &vui_params->neutral_chroma_indication_flag, sr_ctx);
+	HEVC_SWSR_U1("field_seq_flag",
+		     &vui_params->field_seq_flag, sr_ctx);
+	HEVC_SWSR_U1("frame_field_info_present_flag",
+		     &vui_params->frame_field_info_present_flag, sr_ctx);
+	HEVC_SWSR_U1("default_display_window_flag",
+		     &vui_params->default_display_window_flag, sr_ctx);
+	if (vui_params->default_display_window_flag) {
+		HEVC_SWSR_UE("def_disp_win_left_offset",
+			     (unsigned int *)&vui_params->def_disp_win_left_offset, sr_ctx);
+		HEVC_SWSR_UE("def_disp_win_right_offset",
+			     (unsigned int *)&vui_params->def_disp_win_right_offset, sr_ctx);
+		HEVC_SWSR_UE("def_disp_win_top_offset",
+			     (unsigned int *)&vui_params->def_disp_win_top_offset, sr_ctx);
+		HEVC_SWSR_UE("def_disp_win_bottom_offset",
+			     (unsigned int *)&vui_params->def_disp_win_bottom_offset, sr_ctx);
+	}
+	HEVC_SWSR_U1("vui_timing_info_present_flag",
+		     &vui_params->vui_timing_info_present_flag, sr_ctx);
+	if (vui_params->vui_timing_info_present_flag) {
+		HEVC_SWSR_UN("vui_num_units_in_tick",
+			     (unsigned int *)&vui_params->vui_num_units_in_tick, 32, sr_ctx);
+		HEVC_SWSR_UN("vui_time_scale",
+			     (unsigned int *)&vui_params->vui_time_scale, 32, sr_ctx);
+		HEVC_SWSR_U1("vui_poc_proportional_to_timing_flag",
+			     &vui_params->vui_poc_proportional_to_timing_flag,
+			     sr_ctx);
+		if (vui_params->vui_poc_proportional_to_timing_flag)
+			HEVC_SWSR_UE("vui_num_ticks_poc_diff_one_minus1",
+				     (unsigned int *)&vui_params->vui_num_ticks_poc_diff_one_minus1,
+				     sr_ctx);
+
+		HEVC_SWSR_U1("vui_hrd_parameters_present_flag",
+			     &vui_params->vui_hrd_parameters_present_flag,
+			     sr_ctx);
+		if (vui_params->vui_hrd_parameters_present_flag)
+			bspp_hevc_parsehrdparams(sr_ctx, &vui_params->vui_hrd_params,
+						 1, sps_max_sub_layers_minus1);
+	}
+	HEVC_SWSR_U1("bitstream_restriction_flag",
+		     &vui_params->bitstream_restriction_flag, sr_ctx);
+
+	if (vui_params->bitstream_restriction_flag) {
+		HEVC_SWSR_U1("tiles_fixed_structure_flag",
+			     &vui_params->tiles_fixed_structure_flag, sr_ctx);
+		HEVC_SWSR_U1("motion_vectors_over_pic_boundaries_flag",
+			     &vui_params->motion_vectors_over_pic_boundaries_flag,
+			     sr_ctx);
+		HEVC_SWSR_U1("restricted_ref_pic_lists_flag",
+			     &vui_params->restricted_ref_pic_lists_flag, sr_ctx);
+
+		HEVC_SWSR_UE("min_spatial_segmentation_idc",
+			     (unsigned int *)&vui_params->min_spatial_segmentation_idc, sr_ctx);
+		HEVC_RANGEUCHECK("min_spatial_segmentation_idc",
+				 vui_params->min_spatial_segmentation_idc,
+				 0, 4095, &parse_err);
+
+		HEVC_SWSR_UE("max_bytes_per_pic_denom",
+			     (unsigned int *)&vui_params->max_bytes_per_pic_denom, sr_ctx);
+		HEVC_RANGEUCHECK("max_bytes_per_pic_denom", vui_params->max_bytes_per_pic_denom,
+				 0, 16, &parse_err);
+
+		HEVC_SWSR_UE("max_bits_per_min_cu_denom",
+			     (unsigned int *)&vui_params->max_bits_per_min_cu_denom, sr_ctx);
+		HEVC_RANGEUCHECK("max_bits_per_min_cu_denom", vui_params->max_bits_per_min_cu_denom,
+				 0, 16, &parse_err);
+
+		HEVC_SWSR_UE("log2_max_mv_length_horizontal",
+			     (unsigned int *)&vui_params->log2_max_mv_length_horizontal, sr_ctx);
+		HEVC_RANGEUCHECK("log2_max_mv_length_horizontal",
+				 vui_params->log2_max_mv_length_horizontal,
+				 0, 16, &parse_err);
+
+		HEVC_SWSR_UE("log2_max_mv_length_vertical",
+			     (unsigned int *)&vui_params->log2_max_mv_length_vertical, sr_ctx);
+		HEVC_RANGEUCHECK("log2_max_mv_length_vertical",
+				 vui_params->log2_max_mv_length_vertical,
+				 0, 15, &parse_err);
+	}
+
+	return parse_err;
+}
+
+static enum bspp_error_type bspp_hevc_parse_spsrange_extensions
+					(void *sr_ctx,
+					 struct bspp_hevc_sps_range_exts *range_exts)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(range_exts);
+
+	memset(range_exts, 0, sizeof(struct bspp_hevc_sps_range_exts));
+
+	HEVC_SWSR_U1("transform_skip_rotation_enabled_flag",
+		     &range_exts->transform_skip_rotation_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("transform_skip_context_enabled_flag",
+		     &range_exts->transform_skip_context_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("implicit_rdpcm_enabled_flag",
+		     &range_exts->implicit_rdpcm_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("explicit_rdpcm_enabled_flag",
+		     &range_exts->explicit_rdpcm_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("extended_precision_processing_flag",
+		     &range_exts->extended_precision_processing_flag, sr_ctx);
+	HEVC_UCHECK("extended_precision_processing_flag",
+		    range_exts->extended_precision_processing_flag,
+		    0, &parse_err);
+	HEVC_SWSR_U1("intra_smoothing_disabled_flag",
+		     &range_exts->intra_smoothing_disabled_flag, sr_ctx);
+	HEVC_SWSR_U1("high_precision_offsets_enabled_flag",
+		     &range_exts->high_precision_offsets_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("persistent_rice_adaptation_enabled_flag",
+		     &range_exts->persistent_rice_adaptation_enabled_flag,
+		     sr_ctx);
+	HEVC_SWSR_U1("cabac_bypass_alignment_enabled_flag",
+		     &range_exts->cabac_bypass_alignment_enabled_flag, sr_ctx);
+
+	return parse_err;
+}
+
+static unsigned char
+bspp_hevc_checksps_range_extensions(struct bspp_hevc_sps_range_exts *range_exts)
+{
+	VDEC_ASSERT(range_exts);
+
+	if (range_exts->transform_skip_rotation_enabled_flag ||
+	    range_exts->transform_skip_context_enabled_flag ||
+	    range_exts->implicit_rdpcm_enabled_flag ||
+	    range_exts->explicit_rdpcm_enabled_flag ||
+	    range_exts->extended_precision_processing_flag ||
+	    range_exts->intra_smoothing_disabled_flag ||
+	    range_exts->persistent_rice_adaptation_enabled_flag ||
+	    range_exts->cabac_bypass_alignment_enabled_flag)
+		return 1;
+	/*
+	 *  Note: high_precision_offsets_enabled_flag is supported even
+	 * if hw capabilities (bHevcRangeExt is not set)
+	 */
+	return 0;
+}
+
+static enum bspp_error_type bspp_hevc_parsesps(void *sr_ctx,
+					       void *str_res,
+					       struct bspp_hevc_sps *sps)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+	unsigned char i;
+	unsigned int min_cblog2_size_y;
+
+	if (!sr_ctx || !sps) {
+		VDEC_ASSERT(0);
+		return BSPP_ERROR_INVALID_VALUE;
+	}
+
+	memset(sps, 0, sizeof(struct bspp_hevc_sps));
+
+	HEVC_SWSR_UN("sps_video_parameter_set_id",
+		     (unsigned int *)&sps->sps_video_parameter_set_id, 4, sr_ctx);
+	HEVC_SWSR_UN("sps_max_sub_layers_minus1",
+		     (unsigned int *)&sps->sps_max_sub_layers_minus1, 3, sr_ctx);
+	HEVC_RANGEUCHECK("sps_max_sub_layers_minus1", sps->sps_max_sub_layers_minus1, 0,
+			 HEVC_MAX_NUM_SUBLAYERS - 1, &parse_err);
+	HEVC_SWSR_U1("sps_temporal_id_nesting_flag",
+		     &sps->sps_temporal_id_nesting_flag, sr_ctx);
+
+	if (sps->sps_max_sub_layers_minus1 == 0)
+		HEVC_UCHECK("sps_temporal_id_nesting_flag",
+			    sps->sps_temporal_id_nesting_flag, 1, &parse_err);
+
+	parse_err |= bspp_hevc_parse_profiletierlevel
+				(sr_ctx, &sps->profile_tier_level,
+				 sps->sps_max_sub_layers_minus1);
+
+	HEVC_SWSR_UE("sps_seq_parameter_set_id",
+		     (unsigned int *)&sps->sps_seq_parameter_set_id, sr_ctx);
+	HEVC_RANGEUCHECK("sps_seq_parameter_set_id", sps->sps_seq_parameter_set_id, 0,
+			 HEVC_MAX_SPS_COUNT - 1, &parse_err);
+
+	HEVC_SWSR_UE("chroma_format_idc", (unsigned int *)&sps->chroma_format_idc, sr_ctx);
+	HEVC_RANGEUCHECK("chroma_format_idc", sps->chroma_format_idc, 0, 3, &parse_err);
+
+	if (sps->chroma_format_idc == 3)
+		HEVC_SWSR_U1("separate_colour_plane_flag",
+			     &sps->separate_colour_plane_flag, sr_ctx);
+
+	HEVC_SWSR_UE("pic_width_in_luma_samples",
+		     (unsigned int *)&sps->pic_width_in_luma_samples, sr_ctx);
+	HEVC_SWSR_UE("pic_height_in_luma_samples",
+		     (unsigned int *)&sps->pic_height_in_luma_samples, sr_ctx);
+
+	HEVC_SWSR_U1("conformance_window_flag", &sps->conformance_window_flag, sr_ctx);
+
+	if (sps->pic_width_in_luma_samples == 0 ||
+	    sps->pic_height_in_luma_samples == 0) {
+		pr_warn("Invalid video dimensions (%u, %u)",
+			sps->pic_width_in_luma_samples,
+			sps->pic_height_in_luma_samples);
+		parse_err |= BSPP_ERROR_UNRECOVERABLE;
+	}
+
+	if (sps->conformance_window_flag) {
+		HEVC_SWSR_UE("conf_win_left_offset",
+			     (unsigned int *)&sps->conf_win_left_offset, sr_ctx);
+		HEVC_SWSR_UE("conf_win_right_offset",
+			     (unsigned int *)&sps->conf_win_right_offset, sr_ctx);
+		HEVC_SWSR_UE("conf_win_top_offset",
+			     (unsigned int *)&sps->conf_win_top_offset, sr_ctx);
+		HEVC_SWSR_UE("conf_win_bottom_offset",
+			     (unsigned int *)&sps->conf_win_bottom_offset, sr_ctx);
+	}
+
+	HEVC_SWSR_UE("bit_depth_luma_minus8",
+		     (unsigned int *)&sps->bit_depth_luma_minus8, sr_ctx);
+	HEVC_RANGEUCHECK("bit_depth_luma_minus8",
+			 sps->bit_depth_luma_minus8, 0, 6, &parse_err);
+	HEVC_SWSR_UE("bit_depth_chroma_minus8",
+		     (unsigned int *)&sps->bit_depth_chroma_minus8, sr_ctx);
+	HEVC_RANGEUCHECK("bit_depth_chroma_minus8", sps->bit_depth_chroma_minus8,
+			 0, 6, &parse_err);
+
+	HEVC_SWSR_UE("log2_max_pic_order_cnt_lsb_minus4",
+		     (unsigned int *)&sps->log2_max_pic_order_cnt_lsb_minus4, sr_ctx);
+	HEVC_RANGEUCHECK("log2_max_pic_order_cnt_lsb_minus4",
+			 sps->log2_max_pic_order_cnt_lsb_minus4,
+			 0, 12, &parse_err);
+
+	HEVC_SWSR_U1("sps_sub_layer_ordering_info_present_flag",
+		     &sps->sps_sub_layer_ordering_info_present_flag, sr_ctx);
+	for (i = (sps->sps_sub_layer_ordering_info_present_flag ?
+		0 : sps->sps_max_sub_layers_minus1);
+		i <= sps->sps_max_sub_layers_minus1; ++i) {
+		HEVC_SWSR_UE("sps_max_dec_pic_buffering_minus1",
+			     (unsigned int *)&sps->sps_max_dec_pic_buffering_minus1[i], sr_ctx);
+		HEVC_SWSR_UE("sps_max_num_reorder_pics",
+			     (unsigned int *)&sps->sps_max_num_reorder_pics[i], sr_ctx);
+		HEVC_SWSR_UE("sps_max_latency_increase_plus1",
+			     (unsigned int *)&sps->sps_max_latency_increase_plus1[i], sr_ctx);
+	}
+
+	HEVC_SWSR_UE("log2_min_luma_coding_block_size_minus3",
+		     (unsigned int *)&sps->log2_min_luma_coding_block_size_minus3, sr_ctx);
+	HEVC_SWSR_UE("log2_diff_max_min_luma_coding_block_size",
+		     (unsigned int *)&sps->log2_diff_max_min_luma_coding_block_size, sr_ctx);
+	HEVC_SWSR_UE("log2_min_transform_block_size_minus2",
+		     (unsigned int *)&sps->log2_min_transform_block_size_minus2, sr_ctx);
+	HEVC_SWSR_UE("log2_diff_max_min_transform_block_size",
+		     (unsigned int *)&sps->log2_diff_max_min_transform_block_size, sr_ctx);
+	HEVC_SWSR_UE("max_transform_hierarchy_depth_inter",
+		     (unsigned int *)&sps->max_transform_hierarchy_depth_inter, sr_ctx);
+	HEVC_SWSR_UE("max_transform_hierarchy_depth_intra",
+		     (unsigned int *)&sps->max_transform_hierarchy_depth_intra, sr_ctx);
+
+	HEVC_SWSR_U1("scaling_list_enabled_flag", &sps->scaling_list_enabled_flag, sr_ctx);
+
+	if (sps->scaling_list_enabled_flag) {
+		HEVC_SWSR_U1("sps_scaling_list_data_present_flag",
+			     &sps->sps_scaling_list_data_present_flag, sr_ctx);
+		if (sps->sps_scaling_list_data_present_flag)
+			parse_err |= bspp_hevc_parse_scalinglistdata(sr_ctx,
+								     &sps->scalinglist_data);
+		else
+			bspp_hevc_usedefault_scalinglists(&sps->scalinglist_data);
+	}
+
+	HEVC_SWSR_U1("amp_enabled_flag", &sps->amp_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("sample_adaptive_offset_enabled_flag",
+		     &sps->sample_adaptive_offset_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("pcm_enabled_flag", &sps->pcm_enabled_flag, sr_ctx);
+
+	if (sps->pcm_enabled_flag) {
+		HEVC_SWSR_UN("pcm_sample_bit_depth_luma_minus1",
+			     (unsigned int *)&sps->pcm_sample_bit_depth_luma_minus1,
+			     4, sr_ctx);
+		HEVC_SWSR_UN("pcm_sample_bit_depth_chroma_minus1",
+			     (unsigned int *)&sps->pcm_sample_bit_depth_chroma_minus1,
+			     4, sr_ctx);
+		HEVC_SWSR_UE("log2_min_pcm_luma_coding_block_size_minus3",
+			     (unsigned int *)&sps->log2_min_pcm_luma_coding_block_size_minus3,
+			     sr_ctx);
+		HEVC_SWSR_UE("log2_diff_max_min_pcm_luma_coding_block_size",
+			     (unsigned int *)&sps->log2_diff_max_min_pcm_luma_coding_block_size,
+			     sr_ctx);
+		HEVC_SWSR_U1("pcm_loop_filter_disabled_flag",
+			     &sps->pcm_loop_filter_disabled_flag, sr_ctx);
+	} else {
+		sps->pcm_sample_bit_depth_luma_minus1 = 7;
+		sps->pcm_sample_bit_depth_chroma_minus1 = 7;
+		sps->log2_min_pcm_luma_coding_block_size_minus3 = 0;
+		sps->log2_diff_max_min_pcm_luma_coding_block_size = 2;
+	}
+
+	HEVC_SWSR_UE("num_short_term_ref_pic_sets",
+		     (unsigned int *)&sps->num_short_term_ref_pic_sets, sr_ctx);
+	HEVC_RANGEUCHECK("num_short_term_ref_pic_sets", sps->num_short_term_ref_pic_sets, 0,
+			 HEVC_MAX_NUM_ST_REF_PIC_SETS - 1, &parse_err);
+
+	for (i = 0; i < sps->num_short_term_ref_pic_sets; ++i) {
+		parse_err |= bspp_hevc_parse_shortterm_refpicset(sr_ctx,
+				sps->rps_list,
+				i,
+				0);
+	}
+
+	HEVC_SWSR_U1("long_term_ref_pics_present_flag",
+		     &sps->long_term_ref_pics_present_flag, sr_ctx);
+	if (sps->long_term_ref_pics_present_flag) {
+		HEVC_SWSR_UE("num_long_term_ref_pics_sps",
+			     (unsigned int *)&sps->num_long_term_ref_pics_sps, sr_ctx);
+		HEVC_RANGEUCHECK("num_long_term_ref_pics_sps",
+				 sps->num_long_term_ref_pics_sps, 0,
+				 HEVC_MAX_NUM_LT_REF_PICS, &parse_err);
+		for (i = 0; i < sps->num_long_term_ref_pics_sps; ++i) {
+			HEVC_SWSR_UN("lt_ref_pic_poc_lsb_sps",
+				     (unsigned int *)&sps->lt_ref_pic_poc_lsb_sps[i],
+				     sps->log2_max_pic_order_cnt_lsb_minus4 + 4,
+				     sr_ctx);
+			HEVC_SWSR_U1("used_by_curr_pic_lt_sps_flag",
+				     &sps->used_by_curr_pic_lt_sps_flag[i],
+				     sr_ctx);
+		}
+	}
+
+	HEVC_SWSR_U1("sps_temporal_mvp_enabled_flag", &sps->sps_temporal_mvp_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("strong_intra_smoothing_enabled_flag",
+		     &sps->strong_intra_smoothing_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("vui_parameters_present_flag", &sps->vui_parameters_present_flag, sr_ctx);
+
+	if (sps->vui_parameters_present_flag)
+		bspp_hevc_parsevui_parameters(sr_ctx, &sps->vui_params,
+					      sps->sps_max_sub_layers_minus1);
+
+	HEVC_SWSR_U1("sps_extension_present_flag", &sps->sps_extension_present_flag, sr_ctx);
+	if (sps->sps_extension_present_flag &&
+	    bspp_hevc_range_extensions_is_enabled(&sps->profile_tier_level)) {
+		HEVC_SWSR_U1("sps_range_extensions_flag", &sps->sps_range_extensions_flag, sr_ctx);
+
+		HEVC_SWSR_UN("sps_extension_7bits", (unsigned int *)&sps->sps_extension_7bits, 7,
+			     sr_ctx);
+		/*
+		 *  ignore extension data. Although we inform
+		 * if some non-zero data was found
+		 */
+		HEVC_UCHECK("sps_extension_7bits", sps->sps_extension_7bits, 0, &parse_err);
+		/*
+		 * TODO ?: the newest HEVC spec (10/2014) splits
+		 * "sps_extension_7bits" to * sps_multilayer_extension_flag (1)
+		 * sps_extension_6bits (6)
+		 */
+		if (sps->sps_range_extensions_flag)
+			parse_err |= bspp_hevc_parse_spsrange_extensions
+						(sr_ctx, &sps->range_exts);
+	}
+	/*
+	 * calculate "derived" variables needed further in the parsing process
+	 * (of other headers) and save them for later use
+	 */
+	sps->sub_width_c = 1;
+	sps->sub_height_c = 1;
+	if (sps->chroma_format_idc == 2) {
+		sps->sub_width_c = 2;
+	} else if (sps->chroma_format_idc == 1) {
+		sps->sub_width_c = 2;
+		sps->sub_height_c = 2;
+	}
+
+	min_cblog2_size_y = sps->log2_min_luma_coding_block_size_minus3 + 3;
+	sps->ctb_log2size_y =
+		min_cblog2_size_y + sps->log2_diff_max_min_luma_coding_block_size;
+	sps->ctb_size_y = 1 << sps->ctb_log2size_y;
+
+	if (sps->ctb_size_y > 0) {
+		/* use integer division with rounding up */
+		sps->pic_width_in_ctbs_y =
+			(sps->pic_width_in_luma_samples + sps->ctb_size_y - 1)
+			/ sps->ctb_size_y;
+		sps->pic_height_in_ctbs_y =
+			(sps->pic_height_in_luma_samples + sps->ctb_size_y - 1)
+			/ sps->ctb_size_y;
+	} else {
+		parse_err |= BSPP_ERROR_INVALID_VALUE;
+	}
+
+	sps->pic_size_in_ctbs_y =
+		sps->pic_width_in_ctbs_y * sps->pic_height_in_ctbs_y;
+
+	sps->max_pic_order_cnt_lsb =
+		1 << (sps->log2_max_pic_order_cnt_lsb_minus4 + 4);
+
+	for (i = 0; i <= sps->sps_max_sub_layers_minus1; ++i) {
+		sps->sps_max_latency_pictures[i] =
+			sps->sps_max_num_reorder_pics[i] +
+			sps->sps_max_latency_increase_plus1[i] - 1;
+	}
+
+	BSPP_HEVC_SYNTAX("ctb_size_y: %u", sps->ctb_size_y);
+	BSPP_HEVC_SYNTAX("pic_width_in_ctbs_y: %u", sps->pic_width_in_ctbs_y);
+	BSPP_HEVC_SYNTAX("pic_height_in_ctbs_y: %u", sps->pic_height_in_ctbs_y);
+	BSPP_HEVC_SYNTAX("pic_size_in_ctbs_y: %u", sps->pic_size_in_ctbs_y);
+
+	return parse_err;
+}
+
+static int bspp_hevc_release_sequhdrinfo(void *str_alloc, void *secure_spsinfo)
+{
+	struct bspp_hevc_sps *hevc_sps = (struct bspp_hevc_sps *)secure_spsinfo;
+
+	if (!hevc_sps)
+		return IMG_ERROR_INVALID_PARAMETERS;
+
+	/* Release the raw VIU data. */
+	bspp_streamrelese_rawbstrdataplain(str_alloc, (void *)hevc_sps->vui_raw_data);
+	return 0;
+}
+
+static int bspp_hevc_releasedata(void *str_alloc, enum bspp_unit_type data_type,
+				 void *data_handle)
+{
+	int result = 0;
+
+	if (!data_handle)
+		return IMG_ERROR_INVALID_PARAMETERS;
+
+	switch (data_type) {
+	case BSPP_UNIT_SEQUENCE:
+		result = bspp_hevc_release_sequhdrinfo(str_alloc, data_handle);
+		break;
+	default:
+		break;
+	}
+
+	return result;
+}
+
+static int bspp_hevc_reset_ppsinfo(void *secure_ppsinfo)
+{
+	struct bspp_hevc_pps *hevc_pps = NULL;
+
+	if (!secure_ppsinfo)
+		return IMG_ERROR_INVALID_PARAMETERS;
+
+	hevc_pps = (struct bspp_hevc_pps *)secure_ppsinfo;
+
+	memset(hevc_pps, 0, sizeof(*hevc_pps));
+
+	return 0;
+}
+
+static int bspp_hevc_resetdata(enum bspp_unit_type data_type, void *data_handle)
+{
+	int result = 0;
+
+	switch (data_type) {
+	case BSPP_UNIT_PPS:
+		result = bspp_hevc_reset_ppsinfo(data_handle);
+		break;
+	default:
+		break;
+	}
+	return result;
+}
+
+static enum bspp_error_type bspp_hevc_parsepps_range_extensions
+			(void *sr_ctx,
+			 struct bspp_hevc_pps_range_exts *range_exts,
+			 unsigned char transform_skip_enabled_flag,
+			 unsigned char log2_diff_max_min_luma_coding_block_size)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(range_exts);
+
+	memset(range_exts, 0, sizeof(struct bspp_hevc_pps_range_exts));
+
+	if (transform_skip_enabled_flag)
+		HEVC_SWSR_UE("log2_max_transform_skip_block_size_minus2",
+			     (unsigned int *)&range_exts->log2_max_transform_skip_block_size_minus2,
+			     sr_ctx);
+
+	HEVC_SWSR_U1("cross_component_prediction_enabled_flag",
+		     &range_exts->cross_component_prediction_enabled_flag,
+		     sr_ctx);
+	HEVC_UCHECK("cross_component_prediction_enabled_flag",
+		    range_exts->cross_component_prediction_enabled_flag, 0,
+		    &parse_err);
+
+	HEVC_SWSR_U1("chroma_qp_offset_list_enabled_flag",
+		     &range_exts->chroma_qp_offset_list_enabled_flag, sr_ctx);
+
+	if (range_exts->chroma_qp_offset_list_enabled_flag) {
+		unsigned char i;
+
+		HEVC_SWSR_UE("diff_cu_chroma_qp_offset_depth",
+			     (unsigned int *)&range_exts->diff_cu_chroma_qp_offset_depth,
+			     sr_ctx);
+		HEVC_RANGEUCHECK("diff_cu_chroma_qp_offset_depth",
+				 range_exts->diff_cu_chroma_qp_offset_depth, 0,
+				 log2_diff_max_min_luma_coding_block_size,
+				 &parse_err);
+
+		HEVC_SWSR_UE("chroma_qp_offset_list_len_minus1",
+			     (unsigned int *)&range_exts->chroma_qp_offset_list_len_minus1,
+			     sr_ctx);
+		HEVC_RANGEUCHECK("chroma_qp_offset_list_len_minus1",
+				 range_exts->chroma_qp_offset_list_len_minus1,
+				 0, HEVC_MAX_CHROMA_QP - 1, &parse_err);
+		for (i = 0; i <= range_exts->chroma_qp_offset_list_len_minus1; i++) {
+			HEVC_SWSR_SE("cb_qp_offset_list",
+				     (int *)&range_exts->cb_qp_offset_list[i], sr_ctx);
+			HEVC_RANGESCHECK("cb_qp_offset_list", range_exts->cb_qp_offset_list[i],
+					 -12, 12, &parse_err);
+			HEVC_SWSR_SE("cr_qp_offset_list",
+				     (int *)&range_exts->cr_qp_offset_list[i], sr_ctx);
+			HEVC_RANGESCHECK("cr_qp_offset_list", range_exts->cr_qp_offset_list[i],
+					 -12, 12, &parse_err);
+		}
+	}
+	HEVC_SWSR_UE("log2_sao_offset_scale_luma",
+		     (unsigned int *)&range_exts->log2_sao_offset_scale_luma, sr_ctx);
+	HEVC_UCHECK("log2_sao_offset_scale_luma",
+		    range_exts->log2_sao_offset_scale_luma, 0, &parse_err);
+	HEVC_SWSR_UE("log2_sao_offset_scale_chroma",
+		     (unsigned int *)&range_exts->log2_sao_offset_scale_chroma, sr_ctx);
+	HEVC_UCHECK("log2_sao_offset_scale_chroma",
+		    range_exts->log2_sao_offset_scale_chroma, 0, &parse_err);
+
+	return parse_err;
+}
+
+static unsigned char bspp_hevc_checkppsrangeextensions
+				(struct bspp_hevc_pps_range_exts *range_exts)
+{
+	VDEC_ASSERT(range_exts);
+
+	if (range_exts->log2_max_transform_skip_block_size_minus2 ||
+	    range_exts->cross_component_prediction_enabled_flag)
+		return 1;
+	/*
+	 * Note: chroma_qp_offset_list_enabled_flag is supported even
+	 * if hw capabilities (bHevcRangeExt is not set)
+	 */
+	return 0;
+}
+
+static enum bspp_error_type bspp_hevc_parsepps
+			(void *sr_ctx, void *str_res,
+			 struct bspp_hevc_pps *pps)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+	struct bspp_sequence_hdr_info *spsinfo = NULL;
+	struct bspp_hevc_sps *sps = NULL;
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(pps);
+	memset(pps, 0, sizeof(struct bspp_hevc_pps));
+
+	HEVC_SWSR_UE("pps_pic_parameter_set_id",
+		     (unsigned int *)&pps->pps_pic_parameter_set_id, sr_ctx);
+	HEVC_RANGEUCHECK("pps_pic_parameter_set_id", pps->pps_pic_parameter_set_id, 0,
+			 HEVC_MAX_PPS_COUNT - 1, &parse_err);
+	HEVC_SWSR_UE("pps_seq_parameter_set_id",
+		     (unsigned int *)&pps->pps_seq_parameter_set_id, sr_ctx);
+	HEVC_RANGEUCHECK("pps_seq_parameter_set_id", pps->pps_seq_parameter_set_id, 0,
+			 HEVC_MAX_SPS_COUNT - 1, &parse_err);
+
+	spsinfo = bspp_get_sequ_hdr(str_res, pps->pps_seq_parameter_set_id);
+	if (!spsinfo) {
+		parse_err |= BSPP_ERROR_NO_SEQUENCE_HDR;
+	} else {
+		sps = (struct bspp_hevc_sps *)spsinfo->secure_sequence_info;
+		VDEC_ASSERT(sps->sps_seq_parameter_set_id ==
+			pps->pps_seq_parameter_set_id);
+	}
+
+	HEVC_SWSR_U1("dependent_slice_segments_enabled_flag",
+		     &pps->dependent_slice_segments_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("output_flag_present_flag",
+		     &pps->output_flag_present_flag, sr_ctx);
+	HEVC_SWSR_UN("num_extra_slice_header_bits",
+		     (unsigned int *)&pps->num_extra_slice_header_bits, 3, sr_ctx);
+	HEVC_SWSR_U1("sign_data_hiding_enabled_flag", &pps->sign_data_hiding_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("cabac_init_present_flag", &pps->cabac_init_present_flag, sr_ctx);
+	HEVC_SWSR_UE("num_ref_idx_l0_default_active_minus1",
+		     (unsigned int *)&pps->num_ref_idx_l0_default_active_minus1, sr_ctx);
+	HEVC_RANGEUCHECK("num_ref_idx_l0_default_active_minus1",
+			 pps->num_ref_idx_l0_default_active_minus1, 0, 14, &parse_err);
+	HEVC_SWSR_UE("num_ref_idx_l1_default_active_minus1",
+		     (unsigned int *)&pps->num_ref_idx_l1_default_active_minus1, sr_ctx);
+	HEVC_RANGEUCHECK("num_ref_idx_l1_default_active_minus1",
+			 pps->num_ref_idx_l1_default_active_minus1, 0, 14, &parse_err);
+	HEVC_SWSR_SE("init_qp_minus26", (int *)&pps->init_qp_minus26, sr_ctx);
+
+	if (sps)
+		HEVC_RANGESCHECK("init_qp_minus26", pps->init_qp_minus26,
+				 -(26 + (6 * sps->bit_depth_luma_minus8)), 25, &parse_err);
+
+	HEVC_SWSR_U1("constrained_intra_pred_flag", &pps->constrained_intra_pred_flag, sr_ctx);
+	HEVC_SWSR_U1("transform_skip_enabled_flag", &pps->transform_skip_enabled_flag, sr_ctx);
+
+	HEVC_SWSR_U1("cu_qp_delta_enabled_flag", &pps->cu_qp_delta_enabled_flag, sr_ctx);
+
+	if (pps->cu_qp_delta_enabled_flag)
+		HEVC_SWSR_UE("diff_cu_qp_delta_depth",
+			     (unsigned int *)&pps->diff_cu_qp_delta_depth, sr_ctx);
+
+	HEVC_SWSR_SE("pps_cb_qp_offset", (int *)&pps->pps_cb_qp_offset, sr_ctx);
+	HEVC_RANGESCHECK("pps_cb_qp_offset", pps->pps_cb_qp_offset, -12, 12, &parse_err);
+	HEVC_SWSR_SE("pps_cr_qp_offset", (int *)&pps->pps_cr_qp_offset, sr_ctx);
+	HEVC_RANGESCHECK("pps_cr_qp_offset", pps->pps_cr_qp_offset, -12, 12, &parse_err);
+	HEVC_SWSR_U1("pps_slice_chroma_qp_offsets_present_flag",
+		     &pps->pps_slice_chroma_qp_offsets_present_flag, sr_ctx);
+	HEVC_SWSR_U1("weighted_pred_flag", &pps->weighted_pred_flag, sr_ctx);
+	HEVC_SWSR_U1("weighted_bipred_flag", &pps->weighted_bipred_flag, sr_ctx);
+	HEVC_SWSR_U1("transquant_bypass_enabled_flag",
+		     &pps->transquant_bypass_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("tiles_enabled_flag", &pps->tiles_enabled_flag, sr_ctx);
+	HEVC_SWSR_U1("entropy_coding_sync_enabled_flag",
+		     &pps->entropy_coding_sync_enabled_flag, sr_ctx);
+
+	if (pps->tiles_enabled_flag) {
+		HEVC_SWSR_UE("num_tile_columns_minus1",
+			     (unsigned int *)&pps->num_tile_columns_minus1, sr_ctx);
+		HEVC_RANGEUCHECK("num_tile_columns_minus1", pps->num_tile_columns_minus1, 0,
+				 HEVC_MAX_TILE_COLS - 1, &parse_err);
+
+		if (pps->num_tile_columns_minus1 > HEVC_MAX_TILE_COLS)
+			pps->num_tile_columns_minus1 = HEVC_MAX_TILE_COLS;
+
+		HEVC_SWSR_UE("num_tile_rows_minus1", (unsigned int *)&pps->num_tile_rows_minus1,
+			     sr_ctx);
+		HEVC_RANGEUCHECK("num_tile_rows_minus1", pps->num_tile_rows_minus1, 0,
+				 HEVC_MAX_TILE_ROWS - 1, &parse_err);
+
+		if (pps->num_tile_rows_minus1 > HEVC_MAX_TILE_ROWS)
+			pps->num_tile_rows_minus1 = HEVC_MAX_TILE_ROWS;
+
+		HEVC_SWSR_U1("uniform_spacing_flag", &pps->uniform_spacing_flag, sr_ctx);
+
+		if (!pps->uniform_spacing_flag) {
+			unsigned char i = 0;
+
+			for (i = 0; i < pps->num_tile_columns_minus1; ++i)
+				HEVC_SWSR_UE("column_width_minus1",
+					     (unsigned int *)&pps->column_width_minus1[i],
+					     sr_ctx);
+
+			for (i = 0; i < pps->num_tile_rows_minus1; ++i)
+				HEVC_SWSR_UE("row_height_minus1",
+					     (unsigned int *)&pps->row_height_minus1[i],
+					     sr_ctx);
+		}
+		HEVC_SWSR_U1("loop_filter_across_tiles_enabled_flag",
+			     &pps->loop_filter_across_tiles_enabled_flag, sr_ctx);
+	} else {
+		pps->loop_filter_across_tiles_enabled_flag = 1;
+	}
+
+	HEVC_SWSR_U1("pps_loop_filter_across_slices_enabled_flag",
+		     &pps->pps_loop_filter_across_slices_enabled_flag, sr_ctx);
+
+	HEVC_SWSR_U1("deblocking_filter_control_present_flag",
+		     &pps->deblocking_filter_control_present_flag, sr_ctx);
+
+	if (pps->deblocking_filter_control_present_flag) {
+		HEVC_SWSR_U1("deblocking_filter_override_enabled_flag",
+			     &pps->deblocking_filter_override_enabled_flag, sr_ctx);
+		HEVC_SWSR_U1("pps_deblocking_filter_disabled_flag",
+			     &pps->pps_deblocking_filter_disabled_flag, sr_ctx);
+		if (!pps->pps_deblocking_filter_disabled_flag) {
+			HEVC_SWSR_SE("pps_beta_offset_div2", (int *)&pps->pps_beta_offset_div2,
+				     sr_ctx);
+			HEVC_RANGESCHECK("pps_beta_offset_div2", pps->pps_beta_offset_div2, -6, 6,
+					 &parse_err);
+			HEVC_SWSR_SE("pps_tc_offset_div2", (int *)&pps->pps_tc_offset_div2, sr_ctx);
+			HEVC_RANGESCHECK("pps_tc_offset_div2", pps->pps_tc_offset_div2, -6, 6,
+					 &parse_err);
+		}
+	}
+
+	HEVC_SWSR_U1("pps_scaling_list_data_present_flag",
+		     &pps->pps_scaling_list_data_present_flag, sr_ctx);
+	if (pps->pps_scaling_list_data_present_flag)
+		parse_err |= bspp_hevc_parse_scalinglistdata(sr_ctx, &pps->scaling_list);
+
+	HEVC_SWSR_U1("lists_modification_present_flag",
+		     &pps->lists_modification_present_flag, sr_ctx);
+	HEVC_SWSR_UE("log2_parallel_merge_level_minus2",
+		     (unsigned int *)&pps->log2_parallel_merge_level_minus2, sr_ctx);
+	HEVC_SWSR_U1("slice_segment_header_extension_present_flag",
+		     &pps->slice_segment_header_extension_present_flag, sr_ctx);
+
+	HEVC_SWSR_U1("pps_extension_present_flag", &pps->pps_extension_present_flag, sr_ctx);
+	if (pps->pps_extension_present_flag &&
+	    bspp_hevc_range_extensions_is_enabled(&sps->profile_tier_level)) {
+		HEVC_SWSR_U1("pps_range_extensions_flag",
+			     &pps->pps_range_extensions_flag, sr_ctx);
+		HEVC_SWSR_UN("pps_extension_7bits",
+			     (unsigned int *)&pps->pps_extension_7bits, 7, sr_ctx);
+		/*
+		 * ignore extension data. Although we inform
+		 * if some non-zero data was found
+		 */
+		HEVC_UCHECK("pps_extension_7bits", pps->pps_extension_7bits, 0, &parse_err);
+
+		/*
+		 * TODO ?: the newest HEVC spec (10/2014) splits "pps_extension_7bits" to
+		 * pps_multilayer_extension_flag (1)
+		 * pps_extension_6bits (6)
+		 */
+		if (pps->pps_range_extensions_flag && sps) {
+			parse_err |= bspp_hevc_parsepps_range_extensions
+					(sr_ctx,
+					 &pps->range_exts,
+					 pps->transform_skip_enabled_flag,
+					 sps->log2_diff_max_min_luma_coding_block_size);
+		}
+	}
+
+	/* calculate derived elements */
+	if (pps->tiles_enabled_flag && sps)
+		bspp_hevc_dotilecalculations(sps, pps);
+
+	return parse_err;
+}
+
+static void bspp_hevc_dotilecalculations(struct bspp_hevc_sps *sps,
+					 struct bspp_hevc_pps *pps)
+{
+	unsigned short colwidth[HEVC_MAX_TILE_COLS];
+	unsigned short rowheight[HEVC_MAX_TILE_ROWS];
+	unsigned char i;
+
+	if (!pps->tiles_enabled_flag) {
+		pps->max_tile_height_in_ctbs_y = sps->pic_height_in_ctbs_y;
+		return;
+	}
+
+	if (pps->uniform_spacing_flag) {
+		for (i = 0; i <= pps->num_tile_columns_minus1; ++i) {
+			colwidth[i] = ((i + 1) * sps->pic_width_in_ctbs_y) /
+				(pps->num_tile_columns_minus1 + 1) -
+				(i * sps->pic_width_in_ctbs_y) /
+				(pps->num_tile_columns_minus1 + 1);
+		}
+
+		for (i = 0; i <= pps->num_tile_rows_minus1; ++i) {
+			rowheight[i] = ((i + 1) * sps->pic_height_in_ctbs_y) /
+				(pps->num_tile_rows_minus1 + 1) -
+				(i * sps->pic_height_in_ctbs_y) /
+				(pps->num_tile_rows_minus1 + 1);
+		}
+
+		pps->max_tile_height_in_ctbs_y = rowheight[0];
+	} else {
+		pps->max_tile_height_in_ctbs_y = 0;
+
+		colwidth[pps->num_tile_columns_minus1] = sps->pic_width_in_ctbs_y;
+		for (i = 0; i <= pps->num_tile_columns_minus1; ++i) {
+			colwidth[i] = pps->column_width_minus1[i] + 1;
+			colwidth[pps->num_tile_columns_minus1] -= colwidth[i];
+		}
+
+		rowheight[pps->num_tile_rows_minus1] = sps->pic_height_in_ctbs_y;
+		for (i = 0; i <= pps->num_tile_rows_minus1; ++i) {
+			rowheight[i] = pps->row_height_minus1[i] + 1;
+			rowheight[pps->num_tile_rows_minus1] -= rowheight[i];
+
+			if (rowheight[i] > pps->max_tile_height_in_ctbs_y)
+				pps->max_tile_height_in_ctbs_y = rowheight[i];
+		}
+
+		if (rowheight[pps->num_tile_rows_minus1] > pps->max_tile_height_in_ctbs_y)
+			pps->max_tile_height_in_ctbs_y =
+					rowheight[pps->num_tile_rows_minus1];
+	}
+
+	for (i = 0; i <= pps->num_tile_columns_minus1; ++i)
+		pps->col_bd[i + 1] = pps->col_bd[i] + colwidth[i];
+
+	for (i = 0; i <= pps->num_tile_rows_minus1; ++i)
+		pps->row_bd[i + 1] = pps->row_bd[i] + rowheight[i];
+}
+
+static enum bspp_error_type bspp_hevc_parse_slicesegmentheader
+		(void *sr_ctx, void *str_res,
+		 struct bspp_hevc_slice_segment_header *ssh,
+		 unsigned char nalunit_type,
+		 struct bspp_vps_info **vpsinfo,
+		 struct bspp_sequence_hdr_info **spsinfo,
+		 struct bspp_pps_info **ppsinfo)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+	struct bspp_hevc_pps *pps = NULL;
+	struct bspp_hevc_sps *sps = NULL;
+	struct bspp_hevc_vps *vps = NULL;
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(ssh);
+	VDEC_ASSERT(vpsinfo);
+	VDEC_ASSERT(spsinfo);
+	VDEC_ASSERT(ppsinfo);
+
+	memset(ssh, 0, sizeof(struct bspp_hevc_slice_segment_header));
+
+	HEVC_SWSR_U1("first_slice_segment_in_pic_flag",
+		     &ssh->first_slice_segment_in_pic_flag, sr_ctx);
+
+	if (bspp_hevc_picture_is_irap((enum hevc_nalunittype)nalunit_type))
+		HEVC_SWSR_U1("no_output_of_prior_pics_flag",
+			     &ssh->no_output_of_prior_pics_flag, sr_ctx);
+
+	HEVC_SWSR_UE("slice_pic_parameter_set_id", (unsigned int *)&ssh->slice_pic_parameter_set_id,
+		     sr_ctx);
+	HEVC_RANGEUCHECK("slice_pic_parameter_set_id", ssh->slice_pic_parameter_set_id, 0,
+			 HEVC_MAX_PPS_COUNT - 1, &parse_err);
+
+	if (ssh->slice_pic_parameter_set_id >= HEVC_MAX_PPS_COUNT) {
+		pr_warn("PPS Id invalid (%u), setting to 0",
+			ssh->slice_pic_parameter_set_id);
+		ssh->slice_pic_parameter_set_id = 0;
+		parse_err &= ~BSPP_ERROR_INVALID_VALUE;
+		parse_err |= BSPP_ERROR_CORRECTION_VALIDVALUE;
+	}
+
+	/* set PPS */
+	*ppsinfo = bspp_get_pps_hdr(str_res, ssh->slice_pic_parameter_set_id);
+	if (!(*ppsinfo)) {
+		parse_err |= BSPP_ERROR_NO_PPS;
+		goto error;
+	}
+	pps = (struct bspp_hevc_pps *)(*ppsinfo)->secure_pps_info;
+	if (!pps) {
+		parse_err |= BSPP_ERROR_NO_PPS;
+		goto error;
+	}
+	VDEC_ASSERT(pps->pps_pic_parameter_set_id == ssh->slice_pic_parameter_set_id);
+
+	*spsinfo = bspp_get_sequ_hdr(str_res, pps->pps_seq_parameter_set_id);
+	if (!(*spsinfo)) {
+		parse_err |= BSPP_ERROR_NO_SEQUENCE_HDR;
+		goto error;
+	}
+	sps = (struct bspp_hevc_sps *)(*spsinfo)->secure_sequence_info;
+	VDEC_ASSERT(sps->sps_seq_parameter_set_id == pps->pps_seq_parameter_set_id);
+
+	*vpsinfo = bspp_get_vpshdr(str_res, sps->sps_video_parameter_set_id);
+	if (!(*vpsinfo)) {
+		parse_err |= BSPP_ERROR_NO_VPS;
+		goto error;
+	}
+	vps = (struct bspp_hevc_vps *)(*vpsinfo)->secure_vpsinfo;
+	VDEC_ASSERT(vps->vps_video_parameter_set_id == sps->sps_video_parameter_set_id);
+
+	if (!ssh->first_slice_segment_in_pic_flag) {
+		if (pps->dependent_slice_segments_enabled_flag)
+			HEVC_SWSR_U1("dependent_slice_segment_flag",
+				     &ssh->dependent_slice_segment_flag, sr_ctx);
+
+		HEVC_SWSR_UN("slice_segment_address",
+			     (unsigned int *)&ssh->slice_segment_address,
+			     bspp_ceil_log2(sps->pic_size_in_ctbs_y), sr_ctx);
+	}
+
+error:
+	return parse_err;
+}
+
+static enum bspp_error_type bspp_hevc_parse_profiletierlevel
+		(void *sr_ctx,
+		 struct bspp_hevc_profile_tierlevel *ptl,
+		 unsigned char vps_maxsublayers_minus1)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+	unsigned char i, j;
+	unsigned int res = 0;
+
+	VDEC_ASSERT(sr_ctx);
+	VDEC_ASSERT(ptl);
+	VDEC_ASSERT(vps_maxsublayers_minus1 < HEVC_MAX_NUM_SUBLAYERS);
+
+	memset(ptl, 0, sizeof(struct bspp_hevc_profile_tierlevel));
+
+	HEVC_SWSR_UN("general_profile_space", (unsigned int *)&ptl->general_profile_space, 2,
+		     sr_ctx);
+	HEVC_SWSR_U1("general_tier_flag", &ptl->general_tier_flag, sr_ctx);
+	HEVC_SWSR_UN("general_profile_idc", (unsigned int *)&ptl->general_profile_idc, 5, sr_ctx);
+
+	for (j = 0; j < HEVC_MAX_NUM_PROFILE_IDC; ++j) {
+		HEVC_SWSR_U1("general_profile_compatibility_flag",
+			     &ptl->general_profile_compatibility_flag[j],
+			     sr_ctx);
+	}
+
+	HEVC_SWSR_U1("general_progressive_source_flag",
+		     &ptl->general_progressive_source_flag, sr_ctx);
+	HEVC_SWSR_U1("general_interlaced_source_flag",
+		     &ptl->general_interlaced_source_flag, sr_ctx);
+	HEVC_SWSR_U1("general_non_packed_constraint_flag",
+		     &ptl->general_non_packed_constraint_flag, sr_ctx);
+	HEVC_SWSR_U1("general_frame_only_constraint_flag",
+		     &ptl->general_frame_only_constraint_flag, sr_ctx);
+
+	if (ptl->general_profile_idc == 4 ||
+	    ptl->general_profile_compatibility_flag[4]) {
+		HEVC_SWSR_U1("general_max_12bit_constraint_flag",
+			     &ptl->general_max_12bit_constraint_flag, sr_ctx);
+		HEVC_SWSR_U1("general_max_10bit_constraint_flag",
+			     &ptl->general_max_10bit_constraint_flag, sr_ctx);
+		HEVC_SWSR_U1("general_max_8bit_constraint_flag",
+			     &ptl->general_max_8bit_constraint_flag, sr_ctx);
+		HEVC_SWSR_U1("general_max_422chroma_constraint_flag",
+			     &ptl->general_max_422chroma_constraint_flag,
+			     sr_ctx);
+		HEVC_SWSR_U1("general_max_420chroma_constraint_flag",
+			     &ptl->general_max_420chroma_constraint_flag,
+			     sr_ctx);
+		HEVC_SWSR_U1("general_max_monochrome_constraint_flag",
+			     &ptl->general_max_monochrome_constraint_flag,
+			     sr_ctx);
+		HEVC_SWSR_U1("general_intra_constraint_flag",
+			     &ptl->general_intra_constraint_flag, sr_ctx);
+		HEVC_SWSR_U1("general_one_picture_only_constraint_flag",
+			     &ptl->general_one_picture_only_constraint_flag,
+			     sr_ctx);
+		HEVC_SWSR_U1("general_lower_bit_rate_constraint_flag",
+			     &ptl->general_lower_bit_rate_constraint_flag,
+			     sr_ctx);
+		HEVC_SWSR_UN("general_reserved_zero_35bits", &res, 32, sr_ctx);
+		HEVC_UCHECK("general_reserved_zero_35bits", res, 0, &parse_err);
+		HEVC_SWSR_UN("general_reserved_zero_35bits", &res, 3, sr_ctx);
+		HEVC_UCHECK("general_reserved_zero_35bits", res, 0, &parse_err);
+	} else {
+		HEVC_SWSR_UN("general_reserved_zero_44bits (1)", &res, 32, sr_ctx);
+		HEVC_UCHECK("general_reserved_zero_44bits (1)", res, 0, &parse_err);
+		HEVC_SWSR_UN("general_reserved_zero_44bits (2)", &res, 12, sr_ctx);
+		HEVC_UCHECK("general_reserved_zero_44bits (2)", res, 0, &parse_err);
+	}
+
+	HEVC_SWSR_UN("general_level_idc", (unsigned int *)&ptl->general_level_idc, 8, sr_ctx);
+	HEVC_RANGEUCHECK("general_level_idc", ptl->general_level_idc,
+			 HEVC_LEVEL_IDC_MIN, HEVC_LEVEL_IDC_MAX, &parse_err);
+
+	for (i = 0; i < vps_maxsublayers_minus1; ++i) {
+		HEVC_SWSR_U1("sub_layer_profile_present_flag",
+			     &ptl->sub_layer_profile_present_flag[i], sr_ctx);
+		HEVC_SWSR_U1("sub_layer_level_present_flag",
+			     &ptl->sub_layer_level_present_flag[i], sr_ctx);
+	}
+
+	if (vps_maxsublayers_minus1 > 0) {
+		for (i = vps_maxsublayers_minus1; i < 8; ++i) {
+			HEVC_SWSR_UN("reserved_zero_2bits", &res, 2, sr_ctx);
+			HEVC_UCHECK("reserved_zero_2bits", res, 0, &parse_err);
+		}
+	}
+
+	for (i = 0; i < vps_maxsublayers_minus1; ++i) {
+		if (ptl->sub_layer_profile_present_flag[i]) {
+			HEVC_SWSR_UN("sub_layer_profile_space",
+				     (unsigned int *)&ptl->sub_layer_profile_space[i], 2, sr_ctx);
+			HEVC_SWSR_U1("sub_layer_tier_flag", &ptl->sub_layer_tier_flag[i], sr_ctx);
+			HEVC_SWSR_UN("sub_layer_profile_idc",
+				     (unsigned int *)&ptl->sub_layer_profile_idc[i], 5, sr_ctx);
+			for (j = 0; j < HEVC_MAX_NUM_PROFILE_IDC; ++j)
+				HEVC_SWSR_U1("sub_layer_profile_compatibility_flag",
+					     &ptl->sub_layer_profile_compatibility_flag[i][j],
+					     sr_ctx);
+
+			HEVC_SWSR_U1("sub_layer_progressive_source_flag",
+				     &ptl->sub_layer_progressive_source_flag[i],
+				     sr_ctx);
+			HEVC_SWSR_U1("sub_layer_interlaced_source_flag",
+				     &ptl->sub_layer_interlaced_source_flag[i],
+				     sr_ctx);
+			HEVC_SWSR_U1("sub_layer_non_packed_constraint_flag",
+				     &ptl->sub_layer_non_packed_constraint_flag[i],
+				     sr_ctx);
+			HEVC_SWSR_U1("sub_layer_frame_only_constraint_flag",
+				     &ptl->sub_layer_frame_only_constraint_flag[i],
+				     sr_ctx);
+
+			if (ptl->sub_layer_profile_idc[i] == 4 ||
+			    ptl->sub_layer_profile_compatibility_flag[i][4]) {
+				HEVC_SWSR_U1("sub_layer_max_12bit_constraint_flag",
+					     &ptl->sub_layer_max_12bit_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_max_10bit_constraint_flag",
+					     &ptl->sub_layer_max_10bit_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_max_8bit_constraint_flag",
+					     &ptl->sub_layer_max_8bit_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_max_422chroma_constraint_flag",
+					     &ptl->sub_layer_max_422chroma_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_max_420chroma_constraint_flag",
+					     &ptl->sub_layer_max_420chroma_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_max_monochrome_constraint_flag",
+					     &ptl->sub_layer_max_monochrome_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_intra_constraint_flag",
+					     &ptl->sub_layer_intra_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_one_picture_only_constraint_flag",
+					     &ptl->sub_layer_one_picture_only_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_U1("sub_layer_lower_bit_rate_constraint_flag",
+					     &ptl->sub_layer_lower_bit_rate_constraint_flag[i],
+					     sr_ctx);
+				HEVC_SWSR_UN("sub_layer_reserved_zero_35bits",
+					     &res, 32, sr_ctx);
+				HEVC_UCHECK("sub_layer_reserved_zero_35bits",
+					    res, 0, &parse_err);
+				HEVC_SWSR_UN("sub_layer_reserved_zero_35bits",
+					     &res, 3, sr_ctx);
+				HEVC_UCHECK("sub_layer_reserved_zero_35bits",
+					    res, 0, &parse_err);
+			} else {
+				HEVC_SWSR_UN("sub_layer_reserved_zero_44bits (1)",
+					     &res, 32, sr_ctx);
+				HEVC_UCHECK("sub_layer_reserved_zero_44bits (1)",
+					    res, 0, &parse_err);
+				HEVC_SWSR_UN("sub_layer_reserved_zero_44bits (2)",
+					     &res, 12, sr_ctx);
+				HEVC_UCHECK("sub_layer_reserved_zero_44bits (2)",
+					    res, 0, &parse_err);
+			}
+		}
+		if (ptl->sub_layer_level_present_flag[i])
+			HEVC_SWSR_UN("sub_layer_level_idc",
+				     (unsigned int *)&ptl->sub_layer_level_idc[i], 8, sr_ctx);
+	}
+	return parse_err;
+}
+
+/* Default scaling lists */
+#define HEVC_SCALING_LIST_0_SIZE 16
+#define HEVC_SCALING_LIST_123_SIZE 64
+
+static const unsigned char def_4x4[HEVC_SCALING_LIST_0_SIZE] = {
+	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
+};
+
+static const unsigned char def_8x8_intra[HEVC_SCALING_LIST_123_SIZE] = {
+	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 16, 17, 16, 17, 18,
+	17, 18, 18, 17, 18, 21, 19, 20, 21, 20, 19, 21, 24, 22, 22, 24,
+	24, 22, 22, 24, 25, 25, 27, 30, 27, 25, 25, 29, 31, 35, 35, 31,
+	29, 36, 41, 44, 41, 36, 47, 54, 54, 47, 65, 70, 65, 88, 88, 115
+};
+
+static const unsigned char def_8x8_inter[HEVC_SCALING_LIST_123_SIZE] = {
+	16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18,
+	18, 18, 18, 18, 18, 20, 20, 20, 20, 20, 20, 20, 24, 24, 24, 24,
+	24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 28, 28, 28, 28, 28,
+	28, 33, 33, 33, 33, 33, 41, 41, 41, 41, 54, 54, 54, 71, 71, 91
+};
+
+/*
+ * Scan order mapping when translating scaling lists from bitstream order
+ * to PVDEC order
+ */
+static const unsigned char HEVC_INV_ZZ_SCAN4[HEVC_SCALING_LIST_MATRIX_SIZE / 4]  = {
+	0,  1,  2,  4,  3,  6,  7, 10,  5,  8,  9, 12, 11, 13, 14, 15
+};
+
+static const unsigned char HEVC_INV_ZZ_SCAN8[HEVC_SCALING_LIST_MATRIX_SIZE] = {
+	0,  1,  2,  4,  3,  6,  7, 11,  5,  8,  9, 13, 12, 17, 18, 24,
+	10, 15, 16, 22, 21, 28, 29, 36, 23, 30, 31, 38, 37, 43, 44, 49,
+	14, 19, 20, 26, 25, 32, 33, 40, 27, 34, 35, 42, 41, 47, 48, 53,
+	39, 45, 46, 51, 50, 54, 55, 58, 52, 56, 57, 60, 59, 61, 62, 63
+};
+
+static void bspp_hevc_getdefault_scalinglist
+		(unsigned char size_id, unsigned char matrix_id,
+		 const unsigned char **default_scalinglist,
+		 unsigned int *size)
+{
+	static const unsigned char *defaultlists
+	[HEVC_SCALING_LIST_NUM_SIZES][HEVC_SCALING_LIST_NUM_MATRICES] = {
+		{ def_4x4, def_4x4, def_4x4, def_4x4, def_4x4, def_4x4 },
+		{ def_8x8_intra, def_8x8_intra, def_8x8_intra,
+		  def_8x8_inter, def_8x8_inter, def_8x8_inter },
+		{ def_8x8_intra, def_8x8_intra, def_8x8_intra,
+		  def_8x8_inter, def_8x8_inter, def_8x8_inter },
+		{ def_8x8_intra, def_8x8_inter, NULL, NULL, NULL, NULL }
+	};
+
+	static const unsigned int lists_sizes
+	[HEVC_SCALING_LIST_NUM_SIZES][HEVC_SCALING_LIST_NUM_MATRICES] = {
+		{ sizeof(def_4x4), sizeof(def_4x4), sizeof(def_4x4),
+		  sizeof(def_4x4), sizeof(def_4x4), sizeof(def_4x4) },
+		{ sizeof(def_8x8_intra), sizeof(def_8x8_intra),
+		  sizeof(def_8x8_intra), sizeof(def_8x8_inter),
+		  sizeof(def_8x8_inter), sizeof(def_8x8_inter) },
+		{ sizeof(def_8x8_intra), sizeof(def_8x8_intra),
+		  sizeof(def_8x8_intra), sizeof(def_8x8_inter),
+		  sizeof(def_8x8_inter), sizeof(def_8x8_inter) },
+		{ sizeof(def_8x8_intra), sizeof(def_8x8_inter), 0, 0, 0, 0 }
+	};
+
+	/* to assert that input to this function was correct */
+	VDEC_ASSERT(size_id < 4);
+	VDEC_ASSERT(size_id < 3 ? (matrix_id < 6) : (matrix_id < 2));
+
+	*default_scalinglist = defaultlists[size_id][matrix_id];
+	*size = lists_sizes[size_id][matrix_id];
+}
+
+static enum bspp_error_type bspp_hevc_parse_scalinglistdata
+			(void *sr_ctx,
+			 struct bspp_hevc_scalinglist_data *scaling_listdata)
+{
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+	unsigned char size_id, matrix_id;
+
+	for (size_id = 0; size_id < HEVC_SCALING_LIST_NUM_SIZES; ++size_id) {
+		for (matrix_id = 0; matrix_id < ((size_id == 3) ? 2 : 6);
+			++matrix_id) {
+			/*
+			 * Select scaling list on which we will operate in
+			 * the iteration
+			 */
+			unsigned char *scalinglist = scaling_listdata->lists[size_id][matrix_id];
+
+			unsigned char scaling_list_pred_mode_flag = 0;
+
+			HEVC_SWSR_U1("scaling_list_pred_mode_flag",
+				     &scaling_list_pred_mode_flag, sr_ctx);
+			if (!scaling_list_pred_mode_flag) {
+				unsigned char scaling_list_pred_matrix_id_delta = 0;
+				const unsigned char *defaultlist = NULL;
+				unsigned int listsize = 0;
+
+				HEVC_SWSR_UE("scaling_list_pred_matrixid_delta",
+					     (unsigned int *)&scaling_list_pred_matrix_id_delta,
+					     sr_ctx);
+
+				bspp_hevc_getdefault_scalinglist(size_id,
+								 matrix_id,
+								 &defaultlist,
+								 &listsize);
+
+				if (scaling_list_pred_matrix_id_delta == 0) {
+					/* use default one */
+					memcpy(scalinglist, defaultlist, listsize);
+					if (size_id > 1)
+						scaling_listdata->dccoeffs[size_id -
+						2][matrix_id] = 8 + 8;
+				} else {
+					unsigned char ref_matrix_id =
+						matrix_id - scaling_list_pred_matrix_id_delta;
+					unsigned char *refscalinglist =
+						scaling_listdata->lists[size_id][ref_matrix_id];
+					/*
+					 *  use reference list given by
+					 * scaling_list_pred_matrix_id_delta
+					 */
+					memcpy(scalinglist, refscalinglist, listsize);
+					if (size_id > 1)
+						scaling_listdata->dccoeffs[size_id - 2][matrix_id] =
+							scaling_listdata->dccoeffs[size_id -
+							2][ref_matrix_id];
+				}
+			} else {
+				/*
+				 * scaling list coefficients
+				 * signalled explicitly
+				 */
+				static const short coef_startvalue = 8;
+				static const unsigned char matrix_max_coef_num = 64;
+
+				short next_coef = coef_startvalue;
+				unsigned char coef_num =
+					HEVC_MIN(matrix_max_coef_num,
+						 (1 << (4 + (size_id << 1))), unsigned char);
+
+				unsigned char i;
+
+				if (size_id > 1) {
+					short scaling_list_dc_coef_minus8 = 0;
+
+					HEVC_SWSR_SE("scaling_list_dc_coef_minus8",
+						     (int *)&scaling_list_dc_coef_minus8,
+						     sr_ctx);
+					HEVC_RANGESCHECK("scaling_list_dc_coef_minus8",
+							 scaling_list_dc_coef_minus8,
+							 -7, 247, &parse_err);
+
+					next_coef = scaling_list_dc_coef_minus8 + 8;
+					scaling_listdata->dccoeffs[size_id - 2][matrix_id] =
+						(unsigned char)next_coef;
+				}
+				for (i = 0; i < coef_num; ++i) {
+					short scaling_list_delta_coef = 0;
+
+					HEVC_SWSR_SE("scaling_list_delta_coef",
+						     (int *)&scaling_list_delta_coef, sr_ctx);
+					HEVC_RANGESCHECK("scaling_list_delta_coef",
+							 scaling_list_delta_coef, -128, 127,
+							 &parse_err);
+
+					next_coef = (next_coef + scaling_list_delta_coef + 256) &
+											0xFF;
+					scalinglist[i] = next_coef;
+				}
+			}
+		}
+	}
+
+#ifdef DEBUG_DECODER_DRIVER
+	/* print calculated scaling lists */
+	for (size_id = 0; size_id < HEVC_SCALING_LIST_NUM_SIZES; ++size_id) {
+		for (matrix_id = 0; matrix_id < ((size_id == 3) ? 2 : 6);
+			++matrix_id) {
+			unsigned char i = 0;
+			/*
+			 * Select scaling list on which we will operate
+			 * in the iteration
+			 */
+			unsigned char *scalinglist = scaling_listdata->lists[size_id][matrix_id];
+
+			for (; i < ((size_id == 0) ? 16 : 64); ++i) {
+				BSPP_HEVC_SYNTAX("scalinglist[%u][%u][%u] = %u",
+						 size_id,
+						 matrix_id,
+						 i,
+						 scalinglist[i]);
+			}
+		}
+	}
+#endif
+
+	return parse_err;
+}
+
+static void
+bspp_hevc_usedefault_scalinglists(struct bspp_hevc_scalinglist_data *scaling_listdata)
+{
+	unsigned char size_id, matrix_id;
+
+	for (size_id = 0; size_id < HEVC_SCALING_LIST_NUM_SIZES; ++size_id) {
+		for (matrix_id = 0; matrix_id < ((size_id == 3) ? 2 : 6);
+			++matrix_id) {
+			unsigned char *list = scaling_listdata->lists[size_id][matrix_id];
+			const unsigned char *defaultlist = NULL;
+			unsigned int listsize = 0;
+
+			bspp_hevc_getdefault_scalinglist(size_id, matrix_id, &defaultlist,
+							 &listsize);
+
+			memcpy(list, defaultlist, listsize);
+		}
+	}
+
+	memset(scaling_listdata->dccoeffs, 8 + 8, sizeof(scaling_listdata->dccoeffs));
+}
+
+static enum bspp_error_type bspp_hevc_parse_shortterm_refpicset
+				(void *sr_ctx,
+				 struct bspp_hevc_shortterm_refpicset *st_refpicset,
+				 unsigned char st_rps_idx,
+				 unsigned char in_slice_header)
+{
+	/*
+	 * Note: unfortunately short term ref pic set has to be
+	 * "partially-decoded" and parsed at the same time because derived
+	 * syntax elements are used for prediction of subsequent
+	 * short term ref pic sets.
+	 */
+	enum bspp_error_type parse_err = BSPP_ERROR_NONE;
+
+	struct bspp_hevc_shortterm_refpicset *strps =
+		&st_refpicset[st_rps_idx];
+	unsigned char inter_ref_pic_set_prediction_flag = 0;
+	unsigned int i = 0;
+
+	memset(strps, 0, sizeof(*strps));
+
+	if (st_rps_idx != 0) {
+		HEVC_SWSR_U1("inter_ref_pic_set_prediction_flag",
+			     &inter_ref_pic_set_prediction_flag, sr_ctx);
+	}
+
+	if (inter_ref_pic_set_prediction_flag) {
+		signed char j = 0;
+		unsigned char j_8 = 0;
+		unsigned char ref_rps_idx = 0;
+		int delta_rps = 0;
+		unsigned char i = 0;
+		unsigned char delta_idx_minus1 = 0;
+		unsigned char delta_rps_sign = 0;
+		unsigned short abs_delta_rps_minus1 = 0;
+		unsigned char used_by_curr_pic_flag[HEVC_MAX_NUM_REF_PICS];
+		unsigned char use_delta_flag[HEVC_MAX_NUM_REF_PICS];
+
+		struct bspp_hevc_shortterm_refpicset *ref_strps = NULL;
+
+		if (in_slice_header) {
+			HEVC_SWSR_UE("delta_idx_minus1", (unsigned int *)&delta_idx_minus1, sr_ctx);
+			HEVC_RANGEUCHECK("delta_idx_minus1", delta_idx_minus1, 0, st_rps_idx - 1,
+					 &parse_err);
+		}
+
+		HEVC_SWSR_U1("delta_rps_sign", &delta_rps_sign, sr_ctx);
+		HEVC_SWSR_UE("abs_delta_rps_minus1", (unsigned int *)&abs_delta_rps_minus1, sr_ctx);
+		HEVC_RANGEUCHECK("abs_delta_rps_minus1", abs_delta_rps_minus1, 0, ((1 << 15) - 1),
+				 &parse_err);
+
+		ref_rps_idx = st_rps_idx - (delta_idx_minus1 + 1);
+		ref_strps = &st_refpicset[ref_rps_idx];
+
+		memset(use_delta_flag, 1, sizeof(use_delta_flag));
+
+		for (j_8 = 0; j_8 <= ref_strps->num_delta_pocs; ++j_8) {
+			HEVC_SWSR_U1("used_by_curr_pic_flag", &used_by_curr_pic_flag[j_8], sr_ctx);
+			if (!used_by_curr_pic_flag[j_8])
+				HEVC_SWSR_U1("use_delta_flag", &use_delta_flag[j_8], sr_ctx);
+		}
+
+		delta_rps =
+			(1 - 2 * delta_rps_sign) * (abs_delta_rps_minus1 + 1);
+
+		/*
+		 * predict delta POC values of current strps from
+		 * reference strps
+		 */
+		for (j = ref_strps->num_positive_pics - 1; j >= 0; --j) {
+			int dpoc = ref_strps->delta_poc_s1[j] + delta_rps;
+
+			if (dpoc < 0 && use_delta_flag[ref_strps->num_negative_pics + j]) {
+				strps->delta_poc_s0[i] = dpoc;
+				strps->used_bycurr_pic_s0[i++] =
+					used_by_curr_pic_flag[ref_strps->num_negative_pics + j];
+			}
+		}
+
+		if (delta_rps < 0 && use_delta_flag[ref_strps->num_delta_pocs]) {
+			strps->delta_poc_s0[i] = delta_rps;
+			strps->used_bycurr_pic_s0[i++] =
+				used_by_curr_pic_flag[ref_strps->num_delta_pocs];
+		}
+
+		for (j_8 = 0; j_8 < ref_strps->num_negative_pics; ++j_8) {
+			int dpoc = ref_strps->delta_poc_s0[j_8] + delta_rps;
+
+			if (dpoc < 0 && use_delta_flag[j_8]) {
+				strps->delta_poc_s0[i] = dpoc;
+				strps->used_bycurr_pic_s0[i++] = used_by_curr_pic_flag[j_8];
+			}
+		}
+
+		strps->num_negative_pics = i;
+
+		i = 0;
+		for (j = ref_strps->num_negative_pics - 1; j >= 0; --j) {
+			int dpoc = ref_strps->delta_poc_s0[j] + delta_rps;
+
+			if (dpoc > 0 && use_delta_flag[j]) {
+				strps->delta_poc_s1[i] = dpoc;
+				strps->used_bycurr_pic_s1[i++] =
+					used_by_curr_pic_flag[j];
+			}
+		}
+
+		if (delta_rps > 0 && use_delta_flag[ref_strps->num_delta_pocs]) {
+			strps->delta_poc_s1[i] = delta_rps;
+			strps->used_bycurr_pic_s1[i++] =
+				used_by_curr_pic_flag[ref_strps->num_delta_pocs];
+		}
+
+		for (j_8 = 0; j_8 < ref_strps->num_positive_pics; ++j_8) {
+			int dpoc = ref_strps->delta_poc_s1[j_8] + delta_rps;
+
+			if (dpoc > 0 && use_delta_flag[ref_strps->num_negative_pics + j_8]) {
+				strps->delta_poc_s1[i] = dpoc;
+				strps->used_bycurr_pic_s1[i++] =
+					used_by_curr_pic_flag[ref_strps->num_negative_pics + j_8];
+			}
+		}
+
+		strps->num_positive_pics = i;
+		strps->num_delta_pocs = strps->num_negative_pics + strps->num_positive_pics;
+		if (strps->num_delta_pocs > (HEVC_MAX_NUM_REF_PICS - 1)) {
+			strps->num_delta_pocs = HEVC_MAX_NUM_REF_PICS - 1;
+			parse_err |= BSPP_ERROR_CORRECTION_VALIDVALUE;
+		}
+	} else {
+		unsigned char num_negative_pics = 0;
+		unsigned char num_positive_pics = 0;
+		unsigned short delta_poc_s0_minus1[HEVC_MAX_NUM_REF_PICS];
+		unsigned char used_by_curr_pic_s0_flag[HEVC_MAX_NUM_REF_PICS];
+		unsigned short delta_poc_s1_minus1[HEVC_MAX_NUM_REF_PICS];
+		unsigned char used_by_curr_pic_s1_flag[HEVC_MAX_NUM_REF_PICS];
+		unsigned char j = 0;
+
+		HEVC_SWSR_UE("num_negative_pics", (unsigned int *)&num_negative_pics, sr_ctx);
+		if (num_negative_pics > HEVC_MAX_NUM_REF_PICS) {
+			num_negative_pics = HEVC_MAX_NUM_REF_PICS;
+			parse_err |= BSPP_ERROR_CORRECTION_VALIDVALUE;
+		}
+		HEVC_SWSR_UE("num_positive_pics", (unsigned int *)&num_positive_pics, sr_ctx);
+		if (num_positive_pics > HEVC_MAX_NUM_REF_PICS) {
+			num_positive_pics = HEVC_MAX_NUM_REF_PICS;
+			parse_err |= BSPP_ERROR_CORRECTION_VALIDVALUE;
+		}
+
+		for (j = 0; j < num_negative_pics; ++j) {
+			HEVC_SWSR_UE("delta_poc_s0_minus1",
+				     (unsigned int *)&delta_poc_s0_minus1[j], sr_ctx);
+			HEVC_RANGEUCHECK("delta_poc_s0_minus1", delta_poc_s0_minus1[j], 0,
+					 ((1 << 15) - 1), &parse_err);
+			HEVC_SWSR_U1("used_by_curr_pic_s0_flag",
+				     &used_by_curr_pic_s0_flag[j], sr_ctx);
+
+			if (j == 0)
+				strps->delta_poc_s0[j] =
+					-(delta_poc_s0_minus1[j] + 1);
+			else
+				strps->delta_poc_s0[j] = strps->delta_poc_s0[j - 1] -
+							(delta_poc_s0_minus1[j] + 1);
+
+			strps->used_bycurr_pic_s0[j] = used_by_curr_pic_s0_flag[j];
+		}
+
+		for (j = 0; j < num_positive_pics; j++) {
+			HEVC_SWSR_UE("delta_poc_s1_minus1",
+				     (unsigned int *)&delta_poc_s1_minus1[j], sr_ctx);
+			HEVC_RANGEUCHECK("delta_poc_s1_minus1", delta_poc_s1_minus1[j], 0,
+					 ((1 << 15) - 1), &parse_err);
+			HEVC_SWSR_U1("used_by_curr_pic_s1_flag",
+				     &used_by_curr_pic_s1_flag[j], sr_ctx);
+
+			if (j == 0)
+				strps->delta_poc_s1[j] =
+					(delta_poc_s1_minus1[j] + 1);
+			else
+				strps->delta_poc_s1[j] = strps->delta_poc_s1[j - 1] +
+							(delta_poc_s1_minus1[j] + 1);
+			strps->used_bycurr_pic_s1[j] = used_by_curr_pic_s1_flag[j];
+		}
+
+		strps->num_negative_pics = num_negative_pics;
+		strps->num_positive_pics = num_positive_pics;
+		strps->num_delta_pocs = strps->num_negative_pics + strps->num_positive_pics;
+		if (strps->num_delta_pocs > (HEVC_MAX_NUM_REF_PICS - 1)) {
+			strps->num_delta_pocs = HEVC_MAX_NUM_REF_PICS - 1;
+			parse_err |= BSPP_ERROR_CORRECTION_VALIDVALUE;
+		}
+	}
+
+	BSPP_HEVC_SYNTAX
+		("strps[%u]: num_delta_pocs: %u (%u (num_negative_pics) + %u (num_positive_pics))",
+		 st_rps_idx, strps->num_delta_pocs, strps->num_negative_pics,
+		 strps->num_positive_pics);
+
+	for (i = 0; i < strps->num_negative_pics; ++i) {
+		BSPP_HEVC_SYNTAX("StRps[%u][%u]: delta_poc_s0: %d, used_bycurr_pic_s0: %u",
+				 st_rps_idx, i, strps->delta_poc_s0[i],
+				 strps->used_bycurr_pic_s0[i]);
+	}
+
+	for (i = 0; i < strps->num_positive_pics; ++i) {
+		BSPP_HEVC_SYNTAX("StRps[%u][%u]: delta_poc_s1: %d, used_bycurr_pic_s1: %u",
+				 st_rps_idx, i, strps->delta_poc_s1[i],
+				 strps->used_bycurr_pic_s1[i]);
+	}
+
+	return parse_err;
+}
+
+static void bspp_hevc_fillcommonseqhdr(struct bspp_hevc_sps *sps,
+				       struct vdec_comsequ_hdrinfo *common_seq)
+{
+	struct bspp_hevc_vui_params *vui = &sps->vui_params;
+	unsigned char chroma_idc = sps->chroma_format_idc;
+	struct pixel_pixinfo *pixel_info = &common_seq->pixel_info;
+	unsigned int maxsub_layersmin1;
+	unsigned int maxdpb_size;
+	struct vdec_rect *rawdisp_region;
+
+	common_seq->codec_profile = sps->profile_tier_level.general_profile_idc;
+	common_seq->codec_level   = sps->profile_tier_level.general_level_idc;
+
+	if (sps->vui_parameters_present_flag &&
+	    vui->vui_timing_info_present_flag) {
+		common_seq->frame_rate_num = vui->vui_time_scale;
+		common_seq->frame_rate_den = vui->vui_num_units_in_tick;
+		common_seq->frame_rate =
+			1 * common_seq->frame_rate_num / common_seq->frame_rate_den;
+	}
+
+	if (vui->aspect_ratio_info_present_flag) {
+		common_seq->aspect_ratio_num = vui->sar_width;
+		common_seq->aspect_ratio_den = vui->sar_height;
+	}
+
+	common_seq->interlaced_frames = 0;
+
+	/* handle pixel format definitions */
+	pixel_info->chroma_fmt = chroma_idc == 0 ? 0 : 1;
+	pixel_info->chroma_fmt_idc = pixelformat_idc[chroma_idc];
+	pixel_info->chroma_interleave =
+		chroma_idc == 0 ? PIXEL_INVALID_CI : PIXEL_UV_ORDER;
+	pixel_info->bitdepth_y = sps->bit_depth_luma_minus8 + 8;
+	pixel_info->bitdepth_c = sps->bit_depth_chroma_minus8 + 8;
+
+	pixel_info->mem_pkg = (pixel_info->bitdepth_y > 8 ||
+		(pixel_info->bitdepth_c > 8 && pixel_info->chroma_fmt)) ?
+		PIXEL_BIT10_MSB_MP : PIXEL_BIT8_MP;
+	pixel_info->num_planes =
+		chroma_idc == 0 ? 1 : (sps->separate_colour_plane_flag ? 3 : 2);
+
+	pixel_info->pixfmt = pixel_get_pixfmt(pixel_info->chroma_fmt_idc,
+					      pixel_info->chroma_interleave,
+					      pixel_info->mem_pkg,
+					      pixel_info->bitdepth_y,
+					      pixel_info->chroma_fmt ?
+					      pixel_info->bitdepth_c : PIXEL_INVALID_BDC,
+					      pixel_info->num_planes);
+
+	common_seq->max_frame_size.width = sps->pic_width_in_ctbs_y * sps->ctb_size_y;
+	common_seq->max_frame_size.height = sps->pic_height_in_ctbs_y * sps->ctb_size_y;
+
+	common_seq->frame_size.width = sps->pic_width_in_luma_samples;
+	common_seq->frame_size.height = sps->pic_height_in_luma_samples;
+
+	/* Get HEVC max num ref pictures and pass to bspp info*/
+	vdecddutils_ref_pic_hevc_get_maxnum(common_seq, &common_seq->max_ref_frame_num);
+
+	common_seq->field_codec_mblocks = 0;
+
+	maxsub_layersmin1 = sps->sps_max_sub_layers_minus1;
+	maxdpb_size =
+		HEVC_MAX(sps->sps_max_dec_pic_buffering_minus1[maxsub_layersmin1] + 1,
+			 sps->sps_max_num_reorder_pics[maxsub_layersmin1], unsigned char);
+
+	if (sps->sps_max_latency_increase_plus1[maxsub_layersmin1]) {
+		maxdpb_size =
+			HEVC_MAX(maxdpb_size,
+				 sps->sps_max_latency_pictures[maxsub_layersmin1], unsigned int);
+	}
+
+	maxdpb_size = HEVC_MIN(maxdpb_size,
+			       HEVC_MAX_NUM_REF_IDX_ACTIVE + 1, unsigned int);
+
+	common_seq->min_pict_buf_num = HEVC_MAX(maxdpb_size, 6, unsigned int);
+
+	common_seq->picture_reordering = 1;
+	common_seq->post_processing = 0;
+
+	/* handle display region calculation */
+	rawdisp_region = &common_seq->raw_display_region;
+
+	rawdisp_region->width = sps->pic_width_in_luma_samples;
+	rawdisp_region->height = sps->pic_height_in_luma_samples;
+	rawdisp_region->top_offset = 0;
+	rawdisp_region->left_offset = 0;
+
+	if (sps->conformance_window_flag) {
+		struct vdec_rect *disp_region =
+			&common_seq->orig_display_region;
+
+		disp_region->top_offset =
+			sps->sub_height_c * sps->conf_win_top_offset;
+		disp_region->left_offset =
+			sps->sub_width_c * sps->conf_win_left_offset;
+		disp_region->width =
+			sps->pic_width_in_luma_samples -
+			disp_region->left_offset -
+			sps->sub_width_c * sps->conf_win_right_offset;
+		disp_region->height =
+			sps->pic_height_in_luma_samples -
+			disp_region->top_offset -
+			sps->sub_height_c * sps->conf_win_bottom_offset;
+	} else {
+		common_seq->orig_display_region =
+			common_seq->raw_display_region;
+	}
+}
+
+static void bspp_hevc_fillpicturehdr(struct vdec_comsequ_hdrinfo *common_seq,
+				     enum hevc_nalunittype nalunit_type,
+				     struct bspp_pict_hdr_info *picture_hdr,
+				     struct bspp_hevc_sps *sps,
+				     struct bspp_hevc_pps *pps,
+				     struct bspp_hevc_vps *vps)
+{
+	picture_hdr->intra_coded = (nalunit_type == HEVC_NALTYPE_IDR_W_RADL ||
+		nalunit_type == HEVC_NALTYPE_IDR_N_LP);
+	picture_hdr->field = 0;
+	picture_hdr->post_processing = 0;
+	picture_hdr->discontinuous_mbs = 0;
+	picture_hdr->pict_aux_data.id = BSPP_INVALID;
+	picture_hdr->second_pict_aux_data.id = BSPP_INVALID;
+	picture_hdr->pict_sgm_data.id = BSPP_INVALID;
+	picture_hdr->coded_frame_size.width =
+		HEVC_ALIGN(sps->pic_width_in_luma_samples, HEVC_MIN_CODED_UNIT_SIZE, unsigned int);
+	picture_hdr->coded_frame_size.height =
+		HEVC_ALIGN(sps->pic_height_in_luma_samples, HEVC_MIN_CODED_UNIT_SIZE, unsigned int);
+	picture_hdr->disp_info.enc_disp_region = common_seq->orig_display_region;
+	picture_hdr->disp_info.disp_region = common_seq->orig_display_region;
+	picture_hdr->disp_info.raw_disp_region = common_seq->raw_display_region;
+	picture_hdr->disp_info.num_pan_scan_windows = 0;
+	picture_hdr->hevc_pict_hdr_info.range_ext_present =
+			(sps->profile_tier_level.general_profile_idc == 4) ||
+			sps->profile_tier_level.general_profile_compatibility_flag[4];
+
+	picture_hdr->hevc_pict_hdr_info.is_full_range_ext = 0;
+	if (picture_hdr->hevc_pict_hdr_info.range_ext_present &&
+	    (bspp_hevc_checkppsrangeextensions(&pps->range_exts) ||
+	    bspp_hevc_checksps_range_extensions(&sps->range_exts)))
+		picture_hdr->hevc_pict_hdr_info.is_full_range_ext = 1;
+
+	memset(picture_hdr->disp_info.pan_scan_windows, 0,
+	       sizeof(picture_hdr->disp_info.pan_scan_windows));
+}
+
+static void bspp_hevc_fill_fwsps(struct bspp_hevc_sps *sps, struct hevcfw_sequence_ps *fwsps)
+{
+	unsigned char i;
+
+	fwsps->pic_width_in_luma_samples = sps->pic_width_in_luma_samples;
+	fwsps->pic_height_in_luma_samples = sps->pic_height_in_luma_samples;
+	fwsps->num_short_term_ref_pic_sets = sps->num_short_term_ref_pic_sets;
+	fwsps->num_long_term_ref_pics_sps = sps->num_long_term_ref_pics_sps;
+	fwsps->sps_max_sub_layers_minus1 = sps->sps_max_sub_layers_minus1;
+	fwsps->max_transform_hierarchy_depth_inter =
+				sps->max_transform_hierarchy_depth_inter;
+	fwsps->max_transform_hierarchy_depth_intra =
+				sps->max_transform_hierarchy_depth_intra;
+	fwsps->log2_diff_max_min_transform_block_size =
+				sps->log2_diff_max_min_transform_block_size;
+	fwsps->log2_min_transform_block_size_minus2 =
+				sps->log2_min_transform_block_size_minus2;
+	fwsps->log2_diff_max_min_luma_coding_block_size =
+				sps->log2_diff_max_min_luma_coding_block_size;
+	fwsps->log2_min_luma_coding_block_size_minus3 =
+				sps->log2_min_luma_coding_block_size_minus3;
+
+	HEVC_STATIC_ASSERT(sizeof(sps->sps_max_dec_pic_buffering_minus1) ==
+			   sizeof(fwsps->sps_max_dec_pic_buffering_minus1));
+	memcpy(fwsps->sps_max_dec_pic_buffering_minus1, sps->sps_max_dec_pic_buffering_minus1,
+	       sizeof(fwsps->sps_max_dec_pic_buffering_minus1[0]) *
+	       (sps->sps_max_sub_layers_minus1 + 1));
+
+	HEVC_STATIC_ASSERT(sizeof(sps->sps_max_num_reorder_pics) ==
+			   sizeof(fwsps->sps_max_num_reorder_pics));
+	memcpy(fwsps->sps_max_num_reorder_pics, sps->sps_max_num_reorder_pics,
+	       sizeof(fwsps->sps_max_num_reorder_pics[0]) *
+	       (sps->sps_max_sub_layers_minus1 + 1));
+
+	HEVC_STATIC_ASSERT(sizeof(sps->sps_max_latency_increase_plus1) ==
+			   sizeof(fwsps->sps_max_latency_increase_plus1));
+	memcpy(fwsps->sps_max_latency_increase_plus1, sps->sps_max_latency_increase_plus1,
+	       sizeof(fwsps->sps_max_latency_increase_plus1[0]) *
+	       (sps->sps_max_sub_layers_minus1 + 1));
+
+	fwsps->chroma_format_idc = sps->chroma_format_idc;
+	fwsps->separate_colour_plane_flag = sps->separate_colour_plane_flag;
+	fwsps->log2_max_pic_order_cnt_lsb_minus4 =
+		sps->log2_max_pic_order_cnt_lsb_minus4;
+	fwsps->long_term_ref_pics_present_flag =
+		sps->long_term_ref_pics_present_flag;
+	fwsps->sample_adaptive_offset_enabled_flag =
+		sps->sample_adaptive_offset_enabled_flag;
+	fwsps->sps_temporal_mvp_enabled_flag =
+		sps->sps_temporal_mvp_enabled_flag;
+	fwsps->bit_depth_luma_minus8 = sps->bit_depth_luma_minus8;
+	fwsps->bit_depth_chroma_minus8 = sps->bit_depth_chroma_minus8;
+	fwsps->pcm_sample_bit_depth_luma_minus1 =
+		sps->pcm_sample_bit_depth_luma_minus1;
+	fwsps->pcm_sample_bit_depth_chroma_minus1 =
+		sps->pcm_sample_bit_depth_chroma_minus1;
+	fwsps->log2_min_pcm_luma_coding_block_size_minus3 =
+		sps->log2_min_pcm_luma_coding_block_size_minus3;
+	fwsps->log2_diff_max_min_pcm_luma_coding_block_size =
+		sps->log2_diff_max_min_pcm_luma_coding_block_size;
+	fwsps->pcm_loop_filter_disabled_flag =
+		sps->pcm_loop_filter_disabled_flag;
+	fwsps->amp_enabled_flag = sps->amp_enabled_flag;
+	fwsps->pcm_enabled_flag = sps->pcm_enabled_flag;
+	fwsps->strong_intra_smoothing_enabled_flag =
+		sps->strong_intra_smoothing_enabled_flag;
+	fwsps->scaling_list_enabled_flag = sps->scaling_list_enabled_flag;
+	fwsps->transform_skip_rotation_enabled_flag =
+		sps->range_exts.transform_skip_rotation_enabled_flag;
+	fwsps->transform_skip_context_enabled_flag =
+		sps->range_exts.transform_skip_context_enabled_flag;
+	fwsps->implicit_rdpcm_enabled_flag =
+		sps->range_exts.implicit_rdpcm_enabled_flag;
+	fwsps->explicit_rdpcm_enabled_flag =
+		sps->range_exts.explicit_rdpcm_enabled_flag;
+	fwsps->extended_precision_processing_flag =
+		sps->range_exts.extended_precision_processing_flag;
+	fwsps->intra_smoothing_disabled_flag =
+		sps->range_exts.intra_smoothing_disabled_flag;
+	/* high precision makes no sense for 8 bit luma & chroma,
+	 * so forward this parameter only when bitdepth > 8
+	 */
+	if (sps->bit_depth_luma_minus8 || sps->bit_depth_chroma_minus8)
+		fwsps->high_precision_offsets_enabled_flag =
+			sps->range_exts.high_precision_offsets_enabled_flag;
+
+	fwsps->persistent_rice_adaptation_enabled_flag =
+		sps->range_exts.persistent_rice_adaptation_enabled_flag;
+	fwsps->cabac_bypass_alignment_enabled_flag =
+		sps->range_exts.cabac_bypass_alignment_enabled_flag;
+
+	HEVC_STATIC_ASSERT(sizeof(sps->lt_ref_pic_poc_lsb_sps) ==
+			   sizeof(fwsps->lt_ref_pic_poc_lsb_sps));
+	HEVC_STATIC_ASSERT(sizeof(sps->used_by_curr_pic_lt_sps_flag) ==
+			   sizeof(fwsps->used_by_curr_pic_lt_sps_flag));
+	memcpy(fwsps->lt_ref_pic_poc_lsb_sps, sps->lt_ref_pic_poc_lsb_sps,
+	       sizeof(fwsps->lt_ref_pic_poc_lsb_sps[0]) *
+		sps->num_long_term_ref_pics_sps);
+	memcpy(fwsps->used_by_curr_pic_lt_sps_flag, sps->used_by_curr_pic_lt_sps_flag,
+	       sizeof(fwsps->used_by_curr_pic_lt_sps_flag[0]) * sps->num_long_term_ref_pics_sps);
+
+	for (i = 0; i < sps->num_short_term_ref_pic_sets; ++i)
+		bspp_hevc_fill_fwst_rps(&sps->rps_list[i], &fwsps->st_rps_list[i]);
+
+	/* derived elements */
+	fwsps->pic_size_in_ctbs_y = sps->pic_size_in_ctbs_y;
+	fwsps->pic_height_in_ctbs_y = sps->pic_height_in_ctbs_y;
+	fwsps->pic_width_in_ctbs_y = sps->pic_width_in_ctbs_y;
+	fwsps->ctb_size_y = sps->ctb_size_y;
+	fwsps->ctb_log2size_y = sps->ctb_log2size_y;
+	fwsps->max_pic_order_cnt_lsb = sps->max_pic_order_cnt_lsb;
+
+	HEVC_STATIC_ASSERT(sizeof(sps->sps_max_latency_pictures) ==
+			   sizeof(fwsps->sps_max_latency_pictures));
+	memcpy(fwsps->sps_max_latency_pictures, sps->sps_max_latency_pictures,
+	       sizeof(fwsps->sps_max_latency_pictures[0]) *
+	      (sps->sps_max_sub_layers_minus1 + 1));
+}
+
+static void bspp_hevc_fill_fwst_rps(struct bspp_hevc_shortterm_refpicset *strps,
+				    struct hevcfw_short_term_ref_picset *fwstrps)
+{
+	fwstrps->num_delta_pocs = strps->num_delta_pocs;
+	fwstrps->num_negative_pics = strps->num_negative_pics;
+	fwstrps->num_positive_pics = strps->num_positive_pics;
+
+	HEVC_STATIC_ASSERT(sizeof(strps->delta_poc_s0) ==
+			   sizeof(fwstrps->delta_poc_s0));
+	memcpy(fwstrps->delta_poc_s0, strps->delta_poc_s0,
+	       sizeof(fwstrps->delta_poc_s0[0]) * strps->num_negative_pics);
+
+	HEVC_STATIC_ASSERT(sizeof(strps->delta_poc_s1) ==
+			   sizeof(fwstrps->delta_poc_s1));
+	memcpy(fwstrps->delta_poc_s1, strps->delta_poc_s1,
+	       sizeof(fwstrps->delta_poc_s1[0]) * strps->num_positive_pics);
+
+	HEVC_STATIC_ASSERT(sizeof(strps->used_bycurr_pic_s0) ==
+			   sizeof(fwstrps->used_bycurr_pic_s0));
+	memcpy(fwstrps->used_bycurr_pic_s0, strps->used_bycurr_pic_s0,
+	       sizeof(fwstrps->used_bycurr_pic_s0[0]) * strps->num_negative_pics);
+
+	HEVC_STATIC_ASSERT(sizeof(strps->used_bycurr_pic_s1) ==
+			   sizeof(fwstrps->used_bycurr_pic_s1));
+	memcpy(fwstrps->used_bycurr_pic_s1, strps->used_bycurr_pic_s1,
+	       sizeof(fwstrps->used_bycurr_pic_s1[0]) * strps->num_positive_pics);
+}
+
+static void bspp_hevc_fill_fwpps(struct bspp_hevc_pps *pps, struct hevcfw_picture_ps *fw_pps)
+{
+	fw_pps->pps_pic_parameter_set_id = pps->pps_pic_parameter_set_id;
+	fw_pps->num_tile_columns_minus1 = pps->num_tile_columns_minus1;
+	fw_pps->num_tile_rows_minus1 = pps->num_tile_rows_minus1;
+	fw_pps->diff_cu_qp_delta_depth = pps->diff_cu_qp_delta_depth;
+	fw_pps->init_qp_minus26 = pps->init_qp_minus26;
+	fw_pps->pps_beta_offset_div2 = pps->pps_beta_offset_div2;
+	fw_pps->pps_tc_offset_div2 = pps->pps_tc_offset_div2;
+	fw_pps->pps_cb_qp_offset = pps->pps_cb_qp_offset;
+	fw_pps->pps_cr_qp_offset = pps->pps_cr_qp_offset;
+	fw_pps->log2_parallel_merge_level_minus2 =
+		pps->log2_parallel_merge_level_minus2;
+
+	fw_pps->dependent_slice_segments_enabled_flag =
+		pps->dependent_slice_segments_enabled_flag;
+	fw_pps->output_flag_present_flag = pps->output_flag_present_flag;
+	fw_pps->num_extra_slice_header_bits = pps->num_extra_slice_header_bits;
+	fw_pps->lists_modification_present_flag =
+		pps->lists_modification_present_flag;
+	fw_pps->cabac_init_present_flag = pps->cabac_init_present_flag;
+	fw_pps->weighted_pred_flag = pps->weighted_pred_flag;
+	fw_pps->weighted_bipred_flag = pps->weighted_bipred_flag;
+	fw_pps->pps_slice_chroma_qp_offsets_present_flag =
+		pps->pps_slice_chroma_qp_offsets_present_flag;
+	fw_pps->deblocking_filter_override_enabled_flag =
+		pps->deblocking_filter_override_enabled_flag;
+	fw_pps->tiles_enabled_flag = pps->tiles_enabled_flag;
+	fw_pps->entropy_coding_sync_enabled_flag =
+		pps->entropy_coding_sync_enabled_flag;
+	fw_pps->slice_segment_header_extension_present_flag =
+		pps->slice_segment_header_extension_present_flag;
+	fw_pps->transquant_bypass_enabled_flag =
+		pps->transquant_bypass_enabled_flag;
+	fw_pps->cu_qp_delta_enabled_flag = pps->cu_qp_delta_enabled_flag;
+	fw_pps->transform_skip_enabled_flag = pps->transform_skip_enabled_flag;
+	fw_pps->sign_data_hiding_enabled_flag =
+		pps->sign_data_hiding_enabled_flag;
+	fw_pps->num_ref_idx_l0_default_active_minus1 =
+		pps->num_ref_idx_l0_default_active_minus1;
+	fw_pps->num_ref_idx_l1_default_active_minus1 =
+		pps->num_ref_idx_l1_default_active_minus1;
+	fw_pps->constrained_intra_pred_flag =  pps->constrained_intra_pred_flag;
+	fw_pps->pps_deblocking_filter_disabled_flag =
+		pps->pps_deblocking_filter_disabled_flag;
+	fw_pps->pps_loop_filter_across_slices_enabled_flag =
+		pps->pps_loop_filter_across_slices_enabled_flag;
+	fw_pps->loop_filter_across_tiles_enabled_flag =
+		pps->loop_filter_across_tiles_enabled_flag;
+	fw_pps->log2_max_transform_skip_block_size_minus2 =
+		pps->range_exts.log2_max_transform_skip_block_size_minus2;
+	fw_pps->cross_component_prediction_enabled_flag =
+		pps->range_exts.cross_component_prediction_enabled_flag;
+	fw_pps->chroma_qp_offset_list_enabled_flag =
+		pps->range_exts.chroma_qp_offset_list_enabled_flag;
+	fw_pps->diff_cu_chroma_qp_offset_depth =
+		pps->range_exts.diff_cu_chroma_qp_offset_depth;
+	fw_pps->chroma_qp_offset_list_len_minus1 =
+		pps->range_exts.chroma_qp_offset_list_len_minus1;
+	memcpy(fw_pps->cb_qp_offset_list, pps->range_exts.cb_qp_offset_list,
+	       sizeof(pps->range_exts.cb_qp_offset_list));
+	memcpy(fw_pps->cr_qp_offset_list, pps->range_exts.cr_qp_offset_list,
+	       sizeof(pps->range_exts.cr_qp_offset_list));
+
+	/* derived elements */
+	HEVC_STATIC_ASSERT(sizeof(pps->col_bd) == sizeof(fw_pps->col_bd));
+	HEVC_STATIC_ASSERT(sizeof(pps->row_bd) == sizeof(fw_pps->row_bd));
+	memcpy(fw_pps->col_bd, pps->col_bd, sizeof(fw_pps->col_bd));
+	memcpy(fw_pps->row_bd, pps->row_bd, sizeof(fw_pps->row_bd));
+}
+
+static void bspp_hevc_fill_fw_scaling_lists(struct bspp_hevc_pps *pps,
+					    struct bspp_hevc_sps *sps,
+					    struct hevcfw_picture_ps *fw_pps)
+{
+	signed char size_id, matrix_id;
+	unsigned char *scalinglist;
+	/*
+	 * We are starting at 1 to leave space for addresses,
+	 * filled by lower layer
+	 */
+	unsigned int *scaling_lists = &fw_pps->scaling_lists[1];
+	unsigned char i;
+
+	struct bspp_hevc_scalinglist_data *scaling_listdata =
+		pps->pps_scaling_list_data_present_flag ?
+		&pps->scaling_list :
+		&sps->scalinglist_data;
+
+	if (!sps->scaling_list_enabled_flag)
+		return;
+
+	fw_pps->scaling_list_enabled_flag = sps->scaling_list_enabled_flag;
+
+	for (size_id = HEVC_SCALING_LIST_NUM_SIZES - 1;
+		size_id >= 0; --size_id) {
+		const unsigned char *zz =
+			(size_id == 0 ? HEVC_INV_ZZ_SCAN4 : HEVC_INV_ZZ_SCAN8);
+
+		for (matrix_id = 0; matrix_id < ((size_id == 3) ? 2 : 6);
+			++matrix_id) {
+			/*
+			 * Select scaling list on which we will operate
+			 * in the iteration
+			 */
+			scalinglist =
+				scaling_listdata->lists[size_id][matrix_id];
+
+			for (i = 0; i < ((size_id == 0) ? 16 : 64); i += 4) {
+				*scaling_lists =
+					scalinglist[zz[i + 3]] << 24 |
+					scalinglist[zz[i + 2]] << 16 |
+					scalinglist[zz[i + 1]] << 8 |
+					scalinglist[zz[i]];
+				scaling_lists += 2;
+			}
+		}
+	}
+
+	for (i = 0; i < 2; ++i) {
+		*scaling_lists = scaling_listdata->dccoeffs[1][i];
+		scaling_lists += 2;
+	}
+
+	for (i = 0; i < 6; ++i) {
+		*scaling_lists = scaling_listdata->dccoeffs[0][i];
+		scaling_lists += 2;
+	}
+}
+
+static unsigned int bspp_ceil_log2(unsigned int linear_val)
+{
+	unsigned int log_val = 0;
+
+	if (linear_val > 0)
+		--linear_val;
+
+	while (linear_val > 0) {
+		linear_val >>= 1;
+		++log_val;
+	}
+
+	return log_val;
+}
+
+static unsigned char bspp_hevc_picture_is_irap(enum hevc_nalunittype nalunit_type)
+{
+	return (nalunit_type >= HEVC_NALTYPE_BLA_W_LP) &&
+	       (nalunit_type <= HEVC_NALTYPE_RSV_IRAP_VCL23);
+}
+
+static unsigned char bspp_hevc_picture_is_cra(enum hevc_nalunittype nalunit_type)
+{
+	return (nalunit_type == HEVC_NALTYPE_CRA);
+}
+
+static unsigned char bspp_hevc_picture_is_idr(enum hevc_nalunittype nalunit_type)
+{
+	return (nalunit_type == HEVC_NALTYPE_IDR_N_LP) ||
+	       (nalunit_type == HEVC_NALTYPE_IDR_W_RADL);
+}
+
+static unsigned char bspp_hevc_picture_is_bla(enum hevc_nalunittype nalunit_type)
+{
+	return (nalunit_type >= HEVC_NALTYPE_BLA_W_LP) &&
+	       (nalunit_type <= HEVC_NALTYPE_BLA_N_LP);
+}
+
+static unsigned char bspp_hevc_picture_getnorasl_outputflag
+					(enum hevc_nalunittype nalunit_type,
+					 struct bspp_hevc_inter_pict_ctx *inter_pict_ctx)
+{
+	VDEC_ASSERT(inter_pict_ctx);
+
+	if (bspp_hevc_picture_is_idr(nalunit_type) ||
+	    bspp_hevc_picture_is_bla(nalunit_type) ||
+	    inter_pict_ctx->first_after_eos ||
+	    (bspp_hevc_picture_is_cra(nalunit_type) && inter_pict_ctx->seq_pic_count == 1))
+		return 1;
+
+	return 0;
+}
+
+static unsigned char bspp_hevc_range_extensions_is_enabled
+				(struct bspp_hevc_profile_tierlevel *profile_tierlevel)
+{
+	unsigned char is_enabled;
+
+	is_enabled = profile_tierlevel->general_profile_idc >= 4 ||
+		profile_tierlevel->general_profile_compatibility_flag[4];
+
+	return is_enabled;
+}
+
+static void bspp_hevc_parse_codec_config(void *hndl_swsr_ctx, unsigned int *unit_count,
+					 unsigned int *unit_array_count,
+					 unsigned int *delim_length,
+					 unsigned int *size_delim_length)
+{
+	unsigned long long value = 23;
+
+	/*
+	 * Set the shift-register up to provide next 23 bytes
+	 * without emulation prevention detection.
+	 */
+	swsr_consume_delim(hndl_swsr_ctx, SWSR_EMPREVENT_NONE, 0, &value);
+	/*
+	 * Codec config header must be read for size delimited data (HEVC)
+	 * to get to the start of each unit.
+	 * This parsing follows section 8.3.3.1.2 of ISO/IEC 14496-15:2013.
+	 */
+	swsr_read_bits(hndl_swsr_ctx, 8 * 4);
+	swsr_read_bits(hndl_swsr_ctx, 8 * 4);
+	swsr_read_bits(hndl_swsr_ctx, 8 * 4);
+	swsr_read_bits(hndl_swsr_ctx, 8 * 4);
+	swsr_read_bits(hndl_swsr_ctx, 8 * 4);
+	swsr_read_bits(hndl_swsr_ctx, 8);
+
+	*delim_length = ((swsr_read_bits(hndl_swsr_ctx, 8) & 0x3) + 1) * 8;
+	*unit_array_count = swsr_read_bits(hndl_swsr_ctx, 8);
+
+	/* Size delimiter is only 2 bytes for HEVC codec configuration. */
+	*size_delim_length = 2 * 8;
+}
+
+static void bspp_hevc_update_unitcounts(void *hndl_swsr_ctx, unsigned int *unit_count,
+					unsigned int *unit_array_count)
+{
+	if (*unit_array_count != 0) {
+		unsigned long long value = 3;
+
+		if (*unit_count == 0) {
+			/*
+			 * Set the shift-register up to provide next 3 bytes
+			 * without emulation prevention detection.
+			 */
+			swsr_consume_delim(hndl_swsr_ctx, SWSR_EMPREVENT_NONE, 0, &value);
+
+			swsr_read_bits(hndl_swsr_ctx, 8);
+			*unit_count = swsr_read_bits(hndl_swsr_ctx, 16);
+
+			(*unit_array_count)--;
+			(*unit_count)--;
+		}
+	}
+}
+
+void bspp_hevc_determine_unittype(unsigned char bitstream_unittype,
+				  int disable_mvc,
+				  enum bspp_unit_type *bspp_unittype)
+{
+	/* 6 bits for NAL Unit Type in HEVC */
+	unsigned char type = (bitstream_unittype >> 1) & 0x3f;
+
+	switch (type) {
+	case HEVC_NALTYPE_VPS:
+		*bspp_unittype = BSPP_UNIT_VPS;
+		break;
+
+	case HEVC_NALTYPE_SPS:
+		*bspp_unittype = BSPP_UNIT_SEQUENCE;
+		break;
+
+	case HEVC_NALTYPE_PPS:
+		*bspp_unittype = BSPP_UNIT_PPS;
+		break;
+
+	case HEVC_NALTYPE_TRAIL_N:
+	case HEVC_NALTYPE_TRAIL_R:
+	case HEVC_NALTYPE_TSA_N:
+	case HEVC_NALTYPE_TSA_R:
+	case HEVC_NALTYPE_STSA_N:
+	case HEVC_NALTYPE_STSA_R:
+	case HEVC_NALTYPE_RADL_N:
+	case HEVC_NALTYPE_RADL_R:
+	case HEVC_NALTYPE_RASL_N:
+	case HEVC_NALTYPE_RASL_R:
+	case HEVC_NALTYPE_BLA_W_LP:
+	case HEVC_NALTYPE_BLA_W_RADL:
+	case HEVC_NALTYPE_BLA_N_LP:
+	case HEVC_NALTYPE_IDR_W_RADL:
+	case HEVC_NALTYPE_IDR_N_LP:
+	case HEVC_NALTYPE_CRA:
+	case HEVC_NALTYPE_EOS:
+		/* Attach EOS to picture data, so it can be detected in FW */
+		*bspp_unittype = BSPP_UNIT_PICTURE;
+		break;
+
+	case HEVC_NALTYPE_AUD:
+	case HEVC_NALTYPE_PREFIX_SEI:
+	case HEVC_NALTYPE_SUFFIX_SEI:
+	case HEVC_NALTYPE_EOB:
+	case HEVC_NALTYPE_FD:
+		*bspp_unittype = BSPP_UNIT_NON_PICTURE;
+		break;
+
+	default:
+		*bspp_unittype = BSPP_UNIT_UNSUPPORTED;
+		break;
+	}
+}
+
+int bspp_hevc_set_parser_config(enum vdec_bstr_format bstr_format,
+				struct bspp_vid_std_features *pvidstd_features,
+				struct bspp_swsr_ctx *pswsr_ctx,
+				struct bspp_parser_callbacks *parser_callbacks,
+				struct bspp_inter_pict_data *pinterpict_data)
+{
+	/* set HEVC parser callbacks. */
+	parser_callbacks->parse_unit_cb         = bspp_hevc_unitparser;
+	parser_callbacks->release_data_cb       = bspp_hevc_releasedata;
+	parser_callbacks->reset_data_cb         = bspp_hevc_resetdata;
+	parser_callbacks->parse_codec_config_cb = bspp_hevc_parse_codec_config;
+	parser_callbacks->update_unit_counts_cb = bspp_hevc_update_unitcounts;
+	parser_callbacks->initialise_parsing_cb = bspp_hevc_initialiseparsing;
+	parser_callbacks->finalise_parsing_cb   = bspp_hevc_finaliseparsing;
+
+	/* Set HEVC specific features. */
+	pvidstd_features->seq_size = sizeof(struct bspp_hevc_sequ_hdr_info);
+	pvidstd_features->uses_vps  = 1;
+	pvidstd_features->vps_size = sizeof(struct bspp_hevc_vps);
+	pvidstd_features->uses_pps  = 1;
+	pvidstd_features->pps_size = sizeof(struct bspp_hevc_pps);
+
+	/* Set HEVC specific shift register config. */
+	pswsr_ctx->emulation_prevention = SWSR_EMPREVENT_00000300;
+
+	if (bstr_format == VDEC_BSTRFORMAT_DEMUX_BYTESTREAM ||
+	    bstr_format == VDEC_BSTRFORMAT_ELEMENTARY) {
+		pswsr_ctx->sr_config.delim_type = SWSR_DELIM_SCP;
+		pswsr_ctx->sr_config.delim_length = 3 * 8;
+		pswsr_ctx->sr_config.scp_value = 0x000001;
+	} else if (bstr_format == VDEC_BSTRFORMAT_DEMUX_SIZEDELIMITED) {
+		pswsr_ctx->sr_config.delim_type = SWSR_DELIM_SIZE;
+		pswsr_ctx->sr_config.delim_length = 4 * 8;
+	} else {
+		return IMG_ERROR_NOT_SUPPORTED;
+	}
+
+	return 0;
+}
diff --git a/drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.h b/drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.h
new file mode 100644
index 000000000000..b53d9fa4ce80
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/hevc_secure_parser.h
@@ -0,0 +1,445 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * h.264 secure data unit parsing API.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+#ifndef __HEVCSECUREPARSER_H__
+#define __HEVCSECUREPARSER_H__
+
+#include "bspp_int.h"
+
+#define HEVC_MAX_NUM_PROFILE_IDC        (32)
+#define HEVC_MAX_NUM_SUBLAYERS          (7)
+#define HEVC_MAX_VPS_OP_SETS_PLUS1      (1024)
+#define HEVC_MAX_VPS_NUH_RESERVED_ZERO_LAYER_ID_PLUS1   (1)
+#define HEVC_MAX_NUM_REF_PICS           (16)
+#define HEVC_MAX_NUM_ST_REF_PIC_SETS    (65)
+#define HEVC_MAX_NUM_LT_REF_PICS        (32)
+#define HEVC_MAX_NUM_REF_IDX_ACTIVE     (15)
+#define HEVC_LEVEL_IDC_MIN              (30)
+#define HEVC_LEVEL_IDC_MAX              (186)
+#define HEVC_1_0_PROFILE_IDC_MAX        (3)
+#define HEVC_MAX_CPB_COUNT              (32)
+#define HEVC_MIN_CODED_UNIT_SIZE        (8)
+
+/* hevc scaling lists (all values are maximum possible ones) */
+#define HEVC_SCALING_LIST_NUM_SIZES     (4)
+#define HEVC_SCALING_LIST_NUM_MATRICES  (6)
+#define HEVC_SCALING_LIST_MATRIX_SIZE   (64)
+
+#define HEVC_MAX_TILE_COLS              (20)
+#define HEVC_MAX_TILE_ROWS              (22)
+
+#define HEVC_EXTENDED_SAR               (255)
+
+#define HEVC_MAX_CHROMA_QP              (6)
+
+enum hevc_nalunittype {
+	HEVC_NALTYPE_TRAIL_N        = 0,
+	HEVC_NALTYPE_TRAIL_R        = 1,
+	HEVC_NALTYPE_TSA_N          = 2,
+	HEVC_NALTYPE_TSA_R          = 3,
+	HEVC_NALTYPE_STSA_N         = 4,
+	HEVC_NALTYPE_STSA_R         = 5,
+	HEVC_NALTYPE_RADL_N         = 6,
+	HEVC_NALTYPE_RADL_R         = 7,
+	HEVC_NALTYPE_RASL_N         = 8,
+	HEVC_NALTYPE_RASL_R         = 9,
+	HEVC_NALTYPE_RSV_VCL_N10    = 10,
+	HEVC_NALTYPE_RSV_VCL_R11    = 11,
+	HEVC_NALTYPE_RSV_VCL_N12    = 12,
+	HEVC_NALTYPE_RSV_VCL_R13    = 13,
+	HEVC_NALTYPE_RSV_VCL_N14    = 14,
+	HEVC_NALTYPE_RSV_VCL_R15    = 15,
+	HEVC_NALTYPE_BLA_W_LP       = 16,
+	HEVC_NALTYPE_BLA_W_RADL     = 17,
+	HEVC_NALTYPE_BLA_N_LP       = 18,
+	HEVC_NALTYPE_IDR_W_RADL     = 19,
+	HEVC_NALTYPE_IDR_N_LP       = 20,
+	HEVC_NALTYPE_CRA            = 21,
+	HEVC_NALTYPE_RSV_IRAP_VCL22 = 22,
+	HEVC_NALTYPE_RSV_IRAP_VCL23 = 23,
+	HEVC_NALTYPE_VPS            = 32,
+	HEVC_NALTYPE_SPS            = 33,
+	HEVC_NALTYPE_PPS            = 34,
+	HEVC_NALTYPE_AUD            = 35,
+	HEVC_NALTYPE_EOS            = 36,
+	HEVC_NALTYPE_EOB            = 37,
+	HEVC_NALTYPE_FD             = 38,
+	HEVC_NALTYPE_PREFIX_SEI     = 39,
+	HEVC_NALTYPE_SUFFIX_SEI     = 40,
+	HEVC_NALTYPE_FORCE32BITS    = 0x7FFFFFFFU
+};
+
+enum bspp_hevcslicetype {
+	HEVC_SLICE_B           = 0,
+	HEVC_SLICE_P           = 1,
+	HEVC_SLICE_I           = 2,
+	HEVC_SLICE_FORCE32BITS = 0x7FFFFFFFU
+};
+
+/* HEVC NAL unit header */
+struct bspp_hevcnalheader {
+	unsigned char nal_unit_type;
+	unsigned char nuh_layer_id;
+	unsigned char nuh_temporal_id_plus1;
+};
+
+/* HEVC video profile_tier_level */
+struct bspp_hevc_profile_tierlevel {
+	unsigned char general_profile_space;
+	unsigned char general_tier_flag;
+	unsigned char general_profile_idc;
+	unsigned char general_profile_compatibility_flag[HEVC_MAX_NUM_PROFILE_IDC];
+	unsigned char general_progressive_source_flag;
+	unsigned char general_interlaced_source_flag;
+	unsigned char general_non_packed_constraint_flag;
+	unsigned char general_frame_only_constraint_flag;
+	unsigned char general_max_12bit_constraint_flag;
+	unsigned char general_max_10bit_constraint_flag;
+	unsigned char general_max_8bit_constraint_flag;
+	unsigned char general_max_422chroma_constraint_flag;
+	unsigned char general_max_420chroma_constraint_flag;
+	unsigned char general_max_monochrome_constraint_flag;
+	unsigned char general_intra_constraint_flag;
+	unsigned char general_one_picture_only_constraint_flag;
+	unsigned char general_lower_bit_rate_constraint_flag;
+	unsigned char general_level_idc;
+	unsigned char sub_layer_profile_present_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_level_present_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_profile_space[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_tier_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_profile_idc[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_profile_compatibility_flag[HEVC_MAX_NUM_SUBLAYERS -
+						   1][HEVC_MAX_NUM_PROFILE_IDC];
+	unsigned char sub_layer_progressive_source_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_interlaced_source_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_non_packed_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_frame_only_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_12bit_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_10bit_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_8bit_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_422chroma_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_420chroma_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_monochrome_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_intra_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_one_picture_only_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_lower_bit_rate_constraint_flag[HEVC_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_level_idc[HEVC_MAX_NUM_SUBLAYERS - 1];
+};
+
+/* HEVC sub layer HRD parameters */
+struct bspp_hevc_sublayer_hrd_parameters {
+	unsigned char bit_rate_value_minus1[HEVC_MAX_CPB_COUNT];
+	unsigned char cpb_size_value_minus1[HEVC_MAX_CPB_COUNT];
+	unsigned char cpb_size_du_value_minus1[HEVC_MAX_CPB_COUNT];
+	unsigned char bit_rate_du_value_minus1[HEVC_MAX_CPB_COUNT];
+	unsigned char cbr_flag[HEVC_MAX_CPB_COUNT];
+};
+
+/* HEVC HRD parameters */
+struct bspp_hevc_hrd_parameters {
+	unsigned char nal_hrd_parameters_present_flag;
+	unsigned char vcl_hrd_parameters_present_flag;
+	unsigned char sub_pic_hrd_params_present_flag;
+	unsigned char tick_divisor_minus2;
+	unsigned char du_cpb_removal_delay_increment_length_minus1;
+	unsigned char sub_pic_cpb_params_in_pic_timing_sei_flag;
+	unsigned char dpb_output_delay_du_length_minus1;
+	unsigned char bit_rate_scale;
+	unsigned char cpb_size_scale;
+	unsigned char cpb_size_du_scale;
+	unsigned char initial_cpb_removal_delay_length_minus1;
+	unsigned char au_cpb_removal_delay_length_minus1;
+	unsigned char dpb_output_delay_length_minus1;
+	unsigned char fixed_pic_rate_general_flag[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char fixed_pic_rate_within_cvs_flag[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char elemental_duration_in_tc_minus1[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char low_delay_hrd_flag[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char cpb_cnt_minus1[HEVC_MAX_NUM_SUBLAYERS];
+	struct bspp_hevc_sublayer_hrd_parameters sublayhrdparams[HEVC_MAX_NUM_SUBLAYERS];
+};
+
+/* HEVC video parameter set */
+struct bspp_hevc_vps {
+	unsigned char is_different;
+	unsigned char is_sent;
+	unsigned char is_available;
+	unsigned char vps_video_parameter_set_id;
+	unsigned char vps_reserved_three_2bits;
+	unsigned char vps_max_layers_minus1;
+	unsigned char vps_max_sub_layers_minus1;
+	unsigned char vps_temporal_id_nesting_flag;
+	unsigned short vps_reserved_0xffff_16bits;
+	struct bspp_hevc_profile_tierlevel profiletierlevel;
+	unsigned char vps_max_dec_pic_buffering_minus1[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char vps_max_num_reorder_pics[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char vps_max_latency_increase_plus1[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char vps_sub_layer_ordering_info_present_flag;
+	unsigned char vps_max_layer_id;
+	unsigned char vps_num_layer_sets_minus1;
+	unsigned char layer_id_included_flag[HEVC_MAX_VPS_OP_SETS_PLUS1]
+		[HEVC_MAX_VPS_NUH_RESERVED_ZERO_LAYER_ID_PLUS1];
+	unsigned char vps_timing_info_present_flag;
+	unsigned int vps_num_units_in_tick;
+	unsigned int vps_time_scale;
+	unsigned char vps_poc_proportional_to_timing_flag;
+	unsigned char vps_num_ticks_poc_diff_one_minus1;
+	unsigned char vps_num_hrd_parameters;
+	unsigned char *hrd_layer_set_idx;
+	unsigned char *cprms_present_flag;
+	unsigned char vps_extension_flag;
+	unsigned char vps_extension_data_flag;
+};
+
+/* HEVC scaling lists */
+struct bspp_hevc_scalinglist_data {
+	unsigned char dccoeffs[HEVC_SCALING_LIST_NUM_SIZES - 2][HEVC_SCALING_LIST_NUM_MATRICES];
+	unsigned char lists[HEVC_SCALING_LIST_NUM_SIZES][HEVC_SCALING_LIST_NUM_MATRICES]
+		[HEVC_SCALING_LIST_MATRIX_SIZE];
+};
+
+/* HEVC short term reference picture set */
+struct bspp_hevc_shortterm_refpicset {
+	unsigned char num_negative_pics;
+	unsigned char num_positive_pics;
+	short delta_poc_s0[HEVC_MAX_NUM_REF_PICS];
+	short delta_poc_s1[HEVC_MAX_NUM_REF_PICS];
+	unsigned char used_bycurr_pic_s0[HEVC_MAX_NUM_REF_PICS];
+	unsigned char used_bycurr_pic_s1[HEVC_MAX_NUM_REF_PICS];
+	unsigned char num_delta_pocs;
+};
+
+/* HEVC video usability information */
+struct bspp_hevc_vui_params {
+	unsigned char aspect_ratio_info_present_flag;
+	unsigned char aspect_ratio_idc;
+	unsigned short sar_width;
+	unsigned short sar_height;
+	unsigned char overscan_info_present_flag;
+	unsigned char overscan_appropriate_flag;
+	unsigned char video_signal_type_present_flag;
+	unsigned char video_format;
+	unsigned char video_full_range_flag;
+	unsigned char colour_description_present_flag;
+	unsigned char colour_primaries;
+	unsigned char transfer_characteristics;
+	unsigned char matrix_coeffs;
+	unsigned char chroma_loc_info_present_flag;
+	unsigned char chroma_sample_loc_type_top_field;
+	unsigned char chroma_sample_loc_type_bottom_field;
+	unsigned char neutral_chroma_indication_flag;
+	unsigned char field_seq_flag;
+	unsigned char frame_field_info_present_flag;
+	unsigned char default_display_window_flag;
+	unsigned short def_disp_win_left_offset;
+	unsigned short def_disp_win_right_offset;
+	unsigned short def_disp_win_top_offset;
+	unsigned short def_disp_win_bottom_offset;
+	unsigned char vui_timing_info_present_flag;
+	unsigned int vui_num_units_in_tick;
+	unsigned int vui_time_scale;
+	unsigned char vui_poc_proportional_to_timing_flag;
+	unsigned int vui_num_ticks_poc_diff_one_minus1;
+	unsigned char vui_hrd_parameters_present_flag;
+	struct bspp_hevc_hrd_parameters vui_hrd_params;
+	unsigned char bitstream_restriction_flag;
+	unsigned char tiles_fixed_structure_flag;
+	unsigned char motion_vectors_over_pic_boundaries_flag;
+	unsigned char restricted_ref_pic_lists_flag;
+	unsigned short min_spatial_segmentation_idc;
+	unsigned char max_bytes_per_pic_denom;
+	unsigned char max_bits_per_min_cu_denom;
+	unsigned char log2_max_mv_length_horizontal;
+	unsigned char log2_max_mv_length_vertical;
+};
+
+/* HEVC sps range extensions */
+struct bspp_hevc_sps_range_exts {
+	unsigned char transform_skip_rotation_enabled_flag;
+	unsigned char transform_skip_context_enabled_flag;
+	unsigned char implicit_rdpcm_enabled_flag;
+	unsigned char explicit_rdpcm_enabled_flag;
+	unsigned char extended_precision_processing_flag;
+	unsigned char intra_smoothing_disabled_flag;
+	unsigned char high_precision_offsets_enabled_flag;
+	unsigned char persistent_rice_adaptation_enabled_flag;
+	unsigned char cabac_bypass_alignment_enabled_flag;
+};
+
+/* HEVC sequence parameter set */
+struct bspp_hevc_sps {
+	unsigned char is_different;
+	unsigned char is_sent;
+	unsigned char is_available;
+	unsigned char sps_video_parameter_set_id;
+	unsigned char sps_max_sub_layers_minus1;
+	unsigned char sps_temporal_id_nesting_flag;
+	struct bspp_hevc_profile_tierlevel profile_tier_level;
+	unsigned char sps_seq_parameter_set_id;
+	unsigned char chroma_format_idc;
+	unsigned char separate_colour_plane_flag;
+	unsigned int pic_width_in_luma_samples;
+	unsigned int pic_height_in_luma_samples;
+	unsigned char conformance_window_flag;
+	unsigned short conf_win_left_offset;
+	unsigned short conf_win_right_offset;
+	unsigned short conf_win_top_offset;
+	unsigned short conf_win_bottom_offset;
+	unsigned char bit_depth_luma_minus8;
+	unsigned char bit_depth_chroma_minus8;
+	unsigned char log2_max_pic_order_cnt_lsb_minus4;
+	unsigned char sps_sub_layer_ordering_info_present_flag;
+	unsigned char sps_max_dec_pic_buffering_minus1[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char sps_max_num_reorder_pics[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned int sps_max_latency_increase_plus1[HEVC_MAX_NUM_SUBLAYERS];
+	unsigned char log2_min_luma_coding_block_size_minus3;
+	unsigned char log2_diff_max_min_luma_coding_block_size;
+	unsigned char log2_min_transform_block_size_minus2;
+	unsigned char log2_diff_max_min_transform_block_size;
+	unsigned char max_transform_hierarchy_depth_inter;
+	unsigned char max_transform_hierarchy_depth_intra;
+	unsigned char scaling_list_enabled_flag;
+	unsigned char sps_scaling_list_data_present_flag;
+	struct bspp_hevc_scalinglist_data scalinglist_data;
+	unsigned char amp_enabled_flag;
+	unsigned char sample_adaptive_offset_enabled_flag;
+	unsigned char pcm_enabled_flag;
+	unsigned char pcm_sample_bit_depth_luma_minus1;
+	unsigned char pcm_sample_bit_depth_chroma_minus1;
+	unsigned char log2_min_pcm_luma_coding_block_size_minus3;
+	unsigned char log2_diff_max_min_pcm_luma_coding_block_size;
+	unsigned char pcm_loop_filter_disabled_flag;
+	unsigned char num_short_term_ref_pic_sets;
+	struct bspp_hevc_shortterm_refpicset rps_list[HEVC_MAX_NUM_ST_REF_PIC_SETS];
+	unsigned char long_term_ref_pics_present_flag;
+	unsigned char num_long_term_ref_pics_sps;
+	unsigned short lt_ref_pic_poc_lsb_sps[HEVC_MAX_NUM_LT_REF_PICS];
+	unsigned char used_by_curr_pic_lt_sps_flag[HEVC_MAX_NUM_LT_REF_PICS];
+	unsigned char sps_temporal_mvp_enabled_flag;
+	unsigned char strong_intra_smoothing_enabled_flag;
+	unsigned char vui_parameters_present_flag;
+	struct bspp_hevc_vui_params vui_params;
+	unsigned char sps_extension_present_flag;
+	unsigned char sps_range_extensions_flag;
+	struct bspp_hevc_sps_range_exts range_exts;
+	unsigned char sps_extension_7bits;
+	unsigned char sps_extension_data_flag;
+	/* derived elements */
+	unsigned char sub_width_c;
+	unsigned char sub_height_c;
+	unsigned char ctb_log2size_y;
+	unsigned char ctb_size_y;
+	unsigned int pic_width_in_ctbs_y;
+	unsigned int pic_height_in_ctbs_y;
+	unsigned int pic_size_in_ctbs_y;
+	int max_pic_order_cnt_lsb;
+	unsigned int sps_max_latency_pictures[HEVC_MAX_NUM_SUBLAYERS];
+	/* raw vui data as extracted from bitstream. */
+	struct bspp_raw_bitstream_data *vui_raw_data;
+};
+
+/*
+ * This structure contains HEVC sequence header information (VPS, SPS, VUI)
+ * contains everything parsed from the video/sequence header.
+ */
+struct bspp_hevc_sequ_hdr_info {
+	struct bspp_hevc_vps vps;
+	struct bspp_hevc_sps sps;
+};
+
+/* HEVC pps range extensions */
+struct bspp_hevc_pps_range_exts {
+	unsigned char log2_max_transform_skip_block_size_minus2;
+	unsigned char cross_component_prediction_enabled_flag;
+	unsigned char chroma_qp_offset_list_enabled_flag;
+	unsigned char diff_cu_chroma_qp_offset_depth;
+	unsigned char chroma_qp_offset_list_len_minus1;
+	unsigned char cb_qp_offset_list[HEVC_MAX_CHROMA_QP];
+	unsigned char cr_qp_offset_list[HEVC_MAX_CHROMA_QP];
+	unsigned char log2_sao_offset_scale_luma;
+	unsigned char log2_sao_offset_scale_chroma;
+};
+
+/* HEVC picture parameter set */
+struct bspp_hevc_pps {
+	unsigned char is_available;
+	unsigned char is_param_copied;
+	unsigned char pps_pic_parameter_set_id;
+	unsigned char pps_seq_parameter_set_id;
+	unsigned char dependent_slice_segments_enabled_flag;
+	unsigned char output_flag_present_flag;
+	unsigned char num_extra_slice_header_bits;
+	unsigned char sign_data_hiding_enabled_flag;
+	unsigned char cabac_init_present_flag;
+	unsigned char num_ref_idx_l0_default_active_minus1;
+	unsigned char num_ref_idx_l1_default_active_minus1;
+	unsigned char init_qp_minus26;
+	unsigned char constrained_intra_pred_flag;
+	unsigned char transform_skip_enabled_flag;
+	unsigned char cu_qp_delta_enabled_flag;
+	unsigned char diff_cu_qp_delta_depth;
+	int pps_cb_qp_offset;
+	int pps_cr_qp_offset;
+	unsigned char pps_slice_chroma_qp_offsets_present_flag;
+	unsigned char weighted_pred_flag;
+	unsigned char weighted_bipred_flag;
+	unsigned char transquant_bypass_enabled_flag;
+	unsigned char tiles_enabled_flag;
+	unsigned char entropy_coding_sync_enabled_flag;
+	unsigned char num_tile_columns_minus1;
+	unsigned char num_tile_rows_minus1;
+	unsigned char uniform_spacing_flag;
+	unsigned char column_width_minus1[HEVC_MAX_TILE_COLS];
+	unsigned char row_height_minus1[HEVC_MAX_TILE_ROWS];
+	unsigned char loop_filter_across_tiles_enabled_flag;
+	unsigned char pps_loop_filter_across_slices_enabled_flag;
+	unsigned char deblocking_filter_control_present_flag;
+	unsigned char deblocking_filter_override_enabled_flag;
+	unsigned char pps_deblocking_filter_disabled_flag;
+	unsigned char pps_beta_offset_div2;
+	unsigned char pps_tc_offset_div2;
+	unsigned char pps_scaling_list_data_present_flag;
+	struct bspp_hevc_scalinglist_data scaling_list;
+	unsigned char lists_modification_present_flag;
+	unsigned char log2_parallel_merge_level_minus2;
+	unsigned char slice_segment_header_extension_present_flag;
+	unsigned char pps_extension_present_flag;
+	unsigned char pps_range_extensions_flag;
+	struct bspp_hevc_pps_range_exts range_exts;
+	unsigned char pps_extension_7bits;
+	unsigned char pps_extension_data_flag;
+	/* derived elements */
+	unsigned short col_bd[HEVC_MAX_TILE_COLS + 1];
+	unsigned short row_bd[HEVC_MAX_TILE_ROWS + 1];
+	/* PVDEC derived elements */
+	unsigned int max_tile_height_in_ctbs_y;
+};
+
+/* HEVC slice segment header */
+struct bspp_hevc_slice_segment_header {
+	unsigned char bslice_is_idr;
+	unsigned char first_slice_segment_in_pic_flag;
+	unsigned char no_output_of_prior_pics_flag;
+	unsigned char slice_pic_parameter_set_id;
+	unsigned char dependent_slice_segment_flag;
+	unsigned int slice_segment_address;
+};
+
+/*
+ * @Function   bspp_hevc_set_parser_config
+ * sets the parser configuration.
+ */
+int bspp_hevc_set_parser_config(enum vdec_bstr_format bstr_format,
+				struct bspp_vid_std_features *pvidstd_features,
+				struct bspp_swsr_ctx *pswsr_ctx,
+				struct bspp_parser_callbacks *pparser_callbacks,
+				struct bspp_inter_pict_data *pinterpict_data);
+
+void bspp_hevc_determine_unittype(unsigned char bitstream_unittype,
+				  int disable_mvc,
+				  enum bspp_unit_type *bspp_unittype);
+
+#endif /*__H264SECUREPARSER_H__ */
diff --git a/drivers/media/platform/vxe-vxd/decoder/hevcfw_data.h b/drivers/media/platform/vxe-vxd/decoder/hevcfw_data.h
new file mode 100644
index 000000000000..022661737eb1
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/hevcfw_data.h
@@ -0,0 +1,469 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Public data structures for the hevc parser firmware module.
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+/* Include shared header version here to replace the standard version. */
+#include "hevcfw_data_shared.h"
+
+#ifndef _HEVCFW_DATA_H_
+#define _HEVCFW_DATA_H_
+
+#include "vdecfw_shared.h"
+
+#define HEVC_MAX_VPS_COUNT              16
+#define HEVC_MAX_SPS_COUNT              16
+#define HEVC_MAX_PPS_COUNT              64
+
+#define HEVCFW_MAX_NUM_PROFILE_IDC 32
+#define HEVCFW_MAX_VPS_OP_SETS_PLUS1 1024
+#define HEVCFW_MAX_VPS_NUH_RESERVED_ZERO_LAYER_ID_PLUS1 1
+
+#define HEVCFW_MAX_NUM_REF_PICS 16
+#define HEVCFW_MAX_NUM_ST_REF_PIC_SETS 65
+#define HEVCFW_MAX_NUM_LT_REF_PICS 32
+#define HEVCFW_MAX_NUM_SUBLAYERS 7
+#define HEVCFW_SCALING_LISTS_BUFSIZE 256
+#define HEVCFW_MAX_TILE_COLS 20
+#define HEVCFW_MAX_TILE_ROWS 22
+
+#define HEVCFW_MAX_CHROMA_QP 6
+
+#define HEVCFW_MAX_DPB_SIZE HEVCFW_MAX_NUM_REF_PICS
+#define HEVCFW_REF_PIC_LIST0 0
+#define HEVCFW_REF_PIC_LIST1 1
+#define HEVCFW_NUM_REF_PIC_LISTS 2
+#define HEVCFW_NUM_DPB_DIFF_REGS 4
+
+/* non-critical errors */
+#define HEVC_ERR_INVALID_VALUE (20)
+#define HEVC_ERR_CORRECTION_VALIDVALUE (21)
+
+#define HEVC_IS_ERR_CRITICAL(err) \
+	((err) > HEVC_ERR_CORRECTION_VALIDVALUE ? 1 : 0)
+
+/* critical errors */
+#define HEVC_ERR_INV_VIDEO_DIMENSION (22)
+#define HEVC_ERR_NO_SEQUENCE_HDR (23)
+#define HEVC_ERR_SPS_EXT_UNSUPP (24 | VDECFW_UNSUPPORTED_CODE_BASE)
+#define HEVC_ERR_PPS_EXT_UNSUPP (25 | VDECFW_UNSUPPORTED_CODE_BASE)
+
+#define HEVC_ERR_FAILED_TO_STORE_VPS (100)
+#define HEVC_ERR_FAILED_TO_STORE_SPS (101)
+#define HEVC_ERR_FAILED_TO_STORE_PPS (102)
+
+#define HEVC_ERR_FAILED_TO_FETCH_VPS (103)
+#define HEVC_ERR_FAILED_TO_FETCH_SPS (104)
+#define HEVC_ERR_FAILED_TO_FETCH_PPS (105)
+/* HEVC Scaling Lists (all values are maximum possible ones) */
+#define HEVCFW_SCALING_LIST_NUM_SIZES 4
+#define HEVCFW_SCALING_LIST_NUM_MATRICES 6
+#define HEVCFW_SCALING_LIST_MATRIX_SIZE 64
+
+struct hevcfw_scaling_listdata {
+	unsigned char dc_coeffs
+	[HEVCFW_SCALING_LIST_NUM_SIZES - 2]
+	[HEVCFW_SCALING_LIST_NUM_MATRICES];
+	unsigned char lists
+	[HEVCFW_SCALING_LIST_NUM_SIZES]
+	[HEVCFW_SCALING_LIST_NUM_MATRICES]
+	[HEVCFW_SCALING_LIST_MATRIX_SIZE];
+};
+
+/* HEVC Video Profile_Tier_Level */
+struct hevcfw_profile_tier_level {
+	unsigned char general_profile_space;
+	unsigned char general_tier_flag;
+	unsigned char general_profile_idc;
+	unsigned char general_profile_compatibility_flag[HEVCFW_MAX_NUM_PROFILE_IDC];
+	unsigned char general_progressive_source_flag;
+	unsigned char general_interlaced_source_flag;
+	unsigned char general_non_packed_constraint_flag;
+	unsigned char general_frame_only_constraint_flag;
+	unsigned char general_max_12bit_constraint_flag;
+	unsigned char general_max_10bit_constraint_flag;
+	unsigned char general_max_8bit_constraint_flag;
+	unsigned char general_max_422chroma_constraint_flag;
+	unsigned char general_max_420chroma_constraint_flag;
+	unsigned char general_max_monochrome_constraint_flag;
+	unsigned char general_intra_constraint_flag;
+	unsigned char general_one_picture_only_constraint_flag;
+	unsigned char general_lower_bit_rate_constraint_flag;
+	unsigned char general_level_idc;
+	unsigned char sub_layer_profile_present_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_level_present_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_profile_space[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_tier_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_profile_idc[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_profile_compatibility_flag[HEVCFW_MAX_NUM_SUBLAYERS -
+						   1][HEVCFW_MAX_NUM_PROFILE_IDC];
+	unsigned char sub_layer_progressive_source_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_interlaced_source_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_non_packed_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_frame_only_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_12bit_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_10bit_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_8bit_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_422chroma_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_420chroma_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_max_monochrome_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_intra_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_one_picture_only_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_lower_bit_rate_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+	unsigned char sub_layer_level_idc[HEVCFW_MAX_NUM_SUBLAYERS - 1];
+};
+
+struct hevcfw_video_ps {
+	int is_different;
+	int is_sent;
+	int is_available;
+	unsigned char vps_video_parameter_set_id;
+	unsigned char vps_reserved_three_2bits;
+	unsigned char vps_max_layers_minus1;
+	unsigned char vps_max_sub_layers_minus1;
+	unsigned char vps_temporal_id_nesting_flag;
+	unsigned short vps_reserved_0xffff_16bits;
+	struct hevcfw_profile_tier_level profile_tier_level;
+};
+
+/* HEVC Video Usability Information */
+struct hevcfw_vui_params {
+	unsigned char aspect_ratio_info_present_flag;
+	unsigned char aspect_ratio_idc;
+	unsigned short sar_width;
+	unsigned short sar_height;
+	unsigned char overscan_info_present_flag;
+	unsigned char overscan_appropriate_flag;
+	unsigned char video_signal_type_present_flag;
+	unsigned char video_format;
+	unsigned char video_full_range_flag;
+	unsigned char colour_description_present_flag;
+	unsigned char colour_primaries;
+	unsigned char transfer_characteristics;
+	unsigned char matrix_coeffs;
+	unsigned char chroma_loc_info_present_flag;
+	unsigned char chroma_sample_loc_type_top_field;
+	unsigned char chroma_sample_loc_type_bottom_field;
+	unsigned char neutral_chroma_indication_flag;
+	unsigned char field_seq_flag;
+	unsigned char frame_field_info_present_flag;
+	unsigned char default_display_window_flag;
+	unsigned short def_disp_win_left_offset;
+	unsigned short def_disp_win_right_offset;
+	unsigned short def_disp_win_top_offset;
+	unsigned short def_disp_win_bottom_offset;
+	unsigned char vui_timing_info_present_flag;
+	unsigned int vui_num_units_in_tick;
+	unsigned int vui_time_scale;
+};
+
+/* HEVC Short Term Reference Picture Set */
+struct hevcfw_short_term_ref_picset {
+	unsigned char num_negative_pics;
+	unsigned char num_positive_pics;
+	short delta_poc_s0[HEVCFW_MAX_NUM_REF_PICS];
+	short delta_poc_s1[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char used_bycurr_pic_s0[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char used_bycurr_pic_s1[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char num_delta_pocs;
+};
+
+/*
+ * This describes the SPS header data required by the HEVC firmware that should
+ * be supplied by the Host.
+ */
+struct hevcfw_sequence_ps {
+	/* syntax elements from SPS */
+	unsigned short pic_width_in_luma_samples;
+	unsigned short pic_height_in_luma_samples;
+	unsigned char num_short_term_ref_pic_sets;
+	unsigned char num_long_term_ref_pics_sps;
+	unsigned short lt_ref_pic_poc_lsb_sps[HEVCFW_MAX_NUM_LT_REF_PICS];
+	unsigned char used_by_curr_pic_lt_sps_flag[HEVCFW_MAX_NUM_LT_REF_PICS];
+	struct hevcfw_short_term_ref_picset st_rps_list[HEVCFW_MAX_NUM_ST_REF_PIC_SETS];
+	unsigned char sps_max_sub_layers_minus1;
+	unsigned char sps_max_dec_pic_buffering_minus1[HEVCFW_MAX_NUM_SUBLAYERS];
+	unsigned char sps_max_num_reorder_pics[HEVCFW_MAX_NUM_SUBLAYERS];
+	unsigned int sps_max_latency_increase_plus1[HEVCFW_MAX_NUM_SUBLAYERS];
+	unsigned char max_transform_hierarchy_depth_inter;
+	unsigned char max_transform_hierarchy_depth_intra;
+	unsigned char log2_diff_max_min_transform_block_size;
+	unsigned char log2_min_transform_block_size_minus2;
+	unsigned char log2_diff_max_min_luma_coding_block_size;
+	unsigned char log2_min_luma_coding_block_size_minus3;
+	unsigned char chroma_format_idc;
+	unsigned char separate_colour_plane_flag;
+	unsigned char num_extra_slice_header_bits;
+	unsigned char log2_max_pic_order_cnt_lsb_minus4;
+	unsigned char long_term_ref_pics_present_flag;
+	unsigned char sample_adaptive_offset_enabled_flag;
+	unsigned char sps_temporal_mvp_enabled_flag;
+	unsigned char bit_depth_luma_minus8;
+	unsigned char bit_depth_chroma_minus8;
+	unsigned char pcm_sample_bit_depth_luma_minus1;
+	unsigned char pcm_sample_bit_depth_chroma_minus1;
+	unsigned char log2_min_pcm_luma_coding_block_size_minus3;
+	unsigned char log2_diff_max_min_pcm_luma_coding_block_size;
+	unsigned char pcm_loop_filter_disabled_flag;
+	unsigned char amp_enabled_flag;
+	unsigned char pcm_enabled_flag;
+	unsigned char strong_intra_smoothing_enabled_flag;
+	unsigned char scaling_list_enabled_flag;
+	unsigned char transform_skip_rotation_enabled_flag;
+	unsigned char transform_skip_context_enabled_flag;
+	unsigned char implicit_rdpcm_enabled_flag;
+	unsigned char explicit_rdpcm_enabled_flag;
+	unsigned char extended_precision_processing_flag;
+	unsigned char intra_smoothing_disabled_flag;
+	unsigned char high_precision_offsets_enabled_flag;
+	unsigned char persistent_rice_adaptation_enabled_flag;
+	unsigned char cabac_bypass_alignment_enabled_flag;
+	/* derived elements */
+	unsigned int pic_size_in_ctbs_y;
+	unsigned short pic_height_in_ctbs_y;
+	unsigned short pic_width_in_ctbs_y;
+	unsigned char ctb_size_y;
+	unsigned char ctb_log2size_y;
+	int max_pic_order_cnt_lsb;
+	unsigned int sps_max_latency_pictures[HEVCFW_MAX_NUM_SUBLAYERS];
+	unsigned char pps_seq_parameter_set_id;
+	unsigned char sps_video_parameter_set_id;
+	unsigned char sps_temporal_id_nesting_flag;
+	unsigned char sps_seq_parameter_set_id;
+	/* local */
+	unsigned char conformance_window_flag;
+	unsigned short conf_win_left_offset;
+	unsigned short conf_win_right_offset;
+	unsigned short conf_win_top_offset;
+	unsigned short conf_win_bottom_offset;
+	unsigned char sps_sub_layer_ordering_info_present_flag;
+	unsigned char sps_scaling_list_data_present_flag;
+	unsigned char vui_parameters_present_flag;
+	unsigned char sps_extension_present_flag;
+	struct hevcfw_vui_params vui_params;
+	/* derived elements */
+	unsigned char sub_width_c;
+	unsigned char sub_height_c;
+	struct hevcfw_profile_tier_level profile_tier_level;
+	struct hevcfw_scaling_listdata scaling_listdata;
+};
+
+/*
+ * This describes the HEVC parser component "Header data", shown in the
+ * Firmware Memory Layout diagram. This data is required by the HEVC firmware
+ * and should be supplied by the Host.
+ */
+struct hevcfw_headerdata {
+	/* Decode buffers and output control for the current picture */
+	/* Primary decode buffer base addresses */
+	struct vdecfw_image_buffer primary;
+	/* buffer base addresses for alternate output */
+	struct vdecfw_image_buffer alternate;
+	/* address of buffer for temporal mv params */
+	unsigned int temporal_outaddr;
+};
+
+/*
+ * This describes the PPS header data required by the HEVC firmware that should
+ * be supplied by the Host.
+ */
+struct hevcfw_picture_ps {
+	/* syntax elements from the PPS */
+	unsigned char pps_pic_parameter_set_id;
+	unsigned char num_tile_columns_minus1;
+	unsigned char num_tile_rows_minus1;
+	unsigned char diff_cu_qp_delta_depth;
+	unsigned char init_qp_minus26;
+	unsigned char pps_beta_offset_div2;
+	unsigned char pps_tc_offset_div2;
+	unsigned char pps_cb_qp_offset;
+	unsigned char pps_cr_qp_offset;
+	unsigned char log2_parallel_merge_level_minus2;
+	unsigned char dependent_slice_segments_enabled_flag;
+	unsigned char output_flag_present_flag;
+	unsigned char num_extra_slice_header_bits;
+	unsigned char lists_modification_present_flag;
+	unsigned char cabac_init_present_flag;
+	unsigned char weighted_pred_flag;
+	unsigned char weighted_bipred_flag;
+	unsigned char pps_slice_chroma_qp_offsets_present_flag;
+	unsigned char deblocking_filter_override_enabled_flag;
+	unsigned char tiles_enabled_flag;
+	unsigned char entropy_coding_sync_enabled_flag;
+	unsigned char slice_segment_header_extension_present_flag;
+	unsigned char transquant_bypass_enabled_flag;
+	unsigned char cu_qp_delta_enabled_flag;
+	unsigned char transform_skip_enabled_flag;
+	unsigned char sign_data_hiding_enabled_flag;
+	unsigned char num_ref_idx_l0_default_active_minus1;
+	unsigned char num_ref_idx_l1_default_active_minus1;
+	unsigned char constrained_intra_pred_flag;
+	unsigned char pps_deblocking_filter_disabled_flag;
+	unsigned char pps_loop_filter_across_slices_enabled_flag;
+	unsigned char loop_filter_across_tiles_enabled_flag;
+	/* rewritten from SPS, maybe at some point we could get rid of this */
+	unsigned char scaling_list_enabled_flag;
+	unsigned char log2_max_transform_skip_block_size_minus2;
+	unsigned char cross_component_prediction_enabled_flag;
+	unsigned char chroma_qp_offset_list_enabled_flag;
+	unsigned char diff_cu_chroma_qp_offset_depth;
+	/*
+	 * PVDEC derived elements. HEVCFW_SCALING_LISTS_BUFSIZE is
+	 * multiplied by 2 to ensure that there will be space for address of
+	 * each element. These addresses are completed in lower layer.
+	 */
+	unsigned int scaling_lists[HEVCFW_SCALING_LISTS_BUFSIZE * 2];
+	/* derived elements */
+	unsigned short col_bd[HEVCFW_MAX_TILE_COLS + 1];
+	unsigned short row_bd[HEVCFW_MAX_TILE_ROWS + 1];
+
+	unsigned char chroma_qp_offset_list_len_minus1;
+	unsigned char cb_qp_offset_list[HEVCFW_MAX_CHROMA_QP];
+	unsigned char cr_qp_offset_list[HEVCFW_MAX_CHROMA_QP];
+
+	unsigned char uniform_spacing_flag;
+	unsigned char column_width_minus1[HEVCFW_MAX_TILE_COLS];
+	unsigned char row_height_minus1[HEVCFW_MAX_TILE_ROWS];
+
+	unsigned char pps_seq_parameter_set_id;
+	unsigned char deblocking_filter_control_present_flag;
+	unsigned char pps_scaling_list_data_present_flag;
+	unsigned char pps_extension_present_flag;
+
+	struct hevcfw_scaling_listdata scaling_list;
+};
+
+/* This enum determines reference picture status */
+enum hevcfw_reference_type {
+	HEVCFW_REF_UNUSED      = 0,
+	HEVCFW_REF_SHORTTERM,
+	HEVCFW_REF_LONGTERM,
+	HEVCFW_REF_FORCE32BITS = 0x7FFFFFFFU
+};
+
+/* This describes an HEVC picture. It is part of the Context data */
+struct hevcfw_picture {
+	/* Primary (reconstructed) picture buffers */
+	struct vdecfw_image_buffer primary;
+	/* Secondary (alternative) picture buffers */
+	struct vdecfw_image_buffer alternate;
+	/* Unique ID for this picture */
+	unsigned int transaction_id;
+	/* nut of first ssh of picture, determines picture type */
+	unsigned char nalunit_type;
+	/* Picture Order Count (frame number) */
+	int pic_order_cnt_val;
+	/* Slice Picture Order Count Lsb */
+	int slice_pic_ordercnt_lsb;
+	unsigned char pic_output_flag;
+	/* information about long-term pictures */
+	unsigned short dpb_longterm_flags;
+	unsigned int dpb_pic_order_diff[HEVCFW_NUM_DPB_DIFF_REGS];
+	/* address of buffer for temporal mv params */
+	unsigned int temporal_outaddr;
+	/* worst case Dpb diff for the current pic */
+	unsigned int dpb_diff;
+};
+
+/*
+ * This is a wrapper for a picture to hold it in a Decoded Picture Buffer
+ * for further reference
+ */
+struct hevcfw_picture_in_dpb {
+	/* DPB data about the picture */
+	enum hevcfw_reference_type ref_type;
+	unsigned char valid;
+	unsigned char needed_for_output;
+	unsigned char pic_latency_count;
+	/* Picture itself */
+	struct hevcfw_picture picture;
+};
+
+/*
+ * This describes an HEVC's Decoded Picture Buffer (DPB).
+ * It is part of the Context data
+ */
+#define HEVCFW_DPB_IDX_INVALID  -1
+
+struct hevcfw_decoded_picture_buffer {
+	/* reference pictures */
+	struct hevcfw_picture_in_dpb pictures[HEVCFW_MAX_DPB_SIZE];
+	/* organizational data of DPB */
+	unsigned int fullness;
+};
+
+/*
+ * This describes an HEVC's Reference Picture Set (RPS).
+ * It is part of the Context data
+ */
+struct hevcfw_reference_picture_set {
+	/* sizes of poc lists */
+	unsigned char num_pocst_curr_before;
+	unsigned char num_pocst_curr_after;
+	unsigned char num_pocst_foll;
+	unsigned char num_poclt_curr;
+	unsigned char num_poclt_foll;
+	/* poc lists */
+	int pocst_curr_before[HEVCFW_MAX_NUM_REF_PICS];
+	int pocst_curr_after[HEVCFW_MAX_NUM_REF_PICS];
+	int pocst_foll[HEVCFW_MAX_NUM_REF_PICS];
+	int poclt_curr[HEVCFW_MAX_NUM_REF_PICS];
+	int poclt_foll[HEVCFW_MAX_NUM_REF_PICS];
+	/* derived elements */
+	unsigned char curr_delta_pocmsb_presentflag[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char foll_delta_pocmsb_presentflag[HEVCFW_MAX_NUM_REF_PICS];
+	/* reference picture sets: indices in DPB */
+	unsigned char ref_picsetlt_curr[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char ref_picsetlt_foll[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char ref_picsetst_curr_before[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char ref_picsetst_curr_after[HEVCFW_MAX_NUM_REF_PICS];
+	unsigned char ref_picsetst_foll[HEVCFW_MAX_NUM_REF_PICS];
+};
+
+/*
+ * This describes the HEVC parser component "Context data", shown in the
+ * Firmware Memory Layout diagram. This data is the state preserved across
+ * pictures. It is loaded and saved by the Firmware, but requires the host to
+ * provide buffer(s) for this.
+ */
+struct hevcfw_ctx_data {
+	struct hevcfw_sequence_ps sps;
+	struct hevcfw_picture_ps pps;
+	/*
+	 * data from last picture with TemporalId = 0 that is not a RASL, RADL
+	 * or sub-layer non-reference picture
+	 */
+	int prev_pic_order_cnt_lsb;
+	int prev_pic_order_cnt_msb;
+	unsigned char last_irapnorasl_output_flag;
+	/*
+	 * Decoded Pictures Buffer holds information about decoded pictures
+	 * needed for further INTER decoding
+	 */
+	struct hevcfw_decoded_picture_buffer dpb;
+	/* Reference Picture Set is determined on per-picture basis */
+	struct hevcfw_reference_picture_set rps;
+	/*
+	 * Reference Picture List is determined using data from Reference
+	 * Picture Set and from Slice (Segment) Header on per-slice basis
+	 */
+	unsigned char ref_pic_list[HEVCFW_NUM_REF_PIC_LISTS][HEVCFW_MAX_NUM_REF_PICS];
+	/*
+	 * Reference Picture List used to send reflist to the host, the only
+	 * difference is that missing references are marked
+	 * with HEVCFW_DPB_IDX_INVALID
+	 */
+	unsigned char ref_pic_listhlp[HEVCFW_NUM_REF_PIC_LISTS][HEVCFW_MAX_NUM_REF_PICS];
+
+	unsigned int pic_count;
+	unsigned int slice_segment_count;
+	/* There was EOS NAL detected and no new picture yet */
+	int eos_detected;
+	/* This is first picture after EOS NAL */
+	int first_after_eos;
+};
+
+#endif /* _HEVCFW_DATA_H_ */
diff --git a/drivers/media/platform/vxe-vxd/decoder/hevcfw_data_shared.h b/drivers/media/platform/vxe-vxd/decoder/hevcfw_data_shared.h
new file mode 100644
index 000000000000..cc27015cadb1
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/hevcfw_data_shared.h
@@ -0,0 +1,761 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Public data structures for the hevc parser firmware module
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+#ifdef USE_SHARING
+#endif
+
+#ifndef _HEVCFW_DATA_H_
+#define _HEVCFW_DATA_H_
+
+#include "vdecfw_share.h"
+#include "vdecfw_shared.h"
+
+#define HEVC_MAX_VPS_COUNT 16
+#define HEVC_MAX_SPS_COUNT 16
+#define HEVC_MAX_PPS_COUNT 64
+
+#define HEVCFW_MAX_NUM_PROFILE_IDC 32
+#define HEVCFW_MAX_VPS_OP_SETS_PLUS1 1024
+#define HEVCFW_MAX_VPS_NUH_RESERVED_ZERO_LAYER_ID_PLUS1 1
+
+#define HEVCFW_MAX_NUM_REF_PICS 16
+#define HEVCFW_MAX_NUM_ST_REF_PIC_SETS 65
+#define HEVCFW_MAX_NUM_LT_REF_PICS 32
+#define HEVCFW_MAX_NUM_SUBLAYERS 7
+#define HEVCFW_SCALING_LISTS_BUFSIZE 256
+#define HEVCFW_MAX_TILE_COLS 20
+#define HEVCFW_MAX_TILE_ROWS 22
+
+#define HEVCFW_MAX_CHROMA_QP 6
+
+#define HEVCFW_MAX_DPB_SIZE HEVCFW_MAX_NUM_REF_PICS
+#define HEVCFW_REF_PIC_LIST0 0
+#define HEVCFW_REF_PIC_LIST1 1
+#define HEVCFW_NUM_REF_PIC_LISTS 2
+#define HEVCFW_NUM_DPB_DIFF_REGS 4
+
+/* non-critical errors*/
+#define HEVC_ERR_INVALID_VALUE (20)
+#define HEVC_ERR_CORRECTION_VALIDVALUE (21)
+
+#define HEVC_IS_ERR_CRITICAL(err) \
+	((err) > HEVC_ERR_CORRECTION_VALIDVALUE ? 1 : 0)
+
+/* critical errors*/
+#define HEVC_ERR_INV_VIDEO_DIMENSION (22)
+#define HEVC_ERR_NO_SEQUENCE_HDR (23)
+#define HEVC_ERR_SPS_EXT_UNSUPP (24 | VDECFW_UNSUPPORTED_CODE_BASE)
+#define HEVC_ERR_PPS_EXT_UNSUPP (25 | VDECFW_UNSUPPORTED_CODE_BASE)
+
+#define HEVC_ERR_FAILED_TO_STORE_VPS (100)
+#define HEVC_ERR_FAILED_TO_STORE_SPS (101)
+#define HEVC_ERR_FAILED_TO_STORE_PPS (102)
+
+#define HEVC_ERR_FAILED_TO_FETCH_VPS (103)
+#define HEVC_ERR_FAILED_TO_FETCH_SPS (104)
+#define HEVC_ERR_FAILED_TO_FETCH_PPS (105)
+/* HEVC Scaling Lists (all values are maximum possible ones) */
+#define HEVCFW_SCALING_LIST_NUM_SIZES 4
+#define HEVCFW_SCALING_LIST_NUM_MATRICES 6
+#define HEVCFW_SCALING_LIST_MATRIX_SIZE 64
+
+struct hevcfw_scaling_listdata {
+	unsigned char dc_coeffs
+	[HEVCFW_SCALING_LIST_NUM_SIZES - 2]
+	[HEVCFW_SCALING_LIST_NUM_MATRICES];
+
+	unsigned char lists
+	[HEVCFW_SCALING_LIST_NUM_SIZES]
+	[HEVCFW_SCALING_LIST_NUM_MATRICES]
+	[HEVCFW_SCALING_LIST_MATRIX_SIZE];
+};
+
+/* HEVC Video Profile_Tier_Level */
+struct hevcfw_profile_tier_level {
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_profile_space);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_tier_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_profile_idc);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			general_profile_compatibility_flag
+			[HEVCFW_MAX_NUM_PROFILE_IDC]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_progressive_source_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_interlaced_source_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_non_packed_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_frame_only_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_max_12bit_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_max_10bit_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_max_8bit_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_max_422chroma_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_max_420chroma_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_max_monochrome_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_intra_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			general_one_picture_only_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_lower_bit_rate_constraint_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, general_level_idc);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_profile_present_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_level_present_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_profile_space[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_tier_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_profile_idc[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_profile_compatibility_flag
+			[HEVCFW_MAX_NUM_SUBLAYERS - 1][HEVCFW_MAX_NUM_PROFILE_IDC]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_progressive_source_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_interlaced_source_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_non_packed_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_frame_only_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_max_12bit_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_max_10bit_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_max_8bit_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_max_422chroma_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_max_420chroma_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_max_monochrome_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_intra_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_one_picture_only_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_lower_bit_rate_constraint_flag[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sub_layer_level_idc[HEVCFW_MAX_NUM_SUBLAYERS - 1]);
+};
+
+struct hevcfw_video_ps {
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, is_different);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, is_sent);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, is_available);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, vps_video_parameter_set_id);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, vps_reserved_three_2bits);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, vps_max_layers_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, vps_max_sub_layers_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, vps_temporal_id_nesting_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, vps_reserved_0xffff_16bits);
+	struct hevcfw_profile_tier_level profile_tier_level;
+};
+
+/* HEVC Video Usability Information */
+struct hevcfw_vui_params {
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, aspect_ratio_info_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, aspect_ratio_idc);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, sar_width);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, sar_height);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, overscan_info_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, overscan_appropriate_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, video_signal_type_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, video_format);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, video_full_range_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, colour_description_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, colour_primaries);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, transfer_characteristics);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, matrix_coeffs);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, chroma_loc_info_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, chroma_sample_loc_type_top_field);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, chroma_sample_loc_type_bottom_field);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, neutral_chroma_indication_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, field_seq_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, frame_field_info_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, default_display_window_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, def_disp_win_left_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, def_disp_win_right_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, def_disp_win_top_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, def_disp_win_bottom_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, vui_timing_info_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, vui_num_units_in_tick);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, vui_time_scale);
+};
+
+/* HEVC Short Term Reference Picture Set */
+struct hevcfw_short_term_ref_picset {
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_negative_pics);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_positive_pics);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			short, delta_poc_s0[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			short, delta_poc_s1[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, used_bycurr_pic_s0[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, used_bycurr_pic_s1[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_delta_pocs);
+};
+
+/*
+ * This describes the SPS header data required by the HEVC firmware that should
+ * be supplied by the Host.
+ */
+struct hevcfw_sequence_ps {
+	/* syntax elements from SPS */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, pic_width_in_luma_samples);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, pic_height_in_luma_samples);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_short_term_ref_pic_sets);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_long_term_ref_pics_sps);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short,
+			lt_ref_pic_poc_lsb_sps[HEVCFW_MAX_NUM_LT_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			used_by_curr_pic_lt_sps_flag[HEVCFW_MAX_NUM_LT_REF_PICS]);
+	struct hevcfw_short_term_ref_picset st_rps_list[HEVCFW_MAX_NUM_ST_REF_PIC_SETS];
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_max_sub_layers_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sps_max_dec_pic_buffering_minus1[HEVCFW_MAX_NUM_SUBLAYERS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			sps_max_num_reorder_pics[HEVCFW_MAX_NUM_SUBLAYERS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int,
+			sps_max_latency_increase_plus1[HEVCFW_MAX_NUM_SUBLAYERS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, max_transform_hierarchy_depth_inter);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, max_transform_hierarchy_depth_intra);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, log2_diff_max_min_transform_block_size);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, log2_min_transform_block_size_minus2);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			log2_diff_max_min_luma_coding_block_size);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, log2_min_luma_coding_block_size_minus3);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, chroma_format_idc);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, separate_colour_plane_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_extra_slice_header_bits);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, log2_max_pic_order_cnt_lsb_minus4);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, long_term_ref_pics_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sample_adaptive_offset_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_temporal_mvp_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, bit_depth_luma_minus8);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, bit_depth_chroma_minus8);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pcm_sample_bit_depth_luma_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pcm_sample_bit_depth_chroma_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			log2_min_pcm_luma_coding_block_size_minus3);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			log2_diff_max_min_pcm_luma_coding_block_size);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pcm_loop_filter_disabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, amp_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pcm_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, strong_intra_smoothing_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, scaling_list_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, transform_skip_rotation_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, transform_skip_context_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, implicit_rdpcm_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, explicit_rdpcm_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, extended_precision_processing_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, intra_smoothing_disabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, high_precision_offsets_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, persistent_rice_adaptation_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, cabac_bypass_alignment_enabled_flag);
+	/* derived elements */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, pic_size_in_ctbs_y);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, pic_height_in_ctbs_y);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, pic_width_in_ctbs_y);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, ctb_size_y);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, ctb_log2size_y);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, max_pic_order_cnt_lsb);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int,
+			sps_max_latency_pictures[HEVCFW_MAX_NUM_SUBLAYERS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_seq_parameter_set_id);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_video_parameter_set_id);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_temporal_id_nesting_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_seq_parameter_set_id);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, conformance_window_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, conf_win_left_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, conf_win_right_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, conf_win_top_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, conf_win_bottom_offset);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_sub_layer_ordering_info_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_scaling_list_data_present_flag);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, vui_parameters_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sps_extension_present_flag);
+
+	struct hevcfw_vui_params vui_params;
+	/* derived elements */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sub_width_c);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sub_height_c);
+
+	struct hevcfw_profile_tier_level profile_tier_level;
+	struct hevcfw_scaling_listdata scaling_listdata;
+};
+
+/*
+ * This describes the HEVC parser component "Header data", shown in the
+ * Firmware Memory Layout diagram. This data is required by the HEVC firmware
+ * and should be supplied by the Host.
+ */
+struct hevcfw_headerdata {
+	/* Decode buffers and output control for the current picture */
+	/* Primary decode buffer base addresses */
+	struct vdecfw_image_buffer primary;
+	/* buffer base addresses for alternate output */
+	struct vdecfw_image_buffer alternate;
+	/* address of buffer for temporal mv params */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, temporal_outaddr);
+};
+
+/*
+ * This describes the PPS header data required by the HEVC firmware that should
+ * be supplied by the Host.
+ */
+struct hevcfw_picture_ps {
+	/* syntax elements from the PPS */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_pic_parameter_set_id);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_tile_columns_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_tile_rows_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, diff_cu_qp_delta_depth);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, init_qp_minus26);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_beta_offset_div2);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_tc_offset_div2);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_cb_qp_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_cr_qp_offset);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, log2_parallel_merge_level_minus2);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, dependent_slice_segments_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, output_flag_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_extra_slice_header_bits);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, lists_modification_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, cabac_init_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, weighted_pred_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, weighted_bipred_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			pps_slice_chroma_qp_offsets_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			deblocking_filter_override_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, tiles_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, entropy_coding_sync_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			slice_segment_header_extension_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, transquant_bypass_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, cu_qp_delta_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, transform_skip_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, sign_data_hiding_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_ref_idx_l0_default_active_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_ref_idx_l1_default_active_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, constrained_intra_pred_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_deblocking_filter_disabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			pps_loop_filter_across_slices_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, loop_filter_across_tiles_enabled_flag);
+
+	/* rewritten from SPS, maybe at some point we could get rid of this */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, scaling_list_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			log2_max_transform_skip_block_size_minus2);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			cross_component_prediction_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, chroma_qp_offset_list_enabled_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, diff_cu_chroma_qp_offset_depth);
+	/*
+	 * PVDEC derived elements. HEVCFW_SCALING_LISTS_BUFSIZE is
+	 * multiplied by 2 to ensure that there will be space for address of
+	 * each element. These addresses are completed in lower layer.
+	 */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int,
+			scaling_lists[HEVCFW_SCALING_LISTS_BUFSIZE * 2]);
+	/* derived elements */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, col_bd[HEVCFW_MAX_TILE_COLS + 1]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, row_bd[HEVCFW_MAX_TILE_ROWS + 1]);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, chroma_qp_offset_list_len_minus1);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, cb_qp_offset_list[HEVCFW_MAX_CHROMA_QP]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, cr_qp_offset_list[HEVCFW_MAX_CHROMA_QP]);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, uniform_spacing_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			column_width_minus1[HEVCFW_MAX_TILE_COLS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			row_height_minus1[HEVCFW_MAX_TILE_ROWS]);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_seq_parameter_set_id);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, deblocking_filter_control_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_scaling_list_data_present_flag);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pps_extension_present_flag);
+
+	struct hevcfw_scaling_listdata scaling_list;
+};
+
+/* This enum determines reference picture status */
+enum hevcfw_reference_type {
+	HEVCFW_REF_UNUSED      = 0,
+	HEVCFW_REF_SHORTTERM,
+	HEVCFW_REF_LONGTERM,
+	HEVCFW_REF_FORCE32BITS = 0x7FFFFFFFU
+};
+
+/* This describes an HEVC picture. It is part of the Context data */
+struct hevcfw_picture {
+	/* Primary (reconstructed) picture buffers */
+	struct vdecfw_image_buffer primary;
+	/* Secondary (alternative) picture buffers */
+	struct vdecfw_image_buffer alternate;
+	/* Unique ID for this picture */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, transaction_id);
+	/* nut of first ssh of picture, determines picture type */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, nalunit_type);
+	/* Picture Order Count (frame number) */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, pic_order_cnt_val);
+	/* Slice Picture Order Count Lsb */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, slice_pic_ordercnt_lsb);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pic_output_flag);
+	/* information about long-term pictures */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned short, dpb_longterm_flags);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int,
+			dpb_pic_order_diff[HEVCFW_NUM_DPB_DIFF_REGS]);
+	/* address of buffer for temporal mv params */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, temporal_outaddr);
+	/* worst case Dpb diff for the current pic */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, dpb_diff);
+};
+
+/*
+ * This is a wrapper for a picture to hold it in a Decoded Picture Buffer
+ * for further reference
+ */
+struct hevcfw_picture_in_dpb {
+	/* DPB data about the picture */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			enum hevcfw_reference_type, ref_type);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, valid);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, needed_for_output);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, pic_latency_count);
+	/* Picture itself */
+	struct hevcfw_picture picture;
+};
+
+/*
+ * This describes an HEVC's Decoded Picture Buffer (DPB).
+ * It is part of the Context data
+ */
+
+#define HEVCFW_DPB_IDX_INVALID -1
+
+struct hevcfw_decoded_picture_buffer {
+	/* reference pictures */
+	struct hevcfw_picture_in_dpb pictures[HEVCFW_MAX_DPB_SIZE];
+	/* organizational data of DPB */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT, unsigned int, fullness);
+};
+
+/*
+ * This describes an HEVC's Reference Picture Set (RPS).
+ * It is part of the Context data
+ */
+struct hevcfw_reference_picture_set {
+	/* sizes of poc lists */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_pocst_curr_before);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_pocst_curr_after);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_pocst_foll);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_poclt_curr);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, num_poclt_foll);
+	/* poc lists */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, pocst_curr_before[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, pocst_curr_after[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, pocst_foll[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, poclt_curr[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, poclt_foll[HEVCFW_MAX_NUM_REF_PICS]);
+	/* derived elements */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			curr_delta_pocmsb_presentflag[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			foll_delta_pocmsb_presentflag[HEVCFW_MAX_NUM_REF_PICS]);
+	/* reference picture sets: indices in DPB */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, ref_picsetlt_curr[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, ref_picsetlt_foll[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			ref_picsetst_curr_before[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			ref_picsetst_curr_after[HEVCFW_MAX_NUM_REF_PICS]);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, ref_picsetst_foll[HEVCFW_MAX_NUM_REF_PICS]);
+};
+
+/*
+ * This describes the HEVC parser component "Context data", shown in the
+ * Firmware Memory Layout diagram. This data is the state preserved across
+ * pictures. It is loaded and saved by the Firmware, but requires the host to
+ * provide buffer(s) for this.
+ */
+struct hevcfw_ctx_data {
+	struct hevcfw_sequence_ps sps;
+	struct hevcfw_picture_ps pps;
+	/*
+	 * data from last picture with TemporalId = 0 that is not a RASL, RADL
+	 * or sub-layer non-reference picture
+	 */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, prev_pic_order_cnt_lsb);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, prev_pic_order_cnt_msb);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char, last_irapnorasl_output_flag);
+	/*
+	 * Decoded Pictures Buffer holds information about decoded pictures
+	 * needed for further INTER decoding
+	 */
+	struct hevcfw_decoded_picture_buffer dpb;
+	/* Reference Picture Set is determined on per-picture basis */
+	struct hevcfw_reference_picture_set rps;
+	/*
+	 * Reference Picture List is determined using data from Reference
+	 * Picture Set and from Slice (Segment) Header on per-slice basis
+	 */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT, unsigned char,
+			ref_pic_list[HEVCFW_NUM_REF_PIC_LISTS][HEVCFW_MAX_NUM_REF_PICS]);
+	/*
+	 * Reference Picture List used to send reflist to the host, the only
+	 * difference is that missing references are marked
+	 * with HEVCFW_DPB_IDX_INVALID
+	 */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned char,
+			ref_pic_listhlp[HEVCFW_NUM_REF_PIC_LISTS][HEVCFW_MAX_NUM_REF_PICS]);
+
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, pic_count);
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			unsigned int, slice_segment_count);
+	/* There was EOS NAL detected and no new picture yet */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, eos_detected);
+	/* This is first picture after EOS NAL */
+	IMG_ALIGN_FIELD(VDECFW_SHARE_DEFAULT_ALIGNMENT,
+			int, first_after_eos);
+};
+
+#endif /* _HEVCFW_DATA_H_ */
diff --git a/drivers/media/platform/vxe-vxd/decoder/pvdec_entropy_regs.h b/drivers/media/platform/vxe-vxd/decoder/pvdec_entropy_regs.h
new file mode 100644
index 000000000000..42811b46137f
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/pvdec_entropy_regs.h
@@ -0,0 +1,1579 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * VXD DEC Common low level core interface component
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef __PVDEC_ENTROPY_REGS_H__
+#define __PVDEC_ENTROPY_REGS_H__
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_OFFSET                (0x004C)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_STRIDE                (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_NO_ENTRIES            (2)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_EMULATION_COUNT, SR_BIT_OFFSET
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_BIT_OFFSET_MASK            (0x07000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_BIT_OFFSET_LSBMASK         (0x00000007)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_BIT_OFFSET_SHIFT           (24)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_BIT_OFFSET_LENGTH          (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_BIT_OFFSET_DEFAULT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_BIT_OFFSET_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_EMULATION_COUNT, SR_EMULATION_COUNT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_EMULATION_COUNT_MASK \
+	( \
+		0x00FFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_EMULATION_COUNT_LSBMASK \
+	( \
+		0x00FFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_EMULATION_COUNT_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_EMULATION_COUNT_LENGTH             (24)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_EMULATION_COUNT_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_EMULATION_COUNT_SR_EMULATION_COUNT_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_OFFSET               (0x0048)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_STRIDE               (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_NO_ENTRIES           (2)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_STREAMIN, SR_STREAMIN
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_SR_STREAMIN_MASK             (0x000000FF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_SR_STREAMIN_LSBMASK          (0x000000FF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_SR_STREAMIN_SHIFT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_SR_STREAMIN_LENGTH           (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_SR_STREAMIN_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_STREAMIN_SR_STREAMIN_SIGNED_FIELD     (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_OFFSET             (0x0044)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_STRIDE             (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_NO_ENTRIES         (2)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_BYTE_COUNT, SR_BYTE_COUNT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_SR_BYTE_COUNT_MASK         (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_SR_BYTE_COUNT_LSBMASK              (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_SR_BYTE_COUNT_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_SR_BYTE_COUNT_LENGTH               (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_SR_BYTE_COUNT_DEFAULT              (16777215)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_BYTE_COUNT_SR_BYTE_COUNT_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_OFFSET                (0x0040)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_STRIDE                (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_NO_ENTRIES            (2)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_CODEC_MODE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_CODEC_MODE_MASK            (0x000F0000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_CODEC_MODE_LSBMASK         (0x0000000F)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_CODEC_MODE_SHIFT           (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_CODEC_MODE_LENGTH          (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_CODEC_MODE_DEFAULT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_CODEC_MODE_SIGNED_FIELD    (IMG_FALSE)
+
+enum PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_CODEC_MODE_ENUM {
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_VP9         = 0xd,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_HEVC        = 0xc,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_VP8         = 0xb,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_VP6         = 0xa,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_RV9         = 0x9,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_RV8         = 0x8,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_MPEG1       = 0x7,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_WMV9        = 0x6,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_AVS         = 0x5,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_MPEG4       = 0x4,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_MPEG2       = 0x3,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_VC1         = 0x2,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_H264        = 0x1,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_JPEG        = 0x0,
+	PVDEC_ENTROPY_SR_CODEC_MODE_SR_FORCE32BITS = 0x7FFFFFFFU
+};
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_BYTE_COUNT_EBDU
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_BYTE_COUNT_EBDU_MASK               (0x00001000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_BYTE_COUNT_EBDU_LSBMASK            (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_BYTE_COUNT_EBDU_SHIFT              (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_BYTE_COUNT_EBDU_LENGTH             (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_BYTE_COUNT_EBDU_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_BYTE_COUNT_EBDU_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_FILL_IN_ZEROES
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FILL_IN_ZEROES_MASK                (0x00000800)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FILL_IN_ZEROES_LSBMASK             (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FILL_IN_ZEROES_SHIFT               (11)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FILL_IN_ZEROES_LENGTH              (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FILL_IN_ZEROES_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FILL_IN_ZEROES_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_MASTER_SELECT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_MASTER_SELECT_MASK         (0x00000300)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_MASTER_SELECT_LSBMASK              (0x00000003)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_MASTER_SELECT_SHIFT                (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_MASTER_SELECT_LENGTH               (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_MASTER_SELECT_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_MASTER_SELECT_SIGNED_FIELD (IMG_FALSE)
+
+enum PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_MASTER_SELECT_ENUM {
+	PVDEC_ENTROPY_SR_MASTER_SELECT_COPRO       = 0x3,
+	PVDEC_ENTROPY_SR_MASTER_SELECT_ENTDEC      = 0x2,
+	PVDEC_ENTROPY_SR_MASTER_SELECT_REGISTER    = 0x1,
+	PVDEC_ENTROPY_SR_MASTER_SELECT_RESERVED    = 0x0,
+	PVDEC_ENTROPY_SR_MASTER_SELECT_FORCE32BITS = 0x7FFFFFFFU
+};
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_DISABLE_DMA
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_DISABLE_DMA_MASK           (0x00000080)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_DISABLE_DMA_LSBMASK                (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_DISABLE_DMA_SHIFT          (7)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_DISABLE_DMA_LENGTH         (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_DISABLE_DMA_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_DISABLE_DMA_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_FIFO_BYTE_SWAP
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_BYTE_SWAP_MASK                (0x00000040)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_BYTE_SWAP_LSBMASK             (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_BYTE_SWAP_SHIFT               (6)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_BYTE_SWAP_LENGTH              (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_BYTE_SWAP_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_BYTE_SWAP_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_FIFO_MODE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_MODE_MASK             (0x00000020)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_MODE_LSBMASK          (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_MODE_SHIFT            (5)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_MODE_LENGTH           (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_MODE_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_FIFO_MODE_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_RBDU_EXTRACT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_RBDU_EXTRACT_MASK          (0x00000008)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_RBDU_EXTRACT_LSBMASK               (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_RBDU_EXTRACT_SHIFT         (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_RBDU_EXTRACT_LENGTH                (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_RBDU_EXTRACT_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_RBDU_EXTRACT_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_READ_MODE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_READ_MODE_MASK             (0x00000004)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_READ_MODE_LSBMASK          (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_READ_MODE_SHIFT            (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_READ_MODE_LENGTH           (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_READ_MODE_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_READ_MODE_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_PREEMPT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_PREEMPT_MASK               (0x00000002)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_PREEMPT_LSBMASK            (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_PREEMPT_SHIFT              (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_PREEMPT_LENGTH             (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_PREEMPT_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_PREEMPT_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_CONTROL, SR_SW_RESET
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_SW_RESET_MASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_SW_RESET_LSBMASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_SW_RESET_SHIFT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_SW_RESET_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_SW_RESET_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_CONTROL_SR_SW_RESET_SIGNED_FIELD      (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_OFFSET                (0x0100)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_STRIDE                (4)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_NO_ENTRIES            (4)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_BUFFER_SIZE, GENC_BUFFER_SIZE
+ */
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_MASK         (0x0FFFF000)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_LSBMASK              (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_SHIFT                (12)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_LENGTH               (16)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_OFFSET                (0x0110)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_STRIDE                (4)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_NO_ENTRIES            (4)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_BUFFER_BASE_ADDRESS, GENC_BASE_ADDRESS
+ */
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_MASK                (0xFFFFF000)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_LSBMASK             (0x000FFFFF)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_SHIFT               (12)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_LENGTH              (20)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_SIGNED_FIELD        (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_OFFSET               (0x0120)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_STRIDE               (4)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_NO_ENTRIES           (4)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_BUFFER_WRITE_POINTER, GENC_WRITE_POINTER
+ */
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_GENC_WRITE_POINTER_MASK              (0x0FFFFFF0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_GENC_WRITE_POINTER_LSBMASK           (0x00FFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_GENC_WRITE_POINTER_SHIFT             (4)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_GENC_WRITE_POINTER_LENGTH            (24)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_GENC_WRITE_POINTER_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_WRITE_POINTER_GENC_WRITE_POINTER_SIGNED_FIELD      (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_OFFSET                (0x0130)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_STRIDE                (4)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_NO_ENTRIES            (4)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_BUFFER_READ_POINTER, GENC_READ_POINTER
+ */
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_MASK                (0x0FFFFFF0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_LSBMASK             (0x00FFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_SHIFT               (4)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_LENGTH              (24)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_SIGNED_FIELD        (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_OFFSET           (0x01C0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_STRIDE           (4)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_NO_ENTRIES               (4)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_BUFFER_SIGNATURE, GENC_BUFFER_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_GENC_BUFFER_SIGNATURE_MASK               (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_GENC_BUFFER_SIGNATURE_LSBMASK            (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_GENC_BUFFER_SIGNATURE_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_GENC_BUFFER_SIGNATURE_LENGTH             (32)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_GENC_BUFFER_SIGNATURE_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_GENC_BUFFER_SIGNATURE_GENC_BUFFER_SIGNATURE_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_OFFSET            (0x01E8)
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_STRIDE            (4)
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_NO_ENTRIES                (2)
+
+/*
+ * PVDEC_ENTROPY, CR_SR_SIGNATURE, SR_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_SR_SIGNATURE_MASK         (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_SR_SIGNATURE_LSBMASK              (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_SR_SIGNATURE_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_SR_SIGNATURE_LENGTH               (32)
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_SR_SIGNATURE_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_SR_SIGNATURE_SR_SIGNATURE_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_OFFSET              (0x0000)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SOFT_RESET, CR_ENTROPY_GENC_SOFT_RESET
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_SOFT_RESET_MASK             (0x00000004)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_SOFT_RESET_LSBMASK          (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_SOFT_RESET_SHIFT            (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_SOFT_RESET_LENGTH           (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_SOFT_RESET_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_SOFT_RESET_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SOFT_RESET, CR_ENTROPY_GENC_ENGINE_SOFT_RESET
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_ENGINE_SOFT_RESET_MASK \
+	( \
+		0x00000002)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_ENGINE_SOFT_RESET_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_ENGINE_SOFT_RESET_SHIFT             (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_ENGINE_SOFT_RESET_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_ENGINE_SOFT_RESET_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_GENC_ENGINE_SOFT_RESET_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SOFT_RESET, CR_ENTROPY_PARSER_SOFT_RESET
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_PARSER_SOFT_RESET_MASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_PARSER_SOFT_RESET_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_PARSER_SOFT_RESET_SHIFT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_PARSER_SOFT_RESET_LENGTH         (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_PARSER_SOFT_RESET_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SOFT_RESET_CR_ENTROPY_PARSER_SOFT_RESET_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_OFFSET                (0x0008)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, BACKWARD_UPDATE_COMPLETE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_BACKWARD_UPDATE_COMPLETE_MASK         (0x02000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_BACKWARD_UPDATE_COMPLETE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_BACKWARD_UPDATE_COMPLETE_SHIFT                (25)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_BACKWARD_UPDATE_COMPLETE_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_BACKWARD_UPDATE_COMPLETE_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_BACKWARD_UPDATE_COMPLETE_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, HEADER_PARSE_COMPLETE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_HEADER_PARSE_COMPLETE_MASK            (0x01000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_HEADER_PARSE_COMPLETE_LSBMASK         (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_HEADER_PARSE_COMPLETE_SHIFT           (24)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_HEADER_PARSE_COMPLETE_LENGTH          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_HEADER_PARSE_COMPLETE_DEFAULT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_HEADER_PARSE_COMPLETE_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_WDT_CM1_IRQ
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM1_IRQ_MASK              (0x00020000)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM1_IRQ_LSBMASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM1_IRQ_SHIFT             (17)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM1_IRQ_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM1_IRQ_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM1_IRQ_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_WDT_CM0_IRQ
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM0_IRQ_MASK              (0x00010000)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM0_IRQ_LSBMASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM0_IRQ_SHIFT             (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM0_IRQ_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM0_IRQ_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_WDT_CM0_IRQ_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_GENC_FULL
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_GENC_FULL_MASK                (0x00000F00)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_GENC_FULL_LSBMASK             (0x0000000F)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_GENC_FULL_SHIFT               (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_GENC_FULL_LENGTH              (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_GENC_FULL_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_GENC_FULL_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_FRAGMENT_SLICE_COMPLETE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_SLICE_COMPLETE_MASK \
+	( \
+		0x00000080)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_SLICE_COMPLETE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_SLICE_COMPLETE_SHIFT         (7)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_SLICE_COMPLETE_LENGTH \
+	( \
+		1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_SLICE_COMPLETE_DEFAULT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_SLICE_COMPLETE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_FRAGMENT_ROW_COMPLETE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_ROW_COMPLETE_MASK \
+	( \
+		0x00000040)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_ROW_COMPLETE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_ROW_COMPLETE_SHIFT           (6)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_ROW_COMPLETE_LENGTH          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_ROW_COMPLETE_DEFAULT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_FRAGMENT_ROW_COMPLETE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_DMAC_IRQ
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_DMAC_IRQ_MASK         (0x00000030)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_DMAC_IRQ_LSBMASK              (0x00000003)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_DMAC_IRQ_SHIFT                (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_DMAC_IRQ_LENGTH               (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_DMAC_IRQ_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_DMAC_IRQ_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_ERROR_FRAGMENT_DONE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_FRAGMENT_DONE_MASK \
+	( \
+		0x00000008)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_FRAGMENT_DONE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_FRAGMENT_DONE_SHIFT             (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_FRAGMENT_DONE_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_FRAGMENT_DONE_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_FRAGMENT_DONE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_ERROR_DETECTED_PARSER
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_PARSER_MASK \
+	( \
+		0x00000004)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_PARSER_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_PARSER_SHIFT           (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_PARSER_LENGTH          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_PARSER_DEFAULT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_PARSER_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_ERROR_DETECTED_SR
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_SR_MASK \
+	( \
+		0x00000002)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_SR_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_SR_SHIFT               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_SR_LENGTH              (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_SR_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_ERROR_DETECTED_SR_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_STATUS, ENTROPY_END_OF_SLICE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_END_OF_SLICE_MASK             (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_END_OF_SLICE_LSBMASK          (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_END_OF_SLICE_SHIFT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_END_OF_SLICE_LENGTH           (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_END_OF_SLICE_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_STATUS_ENTROPY_END_OF_SLICE_SIGNED_FIELD     (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_CLEAR_OFFSET         (0x000C)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_INTERRUPT_CLEAR, ENTROPY_IRQ_CLEAR
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_CLEAR_ENTROPY_IRQ_CLEAR_MASK         (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_CLEAR_ENTROPY_IRQ_CLEAR_LSBMASK              (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_CLEAR_ENTROPY_IRQ_CLEAR_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_CLEAR_ENTROPY_IRQ_CLEAR_LENGTH               (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_CLEAR_ENTROPY_IRQ_CLEAR_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_INTERRUPT_CLEAR_ENTROPY_IRQ_CLEAR_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_HOST_INTERRUPT_ENABLE_OFFSET           (0x0010)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_HOST_INTERRUPT_ENABLE, CR_HOST_IRQ_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_HOST_INTERRUPT_ENABLE_CR_HOST_IRQ_ENABLE_MASK          (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_HOST_INTERRUPT_ENABLE_CR_HOST_IRQ_ENABLE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_HOST_INTERRUPT_ENABLE_CR_HOST_IRQ_ENABLE_SHIFT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_HOST_INTERRUPT_ENABLE_CR_HOST_IRQ_ENABLE_LENGTH                (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_HOST_INTERRUPT_ENABLE_CR_HOST_IRQ_ENABLE_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_HOST_INTERRUPT_ENABLE_CR_HOST_IRQ_ENABLE_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC1_INTERRUPT_ENABLE_OFFSET          (0x0014)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_PROC1_INTERRUPT_ENABLE, CR_PROC1_IRQ_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC1_INTERRUPT_ENABLE_CR_PROC1_IRQ_ENABLE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC1_INTERRUPT_ENABLE_CR_PROC1_IRQ_ENABLE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC1_INTERRUPT_ENABLE_CR_PROC1_IRQ_ENABLE_SHIFT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC1_INTERRUPT_ENABLE_CR_PROC1_IRQ_ENABLE_LENGTH              (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC1_INTERRUPT_ENABLE_CR_PROC1_IRQ_ENABLE_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC1_INTERRUPT_ENABLE_CR_PROC1_IRQ_ENABLE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC2_INTERRUPT_ENABLE_OFFSET          (0x0018)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_PROC2_INTERRUPT_ENABLE, CR_PROC2_IRQ_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC2_INTERRUPT_ENABLE_CR_PROC2_IRQ_ENABLE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC2_INTERRUPT_ENABLE_CR_PROC2_IRQ_ENABLE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC2_INTERRUPT_ENABLE_CR_PROC2_IRQ_ENABLE_SHIFT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC2_INTERRUPT_ENABLE_CR_PROC2_IRQ_ENABLE_LENGTH              (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC2_INTERRUPT_ENABLE_CR_PROC2_IRQ_ENABLE_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PROC2_INTERRUPT_ENABLE_CR_PROC2_IRQ_ENABLE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_OFFSET          (0x0020)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_MAN_CLK_ENABLE, CR_ENTROPY_HEVC_MAN_CLK_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_HEVC_MAN_CLK_ENABLE_MASK \
+	( \
+		0x00000004)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_HEVC_MAN_CLK_ENABLE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_HEVC_MAN_CLK_ENABLE_SHIFT            (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_HEVC_MAN_CLK_ENABLE_LENGTH           (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_HEVC_MAN_CLK_ENABLE_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_HEVC_MAN_CLK_ENABLE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_MAN_CLK_ENABLE, CR_ENTROPY_REG_MAN_CLK_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_REG_MAN_CLK_ENABLE_MASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_REG_MAN_CLK_ENABLE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_REG_MAN_CLK_ENABLE_SHIFT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_REG_MAN_CLK_ENABLE_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_REG_MAN_CLK_ENABLE_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_MAN_CLK_ENABLE_CR_ENTROPY_REG_MAN_CLK_ENABLE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_OFFSET         (0x0024)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_AUTO_CLK_ENABLE, CR_ENTROPY_HEVC_AUTO_CLK_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_HEVC_AUTO_CLK_ENABLE_MASK \
+	( \
+		0x00000004)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_HEVC_AUTO_CLK_ENABLE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_HEVC_AUTO_CLK_ENABLE_SHIFT          (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_HEVC_AUTO_CLK_ENABLE_LENGTH         (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_HEVC_AUTO_CLK_ENABLE_DEFAULT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_HEVC_AUTO_CLK_ENABLE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_AUTO_CLK_ENABLE, CR_ENTROPY_REG_AUTO_CLK_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_REG_AUTO_CLK_ENABLE_MASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_REG_AUTO_CLK_ENABLE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_REG_AUTO_CLK_ENABLE_SHIFT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_REG_AUTO_CLK_ENABLE_LENGTH          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_REG_AUTO_CLK_ENABLE_DEFAULT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_AUTO_CLK_ENABLE_CR_ENTROPY_REG_AUTO_CLK_ENABLE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_OFFSET              (0x0028)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_CLK_STATUS, CR_ENTROPY_HEVC_CLK_STATUS
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_HEVC_CLK_STATUS_MASK             (0x00000004)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_HEVC_CLK_STATUS_LSBMASK          (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_HEVC_CLK_STATUS_SHIFT            (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_HEVC_CLK_STATUS_LENGTH           (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_HEVC_CLK_STATUS_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_HEVC_CLK_STATUS_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_CLK_STATUS, CR_ENTROPY_REG_CLK_STATUS
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_REG_CLK_STATUS_MASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_REG_CLK_STATUS_LSBMASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_REG_CLK_STATUS_SHIFT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_REG_CLK_STATUS_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_REG_CLK_STATUS_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_CLK_STATUS_CR_ENTROPY_REG_CLK_STATUS_SIGNED_FIELD      (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_OFFSET             (0x0030)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_CONTROL, ENTROPY_WDT_CNT_CTRL
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CNT_CTRL_MASK          (0x00060000)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CNT_CTRL_LSBMASK               (0x00000003)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CNT_CTRL_SHIFT         (17)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CNT_CTRL_LENGTH                (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CNT_CTRL_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CNT_CTRL_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_CONTROL, ENTROPY_WDT_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ENABLE_MASK            (0x00010000)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ENABLE_LSBMASK         (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ENABLE_SHIFT           (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ENABLE_LENGTH          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ENABLE_DEFAULT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ENABLE_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_CONTROL, ENTROPY_WDT_ACTION1
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION1_MASK           (0x00003000)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION1_LSBMASK                (0x00000003)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION1_SHIFT          (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION1_LENGTH         (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION1_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION1_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_CONTROL, ENTROPY_WDT_ACTION0
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION0_MASK           (0x00000100)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION0_LSBMASK                (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION0_SHIFT          (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION0_LENGTH         (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION0_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_ACTION0_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_CONTROL, ENTROPY_WDT_CLEAR_SELECT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLEAR_SELECT_MASK              (0x00000030)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLEAR_SELECT_LSBMASK           (0x00000003)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLEAR_SELECT_SHIFT             (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLEAR_SELECT_LENGTH            (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLEAR_SELECT_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLEAR_SELECT_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_CONTROL, ENTROPY_WDT_CLKDIV_SELECT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLKDIV_SELECT_MASK             (0x00000007)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLKDIV_SELECT_LSBMASK          (0x00000007)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLKDIV_SELECT_SHIFT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLKDIV_SELECT_LENGTH           (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLKDIV_SELECT_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_CONTROL_ENTROPY_WDT_CLKDIV_SELECT_SIGNED_FIELD     (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_WDTIMER_OFFSET         (0x0034)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDTIMER, ENTROPY_WDT_COUNTER
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDTIMER_ENTROPY_WDT_COUNTER_MASK               (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDTIMER_ENTROPY_WDT_COUNTER_LSBMASK            (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDTIMER_ENTROPY_WDT_COUNTER_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDTIMER_ENTROPY_WDT_COUNTER_LENGTH             (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDTIMER_ENTROPY_WDT_COUNTER_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDTIMER_ENTROPY_WDT_COUNTER_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_OFFSET                (0x0038)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_COMPAREMATCH, ENTROPY_WDT_CM1
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM1_MASK          (0xFFFF0000)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM1_LSBMASK               (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM1_SHIFT         (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM1_LENGTH                (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM1_DEFAULT               (65535)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM1_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_WDT_COMPAREMATCH, ENTROPY_WDT_CM0
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM0_MASK          (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM0_LSBMASK               (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM0_SHIFT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM0_LENGTH                (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM0_DEFAULT               (65535)
+#define PVDEC_ENTROPY_CR_ENTROPY_WDT_COMPAREMATCH_ENTROPY_WDT_CM0_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_OFFSET         (0x003C)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_SELECT, SR_ENTDEC_SELECTOR
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_ENTDEC_SELECTOR_MASK                (0x00010000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_ENTDEC_SELECTOR_LSBMASK             (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_ENTDEC_SELECTOR_SHIFT               (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_ENTDEC_SELECTOR_LENGTH              (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_ENTDEC_SELECTOR_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_ENTDEC_SELECTOR_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_SELECT, SR_COPRO_SELECTOR
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_COPRO_SELECTOR_MASK         (0x00000100)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_COPRO_SELECTOR_LSBMASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_COPRO_SELECTOR_SHIFT                (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_COPRO_SELECTOR_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_COPRO_SELECTOR_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_COPRO_SELECTOR_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_SELECT, SR_REGIF_SELECTOR
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_REGIF_SELECTOR_MASK         (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_REGIF_SELECTOR_LSBMASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_REGIF_SELECTOR_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_REGIF_SELECTOR_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_REGIF_SELECTOR_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_SELECT_SR_REGIF_SELECTOR_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_OFFSET               (0x0060)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD, SR_RESP_VALID
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_VALID_MASK           (0x80000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_VALID_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_VALID_SHIFT          (31)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_VALID_LENGTH         (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_VALID_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_VALID_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD, SR_SW_RESET_ACTIVE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_SW_RESET_ACTIVE_MASK \
+	( \
+		0x40000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_SW_RESET_ACTIVE_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_SW_RESET_ACTIVE_SHIFT             (30)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_SW_RESET_ACTIVE_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_SW_RESET_ACTIVE_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_SW_RESET_ACTIVE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD, SR_BYTE_ALIGNED
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_BYTE_ALIGNED_MASK         (0x00000010)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_BYTE_ALIGNED_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_BYTE_ALIGNED_SHIFT                (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_BYTE_ALIGNED_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_BYTE_ALIGNED_DEFAULT              (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_BYTE_ALIGNED_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD, SR_MORE_RBSP
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_MORE_RBSP_MASK            (0x00000008)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_MORE_RBSP_LSBMASK         (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_MORE_RBSP_SHIFT           (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_MORE_RBSP_LENGTH          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_MORE_RBSP_DEFAULT         (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_MORE_RBSP_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD, SR_RESP_EXPG_ERROR
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_EXPG_ERROR_MASK \
+	( \
+		0x00000004)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_EXPG_ERROR_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_EXPG_ERROR_SHIFT             (2)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_EXPG_ERROR_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_EXPG_ERROR_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_EXPG_ERROR_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD, SR_RESP_SCP_OR_EOD
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_SCP_OR_EOD_MASK \
+	( \
+		0x00000002)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_SCP_OR_EOD_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_SCP_OR_EOD_SHIFT             (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_SCP_OR_EOD_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_SCP_OR_EOD_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_SCP_OR_EOD_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD, SR_RESP_PREEMPTED
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_PREEMPTED_MASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_PREEMPTED_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_PREEMPTED_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_PREEMPTED_LENGTH             (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_PREEMPTED_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_MSWRD_SR_RESP_PREEMPTED_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD_OFFSET               (0x0064)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD, SR_RESP_VALUE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD_SR_RESP_VALUE_MASK           (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD_SR_RESP_VALUE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD_SR_RESP_VALUE_SHIFT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD_SR_RESP_VALUE_LENGTH         (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD_SR_RESP_VALUE_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_RESP_LSWRD_SR_RESP_VALUE_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_OFFSET                (0x0068)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD, SR_READ_PEEK_EXT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_EXT_MASK         (0x00004000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_EXT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_EXT_SHIFT                (14)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_EXT_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_EXT_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_EXT_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD, SR_PRE_FLUSH
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_PRE_FLUSH_MASK             (0x00001F00)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_PRE_FLUSH_LSBMASK          (0x0000001F)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_PRE_FLUSH_SHIFT            (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_PRE_FLUSH_LENGTH           (5)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_PRE_FLUSH_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_PRE_FLUSH_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD, SR_READ_PEEK
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_MASK             (0x000000F8)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_LSBMASK          (0x0000001F)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_SHIFT            (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_LENGTH           (5)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_READ_PEEK_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD, SR_ACCESS_MODE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_ACCESS_MODE_MASK           (0x00000007)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_ACCESS_MODE_LSBMASK \
+	( \
+		0x00000007)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_ACCESS_MODE_SHIFT          (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_ACCESS_MODE_LENGTH         (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_ACCESS_MODE_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SHIFTREG_COPRO_CMD_MSWRD_SR_ACCESS_MODE_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_OFFSET            (0x0080)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_GENC_CONTROL, GENC_ERROR_FILL_PICTURE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ERROR_FILL_PICTURE_MASK              (0x00000020)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ERROR_FILL_PICTURE_LSBMASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ERROR_FILL_PICTURE_SHIFT             (5)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ERROR_FILL_PICTURE_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ERROR_FILL_PICTURE_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ERROR_FILL_PICTURE_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_GENC_CONTROL, GENC_ENC_ERROR_RECOVERY
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ENC_ERROR_RECOVERY_MASK              (0x00000010)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ENC_ERROR_RECOVERY_LSBMASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ENC_ERROR_RECOVERY_SHIFT             (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ENC_ERROR_RECOVERY_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ENC_ERROR_RECOVERY_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_ENC_ERROR_RECOVERY_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_GENC_CONTROL, GENC_FLUSH
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_FLUSH_MASK           (0x00000002)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_FLUSH_LSBMASK                (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_FLUSH_SHIFT          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_FLUSH_LENGTH         (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_FLUSH_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_FLUSH_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_GENC_CONTROL, GENC_INITIALISE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_INITIALISE_MASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_INITIALISE_LSBMASK           (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_INITIALISE_SHIFT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_INITIALISE_LENGTH            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_INITIALISE_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_GENC_CONTROL_GENC_INITIALISE_SIGNED_FIELD      (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_ADDRESS_OFFSET         (0x0090)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_PARAMETER_ADDRESS, SLICE_PARAMETER_ADDRESS
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_ADDRESS_SLICE_PARAMETER_ADDRESS_MASK \
+	( \
+		0xFFFFFFC0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_ADDRESS_SLICE_PARAMETER_ADDRESS_LSBMASK \
+	( \
+		0x03FFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_ADDRESS_SLICE_PARAMETER_ADDRESS_SHIFT          (6)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_ADDRESS_SLICE_PARAMETER_ADDRESS_LENGTH         (26)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_ADDRESS_SLICE_PARAMETER_ADDRESS_DEFAULT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_ADDRESS_SLICE_PARAMETER_ADDRESS_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_SIZE_OFFSET            (0x0094)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_PARAMETER_SIZE, SLICE_PARAMETER_SIZE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_SIZE_SLICE_PARAMETER_SIZE_MASK         (0x0000000F)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_SIZE_SLICE_PARAMETER_SIZE_LSBMASK \
+	( \
+		0x0000000F)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_SIZE_SLICE_PARAMETER_SIZE_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_SIZE_SLICE_PARAMETER_SIZE_LENGTH               (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_SIZE_SLICE_PARAMETER_SIZE_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_PARAMETER_SIZE_SLICE_PARAMETER_SIZE_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_BASE_ADDRESS_OFFSET              (0x0098)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_FRAGMENT_BASE_ADDRESS, FRAGMENT_BASE_ADDRESS
+ */
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_MASK          (0xFFFFFFC0)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_LSBMASK \
+	( \
+		0x03FFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_SHIFT         (6)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_LENGTH                (26)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_OFFSET           (0x00A0)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_CODEC, ENTROPY_CHROMA_FORMAT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CHROMA_FORMAT_MASK               (0x00070000)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CHROMA_FORMAT_LSBMASK            (0x00000007)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CHROMA_FORMAT_SHIFT              (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CHROMA_FORMAT_LENGTH             (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CHROMA_FORMAT_DEFAULT            (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CHROMA_FORMAT_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_CODEC, ENTROPY_PROFILE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_PROFILE_MASK             (0x00000700)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_PROFILE_LSBMASK          (0x00000007)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_PROFILE_SHIFT            (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_PROFILE_LENGTH           (3)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_PROFILE_DEFAULT          (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_PROFILE_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_CODEC, ENTROPY_CODEC_MODE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CODEC_MODE_MASK          (0x0000000F)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CODEC_MODE_LSBMASK               (0x0000000F)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CODEC_MODE_SHIFT         (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CODEC_MODE_LENGTH                (4)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CODEC_MODE_DEFAULT               (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODEC_ENTROPY_CODEC_MODE_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_OFFSET              (0x00A8)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_CODED_PICTURE_SIZE, ENTROPY_PIC_HEIGHT_MIN1
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_HEIGHT_MIN1_MASK \
+	( \
+		0xFFFF0000)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_HEIGHT_MIN1_LSBMASK \
+	( \
+		0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_HEIGHT_MIN1_SHIFT               (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_HEIGHT_MIN1_LENGTH              (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_HEIGHT_MIN1_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_HEIGHT_MIN1_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_CODED_PICTURE_SIZE, ENTROPY_PIC_WIDTH_MIN1
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_WIDTH_MIN1_MASK         (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_WIDTH_MIN1_LSBMASK \
+	( \
+		0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_WIDTH_MIN1_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_WIDTH_MIN1_LENGTH               (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_WIDTH_MIN1_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_CODED_PICTURE_SIZE_ENTROPY_PIC_WIDTH_MIN1_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_OFFSET             (0x00B0)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_START, ENTROPY_SLICE_ENABLE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_ENABLE_MASK          (0x80000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_ENABLE_LSBMASK               (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_ENABLE_SHIFT         (31)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_ENABLE_LENGTH                (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_ENABLE_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_ENABLE_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_START, ENTROPY_SLICE_CHANGED_CONTEXT
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_CHANGED_CONTEXT_MASK         (0x40000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_CHANGED_CONTEXT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_CHANGED_CONTEXT_SHIFT                (30)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_CHANGED_CONTEXT_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_CHANGED_CONTEXT_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_CHANGED_CONTEXT_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_START, ENTROPY_SLICE_MB_NO_Y
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_Y_MASK         (0x0FFF0000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_Y_LSBMASK              (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_Y_SHIFT                (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_Y_LENGTH               (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_Y_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_Y_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_START, ENTROPY_SLICE_MB_NO_X
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_X_MASK         (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_X_LSBMASK              (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_X_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_X_LENGTH               (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_X_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_START_ENTROPY_SLICE_MB_NO_X_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_OFFSET               (0x00B4)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_END, ENTROPY_SLICE_END_KNOWN
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_KNOWN_MASK         (0x80000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_KNOWN_LSBMASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_KNOWN_SHIFT                (31)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_KNOWN_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_KNOWN_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_KNOWN_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_END, ENTROPY_SLICE_END_MB_NO_Y
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_Y_MASK               (0x0FFF0000)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_Y_LSBMASK            (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_Y_SHIFT              (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_Y_LENGTH             (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_Y_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_Y_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_SLICE_END, ENTROPY_SLICE_END_MB_NO_X
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_X_MASK               (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_X_LSBMASK            (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_X_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_X_LENGTH             (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_X_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_SLICE_END_ENTROPY_SLICE_END_MB_NO_X_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_OFFSET          (0x00B8)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_STATUS, FRAGMENT_TABLE_SIZE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_TABLE_SIZE_MASK                (0xFFFF0000)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_TABLE_SIZE_LSBMASK             (0x0000FFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_TABLE_SIZE_SHIFT               (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_TABLE_SIZE_LENGTH              (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_TABLE_SIZE_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_TABLE_SIZE_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_STATUS, FRAGMENT_ROW
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_ROW_MASK               (0x000003FF)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_ROW_LSBMASK            (0x000003FF)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_ROW_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_ROW_LENGTH             (10)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_ROW_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_STATUS_FRAGMENT_ROW_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_OFFSET         (0x00BC)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_LAST_MB, ENTROPY_LAST_MB_NO_Y
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_Y_MASK              (0x0FFF0000)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_Y_LSBMASK           (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_Y_SHIFT             (16)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_Y_LENGTH            (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_Y_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_Y_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_LAST_MB, ENTROPY_LAST_MB_NO_X
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_X_MASK              (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_X_LSBMASK           (0x00000FFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_X_SHIFT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_X_LENGTH            (12)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_X_DEFAULT           (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_LAST_MB_ENTROPY_LAST_MB_NO_X_SIGNED_FIELD      (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_PIPE_CONFIG_OFFSET             (0x00C0)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_PIPE_CONFIG, CR_ENTROPY_PIPE_CONFIG
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_PIPE_CONFIG_CR_ENTROPY_PIPE_CONFIG_MASK                (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PIPE_CONFIG_CR_ENTROPY_PIPE_CONFIG_LSBMASK             (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PIPE_CONFIG_CR_ENTROPY_PIPE_CONFIG_SHIFT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PIPE_CONFIG_CR_ENTROPY_PIPE_CONFIG_LENGTH              (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_PIPE_CONFIG_CR_ENTROPY_PIPE_CONFIG_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PIPE_CONFIG_CR_ENTROPY_PIPE_CONFIG_SIGNED_FIELD        (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_0_OFFSET          (0x00D0)
+
+/*
+ * PVDEC_ENTROPY, CR_MEM_SECURITY_ENTROPY_0, CR_MEM_SECURITY_ENTROPY_CTRL_0
+ */
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_0_CR_MEM_SECURITY_ENTROPY_CTRL_0_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_0_CR_MEM_SECURITY_ENTROPY_CTRL_0_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_0_CR_MEM_SECURITY_ENTROPY_CTRL_0_SHIFT            (0)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_0_CR_MEM_SECURITY_ENTROPY_CTRL_0_LENGTH           (32)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_0_CR_MEM_SECURITY_ENTROPY_CTRL_0_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_0_CR_MEM_SECURITY_ENTROPY_CTRL_0_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_1_OFFSET          (0x00D4)
+
+/*
+ * PVDEC_ENTROPY, CR_MEM_SECURITY_ENTROPY_1, CR_MEM_SECURITY_ENTROPY_CTRL_1
+ */
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_1_CR_MEM_SECURITY_ENTROPY_CTRL_1_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_1_CR_MEM_SECURITY_ENTROPY_CTRL_1_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_1_CR_MEM_SECURITY_ENTROPY_CTRL_1_SHIFT            (0)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_1_CR_MEM_SECURITY_ENTROPY_CTRL_1_LENGTH           (32)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_1_CR_MEM_SECURITY_ENTROPY_CTRL_1_DEFAULT          (0)
+#define PVDEC_ENTROPY_CR_MEM_SECURITY_ENTROPY_1_CR_MEM_SECURITY_ENTROPY_CTRL_1_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_OFFSET           (0x0180)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_CONTEXT0, GENC_CONTEXT0_3
+ */
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_MASK             (0x003F0000)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_LSBMASK          (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_SHIFT            (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_LENGTH           (6)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_DEFAULT          (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_CONTEXT0, GENC_CONTEXT0_2
+ */
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_MASK             (0x00003F00)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_LSBMASK          (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_SHIFT            (8)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_LENGTH           (6)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_DEFAULT          (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_CONTEXT0, GENC_CONTEXT0_1
+ */
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_MASK             (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_LSBMASK          (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_SHIFT            (0)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_LENGTH           (6)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_DEFAULT          (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_SIGNED_FIELD     (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_OFFSET           (0x0184)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_CONTEXT1, GENC_CONTEXT1_3
+ */
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_MASK             (0x003F0000)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_LSBMASK          (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_SHIFT            (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_LENGTH           (6)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_DEFAULT          (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_CONTEXT1, GENC_CONTEXT1_2
+ */
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_MASK             (0x00003F00)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_LSBMASK          (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_SHIFT            (8)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_LENGTH           (6)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_DEFAULT          (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_CONTEXT1, GENC_CONTEXT1_1
+ */
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_MASK             (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_LSBMASK          (0x0000003F)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_SHIFT            (0)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_LENGTH           (6)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_DEFAULT          (16)
+#define PVDEC_ENTROPY_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_SIGNED_FIELD     (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_FRAME_ID_OFFSET                (0x0190)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_FRAME_ID, ENTROPY_FRAME_ID
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_FRAME_ID_ENTROPY_FRAME_ID_MASK         (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_FRAME_ID_ENTROPY_FRAME_ID_LSBMASK              (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_FRAME_ID_ENTROPY_FRAME_ID_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_FRAME_ID_ENTROPY_FRAME_ID_LENGTH               (32)
+#define PVDEC_ENTROPY_CR_ENTROPY_FRAME_ID_ENTROPY_FRAME_ID_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_FRAME_ID_ENTROPY_FRAME_ID_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_STATUS_OFFSET             (0x01A8)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_PERF_STATUS, ENTROPY_PERF_DATA_VALID
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_STATUS_ENTROPY_PERF_DATA_VALID_MASK               (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_STATUS_ENTROPY_PERF_DATA_VALID_LSBMASK            (0x00000001)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_STATUS_ENTROPY_PERF_DATA_VALID_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_STATUS_ENTROPY_PERF_DATA_VALID_LENGTH             (1)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_STATUS_ENTROPY_PERF_DATA_VALID_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_STATUS_ENTROPY_PERF_DATA_VALID_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_OFFSET               (0x01AC)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_PERF_DATA, ENTROPY_PERF_METRIC_ID
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_ID_MASK          (0xFF000000)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_ID_LSBMASK               (0x000000FF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_ID_SHIFT         (24)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_ID_LENGTH                (8)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_ID_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_ID_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_ENTROPY_PERF_DATA, ENTROPY_PERF_METRIC_VALUE
+ */
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_VALUE_MASK               (0x00FFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_VALUE_LSBMASK            (0x00FFFFFF)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_VALUE_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_VALUE_LENGTH             (24)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_VALUE_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_ENTROPY_PERF_DATA_ENTROPY_PERF_METRIC_VALUE_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_HEVC_PARSER_SIGNATURE_OFFSET           (0x01B8)
+
+/*
+ * PVDEC_ENTROPY, CR_HEVC_PARSER_SIGNATURE, HEVC_PARSER_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_HEVC_PARSER_SIGNATURE_HEVC_PARSER_SIGNATURE_MASK               (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_HEVC_PARSER_SIGNATURE_HEVC_PARSER_SIGNATURE_LSBMASK            (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_HEVC_PARSER_SIGNATURE_HEVC_PARSER_SIGNATURE_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_HEVC_PARSER_SIGNATURE_HEVC_PARSER_SIGNATURE_LENGTH             (32)
+#define PVDEC_ENTROPY_CR_HEVC_PARSER_SIGNATURE_HEVC_PARSER_SIGNATURE_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_HEVC_PARSER_SIGNATURE_HEVC_PARSER_SIGNATURE_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_ENCAP_SIGNATURE_OFFSET         (0x01BC)
+
+/*
+ * PVDEC_ENTROPY, CR_ENCAP_SIGNATURE, ENCAP_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_ENCAP_SIGNATURE_ENCAP_SIGNATURE_MASK           (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENCAP_SIGNATURE_ENCAP_SIGNATURE_LSBMASK                (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_ENCAP_SIGNATURE_ENCAP_SIGNATURE_SHIFT          (0)
+#define PVDEC_ENTROPY_CR_ENCAP_SIGNATURE_ENCAP_SIGNATURE_LENGTH         (32)
+#define PVDEC_ENTROPY_CR_ENCAP_SIGNATURE_ENCAP_SIGNATURE_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_ENCAP_SIGNATURE_ENCAP_SIGNATURE_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_SIGNATURE_OFFSET         (0x01D0)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_FRAGMENT_SIGNATURE, GENC_FRAGMENT_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_SIGNATURE_GENC_FRAGMENT_SIGNATURE_MASK           (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_SIGNATURE_GENC_FRAGMENT_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_SIGNATURE_GENC_FRAGMENT_SIGNATURE_SHIFT          (0)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_SIGNATURE_GENC_FRAGMENT_SIGNATURE_LENGTH         (32)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_SIGNATURE_GENC_FRAGMENT_SIGNATURE_DEFAULT                (0)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_SIGNATURE_GENC_FRAGMENT_SIGNATURE_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_READ_SIGNATURE_OFFSET            (0x01D4)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_FRAGMENT_READ_SIGNATURE, GENC_FRAGMENT_READ_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_READ_SIGNATURE_GENC_FRAGMENT_READ_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_READ_SIGNATURE_GENC_FRAGMENT_READ_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_READ_SIGNATURE_GENC_FRAGMENT_READ_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_READ_SIGNATURE_GENC_FRAGMENT_READ_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_READ_SIGNATURE_GENC_FRAGMENT_READ_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_READ_SIGNATURE_GENC_FRAGMENT_READ_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_WRADDR_SIGNATURE_OFFSET          (0x01D8)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_FRAGMENT_WRADDR_SIGNATURE, GENC_FRAGMENT_WRADDR_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_WRADDR_SIGNATURE_GENC_FRAGMENT_WRADDR_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_WRADDR_SIGNATURE_GENC_FRAGMENT_WRADDR_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_WRADDR_SIGNATURE_GENC_FRAGMENT_WRADDR_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_WRADDR_SIGNATURE_GENC_FRAGMENT_WRADDR_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_ENTROPY_CR_GENC_FRAGMENT_WRADDR_SIGNATURE_GENC_FRAGMENT_WRADDR_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_ENTROPY_CR_GENC_FRAGMENT_WRADDR_SIGNATURE_GENC_FRAGMENT_WRADDR_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_GENC_ENGINE_OUTPUT_SIGNATURE_OFFSET            (0x01E0)
+
+/*
+ * PVDEC_ENTROPY, CR_GENC_ENGINE_OUTPUT_SIGNATURE, GENC_ENGINE_OUTPUT_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_GENC_ENGINE_OUTPUT_SIGNATURE_GENC_ENGINE_OUTPUT_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_ENGINE_OUTPUT_SIGNATURE_GENC_ENGINE_OUTPUT_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_GENC_ENGINE_OUTPUT_SIGNATURE_GENC_ENGINE_OUTPUT_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_GENC_ENGINE_OUTPUT_SIGNATURE_GENC_ENGINE_OUTPUT_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_ENTROPY_CR_GENC_ENGINE_OUTPUT_SIGNATURE_GENC_ENGINE_OUTPUT_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define PVDEC_ENTROPY_CR_GENC_ENGINE_OUTPUT_SIGNATURE_GENC_ENGINE_OUTPUT_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_HEVC_PARAMS_SIGNATURE_OFFSET           (0x01E4)
+
+/*
+ * PVDEC_ENTROPY, CR_HEVC_PARAMS_SIGNATURE, HEVC_PARAMS_SIGNATURE
+ */
+#define PVDEC_ENTROPY_CR_HEVC_PARAMS_SIGNATURE_HEVC_PARAMS_SIGNATURE_MASK               (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_HEVC_PARAMS_SIGNATURE_HEVC_PARAMS_SIGNATURE_LSBMASK            (0xFFFFFFFF)
+#define PVDEC_ENTROPY_CR_HEVC_PARAMS_SIGNATURE_HEVC_PARAMS_SIGNATURE_SHIFT              (0)
+#define PVDEC_ENTROPY_CR_HEVC_PARAMS_SIGNATURE_HEVC_PARAMS_SIGNATURE_LENGTH             (32)
+#define PVDEC_ENTROPY_CR_HEVC_PARAMS_SIGNATURE_HEVC_PARAMS_SIGNATURE_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_HEVC_PARAMS_SIGNATURE_HEVC_PARAMS_SIGNATURE_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_OFFSET          (0x01FC)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, HEVC_PARAMS_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARAMS_SIGNATURE_INIT_MASK         (0x00001000)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARAMS_SIGNATURE_INIT_LSBMASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARAMS_SIGNATURE_INIT_SHIFT                (12)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARAMS_SIGNATURE_INIT_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARAMS_SIGNATURE_INIT_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARAMS_SIGNATURE_INIT_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, HEVC_PARSER_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARSER_SIGNATURE_INIT_MASK         (0x00000800)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARSER_SIGNATURE_INIT_LSBMASK              (0x00000001)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARSER_SIGNATURE_INIT_SHIFT                (11)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARSER_SIGNATURE_INIT_LENGTH               (1)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARSER_SIGNATURE_INIT_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_HEVC_PARSER_SIGNATURE_INIT_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, ENCAP_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_ENCAP_SIGNATURE_INIT_MASK               (0x00000400)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_ENCAP_SIGNATURE_INIT_LSBMASK            (0x00000001)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_ENCAP_SIGNATURE_INIT_SHIFT              (10)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_ENCAP_SIGNATURE_INIT_LENGTH             (1)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_ENCAP_SIGNATURE_INIT_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_ENCAP_SIGNATURE_INIT_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, GENC_ENGINE_OUTPUT_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_ENGINE_OUTPUT_SIGNATURE_INIT_MASK          (0x00000100)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_ENGINE_OUTPUT_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_ENGINE_OUTPUT_SIGNATURE_INIT_SHIFT         (8)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_ENGINE_OUTPUT_SIGNATURE_INIT_LENGTH                (1)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_ENGINE_OUTPUT_SIGNATURE_INIT_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_ENGINE_OUTPUT_SIGNATURE_INIT_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, GENC_FRAGMENT_WRADDR_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_WRADDR_SIGNATURE_INIT_MASK \
+	( \
+		0x00000040)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_WRADDR_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_WRADDR_SIGNATURE_INIT_SHIFT               (6)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_WRADDR_SIGNATURE_INIT_LENGTH              (1)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_WRADDR_SIGNATURE_INIT_DEFAULT             (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_WRADDR_SIGNATURE_INIT_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, GENC_FRAGMENT_READ_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_READ_SIGNATURE_INIT_MASK          (0x00000020)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_READ_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_READ_SIGNATURE_INIT_SHIFT         (5)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_READ_SIGNATURE_INIT_LENGTH                (1)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_READ_SIGNATURE_INIT_DEFAULT               (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_READ_SIGNATURE_INIT_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, GENC_FRAGMENT_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_SIGNATURE_INIT_MASK               (0x00000010)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_SIGNATURE_INIT_LSBMASK            (0x00000001)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_SIGNATURE_INIT_SHIFT              (4)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_SIGNATURE_INIT_LENGTH             (1)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_SIGNATURE_INIT_DEFAULT            (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_FRAGMENT_SIGNATURE_INIT_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_ENTROPY, CR_SIGNATURE_INIT, GENC_BUFFER_SIGNATURE_INIT
+ */
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_BUFFER_SIGNATURE_INIT_MASK         (0x0000000F)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_BUFFER_SIGNATURE_INIT_LSBMASK              (0x0000000F)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_BUFFER_SIGNATURE_INIT_SHIFT                (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_BUFFER_SIGNATURE_INIT_LENGTH               (4)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_BUFFER_SIGNATURE_INIT_DEFAULT              (0)
+#define PVDEC_ENTROPY_CR_SIGNATURE_INIT_GENC_BUFFER_SIGNATURE_INIT_SIGNED_FIELD (IMG_FALSE)
+
+#endif
diff --git a/drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_hevc_regs.h b/drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_hevc_regs.h
new file mode 100644
index 000000000000..6d5f1cec79e6
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_hevc_regs.h
@@ -0,0 +1,1456 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * VXD DEC Common low level core interface component
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef __PVDEC_VEC_BE_HEVC_REGS_H__
+#define __PVDEC_VEC_BE_HEVC_REGS_H__
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_OFFSET             (0x0040)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_STRIDE             (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_NO_ENTRIES         (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_DPB_PIC_ORDER_DIFF, DPB_PIC_ORDER_DIFF_3
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_3_MASK          (0xFF000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_3_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_3_SHIFT         (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_3_LENGTH                (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_3_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_3_SIGNED_FIELD  (IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_DPB_PIC_ORDER_DIFF, DPB_PIC_ORDER_DIFF_2
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_2_MASK          (0x00FF0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_2_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_2_SHIFT         (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_2_LENGTH                (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_2_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_2_SIGNED_FIELD  (IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_DPB_PIC_ORDER_DIFF, DPB_PIC_ORDER_DIFF_1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_1_MASK          (0x0000FF00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_1_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_1_SHIFT         (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_1_LENGTH                (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_1_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_1_SIGNED_FIELD  (IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_DPB_PIC_ORDER_DIFF, DPB_PIC_ORDER_DIFF_0
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_0_MASK          (0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_0_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_0_SHIFT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_0_LENGTH                (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_0_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_PIC_ORDER_DIFF_DPB_PIC_ORDER_DIFF_0_SIGNED_FIELD  (IMG_TRUE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_OFFSET         (0x0050)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_STRIDE         (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_NO_ENTRIES             (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_COL_DPB_PIC_ORDER_DIFF, COL_DPB_PIC_ORDER_DIFF_3
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_3_MASK \
+	( \
+		0xFF000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_3_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_3_SHIFT         (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_3_LENGTH \
+	( \
+		8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_3_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_3_SIGNED_FIELD \
+	( \
+		IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_COL_DPB_PIC_ORDER_DIFF, COL_DPB_PIC_ORDER_DIFF_2
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_2_MASK \
+	( \
+		0x00FF0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_2_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_2_SHIFT         (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_2_LENGTH \
+	( \
+		8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_2_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_2_SIGNED_FIELD \
+	( \
+		IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_COL_DPB_PIC_ORDER_DIFF, COL_DPB_PIC_ORDER_DIFF_1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_1_MASK \
+	( \
+		0x0000FF00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_1_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_1_SHIFT         (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_1_LENGTH \
+	( \
+		8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_1_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_1_SIGNED_FIELD \
+	( \
+		IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_COL_DPB_PIC_ORDER_DIFF, COL_DPB_PIC_ORDER_DIFF_0
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_0_MASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_0_LSBMASK \
+	( \
+		0x000000FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_0_SHIFT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_0_LENGTH \
+	( \
+		8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_0_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_PIC_ORDER_DIFF_COL_DPB_PIC_ORDER_DIFF_0_SIGNED_FIELD \
+	( \
+		IMG_TRUE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_OFFSET           (0x0080)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_STRIDE           (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_NO_ENTRIES               (12)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_TILE_COLUMN_BOUNDARY, COLUMN_BOUNDARY_1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_1_MASK           (0x0FFF0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_1_LSBMASK \
+	( \
+		0x00000FFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_1_SHIFT          (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_1_LENGTH         (12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_1_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_1_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_TILE_COLUMN_BOUNDARY, COLUMN_BOUNDARY_0
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_0_MASK           (0x00000FFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_0_LSBMASK \
+	( \
+		0x00000FFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_0_SHIFT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_0_LENGTH         (12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_0_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_COLUMN_BOUNDARY_COLUMN_BOUNDARY_0_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_OFFSET              (0x00C0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_STRIDE              (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_NO_ENTRIES          (12)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_TILE_ROW_BOUNDARY, ROW_BOUNDARY_1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_1_MASK         (0x0FFF0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_1_LSBMASK              (0x00000FFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_1_SHIFT                (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_1_LENGTH               (12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_1_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_1_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_TILE_ROW_BOUNDARY, ROW_BOUNDARY_0
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_0_MASK         (0x00000FFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_0_LSBMASK              (0x00000FFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_0_SHIFT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_0_LENGTH               (12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_0_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TILE_ROW_BOUNDARY_ROW_BOUNDARY_0_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_OFFSET              (0x013C)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_STRIDE              (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_NO_ENTRIES          (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_12_15, REFPICLIST1_15
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_15_MASK         (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_15_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_15_SHIFT                (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_15_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_15_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_15_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_12_15, REFPICLIST1_14
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_14_MASK         (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_14_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_14_SHIFT                (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_14_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_14_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_14_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_12_15, REFPICLIST1_13
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_13_MASK         (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_13_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_13_SHIFT                (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_13_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_13_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_13_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_12_15, REFPICLIST1_12
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_12_MASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_12_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_12_SHIFT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_12_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_12_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_12_15_REFPICLIST1_12_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_OFFSET               (0x0138)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_STRIDE               (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_NO_ENTRIES           (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_8_11, REFPICLIST1_11
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_11_MASK          (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_11_LSBMASK               (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_11_SHIFT         (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_11_LENGTH                (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_11_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_11_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_8_11, REFPICLIST1_10
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_10_MASK          (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_10_LSBMASK               (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_10_SHIFT         (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_10_LENGTH                (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_10_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_10_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_8_11, REFPICLIST1_9
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_9_MASK           (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_9_LSBMASK                (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_9_SHIFT          (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_9_LENGTH         (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_9_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_9_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_8_11, REFPICLIST1_8
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_8_MASK           (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_8_LSBMASK                (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_8_SHIFT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_8_LENGTH         (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_8_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_8_11_REFPICLIST1_8_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_OFFSET                (0x0134)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_STRIDE                (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_NO_ENTRIES            (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_4_7, REFPICLIST1_7
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_7_MASK            (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_7_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_7_SHIFT           (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_7_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_7_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_7_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_4_7, REFPICLIST1_6
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_6_MASK            (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_6_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_6_SHIFT           (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_6_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_6_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_6_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_4_7, REFPICLIST1_5
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_5_MASK            (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_5_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_5_SHIFT           (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_5_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_5_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_5_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_4_7, REFPICLIST1_4
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_4_MASK            (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_4_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_4_SHIFT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_4_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_4_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_4_7_REFPICLIST1_4_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_OFFSET                (0x0130)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_STRIDE                (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_NO_ENTRIES            (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_0_3, REFPICLIST1_3
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_3_MASK            (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_3_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_3_SHIFT           (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_3_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_3_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_3_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_0_3, REFPICLIST1_2
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_2_MASK            (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_2_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_2_SHIFT           (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_2_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_2_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_2_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_0_3, REFPICLIST1_1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_1_MASK            (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_1_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_1_SHIFT           (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_1_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_1_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_1_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST1_0_3, REFPICLIST1_0
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_0_MASK            (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_0_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_0_SHIFT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_0_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_0_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST1_0_3_REFPICLIST1_0_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_OFFSET              (0x012C)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_STRIDE              (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_NO_ENTRIES          (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_12_15, REFPICLIST0_15
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_15_MASK         (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_15_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_15_SHIFT                (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_15_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_15_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_15_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_12_15, REFPICLIST0_14
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_14_MASK         (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_14_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_14_SHIFT                (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_14_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_14_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_14_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_12_15, REFPICLIST0_13
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_13_MASK         (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_13_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_13_SHIFT                (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_13_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_13_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_13_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_12_15, REFPICLIST0_12
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_12_MASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_12_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_12_SHIFT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_12_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_12_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_12_15_REFPICLIST0_12_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_OFFSET               (0x0128)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_STRIDE               (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_NO_ENTRIES           (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_8_11, REFPICLIST0_11
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_11_MASK          (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_11_LSBMASK               (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_11_SHIFT         (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_11_LENGTH                (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_11_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_11_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_8_11, REFPICLIST0_10
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_10_MASK          (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_10_LSBMASK               (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_10_SHIFT         (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_10_LENGTH                (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_10_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_10_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_8_11, REFPICLIST0_9
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_9_MASK           (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_9_LSBMASK                (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_9_SHIFT          (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_9_LENGTH         (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_9_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_9_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_8_11, REFPICLIST0_8
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_8_MASK           (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_8_LSBMASK                (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_8_SHIFT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_8_LENGTH         (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_8_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_8_11_REFPICLIST0_8_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_OFFSET                (0x0124)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_STRIDE                (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_NO_ENTRIES            (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_4_7, REFPICLIST0_7
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_7_MASK            (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_7_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_7_SHIFT           (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_7_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_7_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_7_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_4_7, REFPICLIST0_6
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_6_MASK            (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_6_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_6_SHIFT           (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_6_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_6_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_6_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_4_7, REFPICLIST0_5
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_5_MASK            (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_5_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_5_SHIFT           (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_5_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_5_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_5_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_4_7, REFPICLIST0_4
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_4_MASK            (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_4_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_4_SHIFT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_4_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_4_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_4_7_REFPICLIST0_4_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_OFFSET                (0x0120)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_STRIDE                (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_NO_ENTRIES            (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_0_3, REFPICLIST0_3
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_3_MASK            (0x0F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_3_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_3_SHIFT           (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_3_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_3_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_3_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_0_3, REFPICLIST0_2
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_2_MASK            (0x000F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_2_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_2_SHIFT           (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_2_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_2_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_2_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_0_3, REFPICLIST0_1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_1_MASK            (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_1_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_1_SHIFT           (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_1_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_1_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_1_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_LIST0_0_3, REFPICLIST0_0
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_0_MASK            (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_0_LSBMASK         (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_0_SHIFT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_0_LENGTH          (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_0_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_LIST0_0_3_REFPICLIST0_0_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_OFFSET          (0x0108)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_STRIDE          (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_NO_ENTRIES              (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_2, INDEPENDENT_SLICE_MB_NO_Y
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_Y_MASK          (0x0007FC00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_Y_LSBMASK \
+	( \
+		0x000001FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_Y_SHIFT         (10)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_Y_LENGTH                (9)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_Y_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_Y_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_2, INDEPENDENT_SLICE_MB_NO_X
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_X_MASK          (0x000001FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_X_LSBMASK \
+	( \
+		0x000001FF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_X_SHIFT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_X_LENGTH                (9)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_X_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_2_INDEPENDENT_SLICE_MB_NO_X_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_OFFSET          (0x0104)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_STRIDE          (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_NO_ENTRIES              (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_1, EXT_INDEPENDENT_SLICE_MB_NO_Y
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_Y_MASK \
+	( \
+		0xE0000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_Y_LSBMASK \
+	( \
+		0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_Y_SHIFT             (29)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_Y_LENGTH            (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_Y_DEFAULT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_Y_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_1, EXT_INDEPENDENT_SLICE_MB_NO_X
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_X_MASK \
+	( \
+		0x1C000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_X_LSBMASK \
+	( \
+		0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_X_SHIFT             (26)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_X_LENGTH            (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_X_DEFAULT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_EXT_INDEPENDENT_SLICE_MB_NO_X_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_1, SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_MASK \
+	( \
+		0x01000000)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_SHIFT \
+	( \
+		24)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_LENGTH \
+	( \
+		1)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_LOOP_FILTER_ACROSS_SLICES_ENABLED_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_1, SLICE_CR_QP_OFFSET
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CR_QP_OFFSET_MASK         (0x001F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CR_QP_OFFSET_LSBMASK              (0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CR_QP_OFFSET_SHIFT                (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CR_QP_OFFSET_LENGTH               (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CR_QP_OFFSET_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CR_QP_OFFSET_SIGNED_FIELD (IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_1, SLICE_CB_QP_OFFSET
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CB_QP_OFFSET_MASK         (0x00001F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CB_QP_OFFSET_LSBMASK              (0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CB_QP_OFFSET_SHIFT                (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CB_QP_OFFSET_LENGTH               (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CB_QP_OFFSET_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_CB_QP_OFFSET_SIGNED_FIELD (IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_1, SLICE_QPY
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_QPY_MASK          (0x0000007F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_QPY_LSBMASK               (0x0000007F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_QPY_SHIFT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_QPY_LENGTH                (7)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_QPY_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_1_SLICE_QPY_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_OFFSET          (0x0100)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_STRIDE          (64)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NO_ENTRIES              (4)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, MAX_NUM_MERGE_CAND
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MAX_NUM_MERGE_CAND_MASK         (0x00700000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MAX_NUM_MERGE_CAND_LSBMASK              (0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MAX_NUM_MERGE_CAND_SHIFT                (20)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MAX_NUM_MERGE_CAND_LENGTH               (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MAX_NUM_MERGE_CAND_DEFAULT              (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MAX_NUM_MERGE_CAND_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, CU_CHROMA_QP_OFFSET_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_CU_CHROMA_QP_OFFSET_ENABLED_FLAG_MASK \
+	( \
+		0x00080000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_CU_CHROMA_QP_OFFSET_ENABLED_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_CU_CHROMA_QP_OFFSET_ENABLED_FLAG_SHIFT          (19)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_CU_CHROMA_QP_OFFSET_ENABLED_FLAG_LENGTH         (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_CU_CHROMA_QP_OFFSET_ENABLED_FLAG_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_CU_CHROMA_QP_OFFSET_ENABLED_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, COLLOCATED_FROM_L0_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_COLLOCATED_FROM_L0_FLAG_MASK            (0x00040000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_COLLOCATED_FROM_L0_FLAG_LSBMASK         (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_COLLOCATED_FROM_L0_FLAG_SHIFT           (18)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_COLLOCATED_FROM_L0_FLAG_LENGTH          (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_COLLOCATED_FROM_L0_FLAG_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_COLLOCATED_FROM_L0_FLAG_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, MVD_L1_ZERO_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MVD_L1_ZERO_FLAG_MASK           (0x00010000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MVD_L1_ZERO_FLAG_LSBMASK                (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MVD_L1_ZERO_FLAG_SHIFT          (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MVD_L1_ZERO_FLAG_LENGTH         (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MVD_L1_ZERO_FLAG_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_MVD_L1_ZERO_FLAG_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, NUM_REF_IDX_L1_ACTIVE_MINUS1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L1_ACTIVE_MINUS1_MASK \
+	( \
+		0x0000F000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L1_ACTIVE_MINUS1_LSBMASK \
+	( \
+		0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L1_ACTIVE_MINUS1_SHIFT              (12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L1_ACTIVE_MINUS1_LENGTH             (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L1_ACTIVE_MINUS1_DEFAULT            (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L1_ACTIVE_MINUS1_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, NUM_REF_IDX_L0_ACTIVE_MINUS1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L0_ACTIVE_MINUS1_MASK \
+	( \
+		0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L0_ACTIVE_MINUS1_LSBMASK \
+	( \
+		0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L0_ACTIVE_MINUS1_SHIFT              (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L0_ACTIVE_MINUS1_LENGTH             (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L0_ACTIVE_MINUS1_DEFAULT            (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_NUM_REF_IDX_L0_ACTIVE_MINUS1_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, SLICE_TEMPORAL_MVP_ENABLE_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TEMPORAL_MVP_ENABLE_FLAG_MASK \
+	( \
+		0x00000010)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TEMPORAL_MVP_ENABLE_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TEMPORAL_MVP_ENABLE_FLAG_SHIFT            (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TEMPORAL_MVP_ENABLE_FLAG_LENGTH           (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TEMPORAL_MVP_ENABLE_FLAG_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TEMPORAL_MVP_ENABLE_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, SLICE_SAO_CHROMA_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_CHROMA_FLAG_MASK              (0x00000008)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_CHROMA_FLAG_LSBMASK           (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_CHROMA_FLAG_SHIFT             (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_CHROMA_FLAG_LENGTH            (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_CHROMA_FLAG_DEFAULT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_CHROMA_FLAG_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, SLICE_SAO_LUMA_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_LUMA_FLAG_MASK                (0x00000004)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_LUMA_FLAG_LSBMASK             (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_LUMA_FLAG_SHIFT               (2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_LUMA_FLAG_LENGTH              (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_LUMA_FLAG_DEFAULT             (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_SAO_LUMA_FLAG_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SLICE_PARAM_0, SLICE_TYPE
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TYPE_MASK         (0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TYPE_LSBMASK              (0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TYPE_SHIFT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TYPE_LENGTH               (2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TYPE_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SLICE_PARAM_0_SLICE_TYPE_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_OFFSET            (0x0000)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, SCALING_LIST_ENABLE_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_SCALING_LIST_ENABLE_FLAG_MASK             (0x80000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_SCALING_LIST_ENABLE_FLAG_LSBMASK          (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_SCALING_LIST_ENABLE_FLAG_SHIFT            (31)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_SCALING_LIST_ENABLE_FLAG_LENGTH           (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_SCALING_LIST_ENABLE_FLAG_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_SCALING_LIST_ENABLE_FLAG_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA_MASK \
+	( \
+		0x70000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA_LSBMASK \
+	( \
+		0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA_SHIFT         (28)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA_LENGTH \
+	( \
+		3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTRA_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, MAX_TRANSFORM_HIERARCHY_DEPTH_INTER
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER_MASK \
+	( \
+		0x07000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER_LSBMASK \
+	( \
+		0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER_SHIFT         (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER_LENGTH \
+	( \
+		3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_MAX_TRANSFORM_HIERARCHY_DEPTH_INTER_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE_MASK \
+	( \
+		0x00300000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE_SHIFT \
+	( \
+		20)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE_LENGTH \
+	( \
+		2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_TRANSFORM_BLOCK_SIZE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2_MASK \
+	( \
+		0x00030000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2_SHIFT \
+	( \
+		16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2_LENGTH \
+	( \
+		2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_TRANSFORM_BLOCK_SIZE_MINUS2_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE_MASK \
+	( \
+		0x00003000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE_SHIFT \
+	( \
+		12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE_LENGTH \
+	( \
+		2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_DIFF_MAX_MIN_LUMA_CODING_BLOCK_SIZE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3_MASK \
+	( \
+		0x00000300)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3_SHIFT \
+	( \
+		8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3_LENGTH \
+	( \
+		2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_LOG2_MIN_LUMA_CODING_BLOCK_SIZE_MINUS3_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, BIT_DEPTH_CHROMA_MINUS8
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_CHROMA_MINUS8_MASK              (0x00000070)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_CHROMA_MINUS8_LSBMASK           (0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_CHROMA_MINUS8_SHIFT             (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_CHROMA_MINUS8_LENGTH            (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_CHROMA_MINUS8_DEFAULT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_CHROMA_MINUS8_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_0, BIT_DEPTH_LUMA_MINUS8
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_LUMA_MINUS8_MASK                (0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_LUMA_MINUS8_LSBMASK             (0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_LUMA_MINUS8_SHIFT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_LUMA_MINUS8_LENGTH              (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_LUMA_MINUS8_DEFAULT             (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_0_BIT_DEPTH_LUMA_MINUS8_SIGNED_FIELD        (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_OFFSET            (0x0004)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, TRANSFORM_SKIP_ROTATION_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_TRANSFORM_SKIP_ROTATION_ENABLED_FLAG_MASK \
+	( \
+		0x00800000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_TRANSFORM_SKIP_ROTATION_ENABLED_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_TRANSFORM_SKIP_ROTATION_ENABLED_FLAG_SHIFT \
+	( \
+		23)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_TRANSFORM_SKIP_ROTATION_ENABLED_FLAG_LENGTH \
+	( \
+		1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_TRANSFORM_SKIP_ROTATION_ENABLED_FLAG_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_TRANSFORM_SKIP_ROTATION_ENABLED_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, IMPLICIT_RDPCM_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_IMPLICIT_RDPCM_ENABLED_FLAG_MASK          (0x00080000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_IMPLICIT_RDPCM_ENABLED_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_IMPLICIT_RDPCM_ENABLED_FLAG_SHIFT         (19)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_IMPLICIT_RDPCM_ENABLED_FLAG_LENGTH                (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_IMPLICIT_RDPCM_ENABLED_FLAG_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_IMPLICIT_RDPCM_ENABLED_FLAG_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, EXPLICIT_RDPCM_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXPLICIT_RDPCM_ENABLED_FLAG_MASK          (0x00040000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXPLICIT_RDPCM_ENABLED_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXPLICIT_RDPCM_ENABLED_FLAG_SHIFT         (18)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXPLICIT_RDPCM_ENABLED_FLAG_LENGTH                (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXPLICIT_RDPCM_ENABLED_FLAG_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXPLICIT_RDPCM_ENABLED_FLAG_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, EXTENDED_PRECISION_PROCESSING_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXTENDED_PRECISION_PROCESSING_FLAG_MASK \
+	( \
+		0x00020000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXTENDED_PRECISION_PROCESSING_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXTENDED_PRECISION_PROCESSING_FLAG_SHIFT          (17)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXTENDED_PRECISION_PROCESSING_FLAG_LENGTH         (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXTENDED_PRECISION_PROCESSING_FLAG_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_EXTENDED_PRECISION_PROCESSING_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, SPS_TEMPORAL_MVP_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_SPS_TEMPORAL_MVP_ENABLED_FLAG_MASK \
+	( \
+		0x00010000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_SPS_TEMPORAL_MVP_ENABLED_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_SPS_TEMPORAL_MVP_ENABLED_FLAG_SHIFT               (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_SPS_TEMPORAL_MVP_ENABLED_FLAG_LENGTH              (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_SPS_TEMPORAL_MVP_ENABLED_FLAG_DEFAULT             (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_SPS_TEMPORAL_MVP_ENABLED_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, PCM_BIT_DEPTH_CHROMA
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_CHROMA_MASK         (0x0000F000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_CHROMA_LSBMASK              (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_CHROMA_SHIFT                (12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_CHROMA_LENGTH               (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_CHROMA_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_CHROMA_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, PCM_BIT_DEPTH_LUMA
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_LUMA_MASK           (0x00000F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_LUMA_LSBMASK                (0x0000000F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_LUMA_SHIFT          (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_LUMA_LENGTH         (4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_LUMA_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_BIT_DEPTH_LUMA_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MASK \
+	( \
+		0x000000C0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE_SHIFT \
+	( \
+		6)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE_LENGTH \
+	( \
+		2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_DIFF_MAX_MIN_PCM_LUMA_CODING_BLOCK_SIZE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3_MASK \
+	( \
+		0x00000030)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3_SHIFT \
+	( \
+		4)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3_LENGTH \
+	( \
+		2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_LOG2_MIN_PCM_LUMA_CODING_BLOCK_SIZE_MINUS3_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, PCM_LOOP_FILTER_DISABLE_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_LOOP_FILTER_DISABLE_FLAG_MASK         (0x00000004)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_LOOP_FILTER_DISABLE_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_LOOP_FILTER_DISABLE_FLAG_SHIFT                (2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_LOOP_FILTER_DISABLE_FLAG_LENGTH               (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_LOOP_FILTER_DISABLE_FLAG_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_LOOP_FILTER_DISABLE_FLAG_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, PCM_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_ENABLED_FLAG_MASK             (0x00000002)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_ENABLED_FLAG_LSBMASK          (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_ENABLED_FLAG_SHIFT            (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_ENABLED_FLAG_LENGTH           (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_ENABLED_FLAG_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_PCM_ENABLED_FLAG_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_SPS_PARAM_1, AMP_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_AMP_ENABLED_FLAG_MASK             (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_AMP_ENABLED_FLAG_LSBMASK          (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_AMP_ENABLED_FLAG_SHIFT            (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_AMP_ENABLED_FLAG_LENGTH           (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_AMP_ENABLED_FLAG_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_SPS_PARAM_1_AMP_ENABLED_FLAG_SIGNED_FIELD     (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_OFFSET            (0x0008)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, NUM_TILE_ROWS_MINUS1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_ROWS_MINUS1_MASK         (0x1F000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_ROWS_MINUS1_LSBMASK              (0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_ROWS_MINUS1_SHIFT                (24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_ROWS_MINUS1_LENGTH               (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_ROWS_MINUS1_DEFAULT              (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_ROWS_MINUS1_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, NUM_TILE_COLUMNS_MINUS1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_COLUMNS_MINUS1_MASK              (0x001F0000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_COLUMNS_MINUS1_LSBMASK           (0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_COLUMNS_MINUS1_SHIFT             (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_COLUMNS_MINUS1_LENGTH            (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_COLUMNS_MINUS1_DEFAULT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_NUM_TILE_COLUMNS_MINUS1_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, DIFF_CU_CHROMA_QP_OFFSET_DEPTH
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_DIFF_CU_CHROMA_QP_OFFSET_DEPTH_MASK \
+	( \
+		0x00003000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_DIFF_CU_CHROMA_QP_OFFSET_DEPTH_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_DIFF_CU_CHROMA_QP_OFFSET_DEPTH_SHIFT              (12)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_DIFF_CU_CHROMA_QP_OFFSET_DEPTH_LENGTH             (2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_DIFF_CU_CHROMA_QP_OFFSET_DEPTH_DEFAULT            (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_DIFF_CU_CHROMA_QP_OFFSET_DEPTH_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, ENTROPY_CODING_SYNC_ENABLE_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_ENTROPY_CODING_SYNC_ENABLE_FLAG_MASK \
+	( \
+		0x00000400)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_ENTROPY_CODING_SYNC_ENABLE_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_ENTROPY_CODING_SYNC_ENABLE_FLAG_SHIFT             (10)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_ENTROPY_CODING_SYNC_ENABLE_FLAG_LENGTH            (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_ENTROPY_CODING_SYNC_ENABLE_FLAG_DEFAULT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_ENTROPY_CODING_SYNC_ENABLE_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, TILES_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TILES_ENABLED_FLAG_MASK           (0x00000200)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TILES_ENABLED_FLAG_LSBMASK                (0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TILES_ENABLED_FLAG_SHIFT          (9)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TILES_ENABLED_FLAG_LENGTH         (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TILES_ENABLED_FLAG_DEFAULT                (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TILES_ENABLED_FLAG_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, TRANSQUANT_BYPASS_ENABLE_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSQUANT_BYPASS_ENABLE_FLAG_MASK \
+	( \
+		0x00000100)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSQUANT_BYPASS_ENABLE_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSQUANT_BYPASS_ENABLE_FLAG_SHIFT               (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSQUANT_BYPASS_ENABLE_FLAG_LENGTH              (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSQUANT_BYPASS_ENABLE_FLAG_DEFAULT             (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSQUANT_BYPASS_ENABLE_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, TRANSFORM_SKIP_ENABLED_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSFORM_SKIP_ENABLED_FLAG_MASK          (0x00000004)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSFORM_SKIP_ENABLED_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSFORM_SKIP_ENABLED_FLAG_SHIFT         (2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSFORM_SKIP_ENABLED_FLAG_LENGTH                (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSFORM_SKIP_ENABLED_FLAG_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_TRANSFORM_SKIP_ENABLED_FLAG_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_0, CROSS_COMPONENT_PREDICTION_FLAG
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_CROSS_COMPONENT_PREDICTION_FLAG_MASK \
+	( \
+		0x00000002)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_CROSS_COMPONENT_PREDICTION_FLAG_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_CROSS_COMPONENT_PREDICTION_FLAG_SHIFT             (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_CROSS_COMPONENT_PREDICTION_FLAG_LENGTH            (1)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_CROSS_COMPONENT_PREDICTION_FLAG_DEFAULT           (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_0_CROSS_COMPONENT_PREDICTION_FLAG_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_OFFSET            (0x000C)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_1, LOG2_MAX_TRANSFORM_SKIP_BLOCK_SIZE_MINUS2
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_MAX_TRANSFORM_SKIP_BLOCK_SIZE_MINUS2_MASK \
+	( \
+		0x03000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_MAX_TRANSFORM_SKIP_BLOCK_SIZE_MINUS2_LSBMASK \
+	( \
+		0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_MAX_TRANSFORM_SKIP_BLOCK_SIZE_MINUS2_SHIFT \
+	( \
+		24)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_MAX_TRANSFORM_SKIP_BLOCK_SIZE_MINUS2_LENGTH \
+	( \
+		2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_MAX_TRANSFORM_SKIP_BLOCK_SIZE_MINUS2_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_MAX_TRANSFORM_SKIP_BLOCK_SIZE_MINUS2_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_1, CHROMA_QP_OFFSET_LIST_LEN_MINUS1
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_CHROMA_QP_OFFSET_LIST_LEN_MINUS1_MASK \
+	( \
+		0x00700000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_CHROMA_QP_OFFSET_LIST_LEN_MINUS1_LSBMASK \
+	( \
+		0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_CHROMA_QP_OFFSET_LIST_LEN_MINUS1_SHIFT            (20)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_CHROMA_QP_OFFSET_LIST_LEN_MINUS1_LENGTH           (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_CHROMA_QP_OFFSET_LIST_LEN_MINUS1_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_CHROMA_QP_OFFSET_LIST_LEN_MINUS1_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_1, LOG2_PARALLEL_MERGE_LEVEL_MINUS2
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_MASK \
+	( \
+		0x00070000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_LSBMASK \
+	( \
+		0x00000007)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_SHIFT            (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_LENGTH           (3)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_1, PIC_CR_QP_OFFSET
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CR_QP_OFFSET_MASK             (0x00001F00)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CR_QP_OFFSET_LSBMASK          (0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CR_QP_OFFSET_SHIFT            (8)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CR_QP_OFFSET_LENGTH           (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CR_QP_OFFSET_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CR_QP_OFFSET_SIGNED_FIELD     (IMG_TRUE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_PPS_PARAM_1, PIC_CB_QP_OFFSET
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CB_QP_OFFSET_MASK             (0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CB_QP_OFFSET_LSBMASK          (0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CB_QP_OFFSET_SHIFT            (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CB_QP_OFFSET_LENGTH           (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CB_QP_OFFSET_DEFAULT          (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_PPS_PARAM_1_PIC_CB_QP_OFFSET_SIGNED_FIELD     (IMG_TRUE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_OFFSET              (0x0010)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_CB_QP_OFFSET_LIST, PPS_CB_QP_OFFSET_LIST
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_MASK          (0x3E000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_LSBMASK \
+	( \
+		0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_SHIFT         (25)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_LENGTH                (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_SIGNED_FIELD  (IMG_TRUE)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_NO_REPS               (6)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CB_QP_OFFSET_LIST_PPS_CB_QP_OFFSET_LIST_SIZE          (5)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_OFFSET              (0x0014)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_CR_QP_OFFSET_LIST, PPS_CR_QP_OFFSET_LIST
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_MASK          (0x3E000000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_LSBMASK \
+	( \
+		0x0000001F)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_SHIFT         (25)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_LENGTH                (5)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_DEFAULT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_SIGNED_FIELD  (IMG_TRUE)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_NO_REPS               (6)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_CR_QP_OFFSET_LIST_PPS_CR_QP_OFFSET_LIST_SIZE          (5)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_IN_BASE_ADDRESS_OFFSET               (0x0030)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_TEMPORAL_IN_BASE_ADDRESS, TEMPORAL_PARAM_IN_BASE_ADDRESS
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_IN_BASE_ADDRESS_TEMPORAL_PARAM_IN_BASE_ADDRESS_MASK \
+	( \
+		0xFFFFFFC0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_IN_BASE_ADDRESS_TEMPORAL_PARAM_IN_BASE_ADDRESS_LSBMASK \
+	( \
+		0x03FFFFFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_IN_BASE_ADDRESS_TEMPORAL_PARAM_IN_BASE_ADDRESS_SHIFT \
+	( \
+		6)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_IN_BASE_ADDRESS_TEMPORAL_PARAM_IN_BASE_ADDRESS_LENGTH \
+	( \
+		26)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_IN_BASE_ADDRESS_TEMPORAL_PARAM_IN_BASE_ADDRESS_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_IN_BASE_ADDRESS_TEMPORAL_PARAM_IN_BASE_ADDRESS_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS_OFFSET              (0x0034)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS, TEMPORAL_PARAM_OUT_BASE_ADDRESS
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS_TEMPORAL_PARAM_OUT_BASE_ADDRESS_MASK \
+	( \
+		0xFFFFFFC0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS_TEMPORAL_PARAM_OUT_BASE_ADDRESS_LSBMASK \
+	( \
+		0x03FFFFFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS_TEMPORAL_PARAM_OUT_BASE_ADDRESS_SHIFT \
+	( \
+		6)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS_TEMPORAL_PARAM_OUT_BASE_ADDRESS_LENGTH \
+	( \
+		26)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS_TEMPORAL_PARAM_OUT_BASE_ADDRESS_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_HEVC_CR_HEVC_TEMPORAL_OUT_BASE_ADDRESS_TEMPORAL_PARAM_OUT_BASE_ADDRESS_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_OFFSET           (0x0038)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_DPB_LONGTERM, PIC_TYPE
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_PIC_TYPE_MASK            (0x00030000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_PIC_TYPE_LSBMASK         (0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_PIC_TYPE_SHIFT           (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_PIC_TYPE_LENGTH          (2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_PIC_TYPE_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_PIC_TYPE_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_DPB_LONGTERM, DPB_LONGTERM
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_DPB_LONGTERM_MASK                (0x0000FFFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_DPB_LONGTERM_LSBMASK             (0x0000FFFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_DPB_LONGTERM_SHIFT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_DPB_LONGTERM_LENGTH              (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_DPB_LONGTERM_DEFAULT             (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_DPB_LONGTERM_DPB_LONGTERM_SIGNED_FIELD        (IMG_FALSE)
+
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_OFFSET               (0x003C)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_COL_DPB_LONGTERM, COL_PIC_TYPE
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_PIC_TYPE_MASK            (0x00030000)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_PIC_TYPE_LSBMASK         (0x00000003)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_PIC_TYPE_SHIFT           (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_PIC_TYPE_LENGTH          (2)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_PIC_TYPE_DEFAULT         (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_PIC_TYPE_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE_HEVC, CR_HEVC_COL_DPB_LONGTERM, COL_DPB_LONGTERM
+ */
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_DPB_LONGTERM_MASK                (0x0000FFFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_DPB_LONGTERM_LSBMASK             (0x0000FFFF)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_DPB_LONGTERM_SHIFT               (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_DPB_LONGTERM_LENGTH              (16)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_DPB_LONGTERM_DEFAULT             (0)
+#define PVDEC_VEC_BE_HEVC_CR_HEVC_COL_DPB_LONGTERM_COL_DPB_LONGTERM_SIGNED_FIELD        (IMG_FALSE)
+
+#endif
diff --git a/drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_regs.h b/drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_regs.h
new file mode 100644
index 000000000000..0d662ccb0aea
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/pvdec_vec_be_regs.h
@@ -0,0 +1,1001 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * VXD DEC Common low level core interface component
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#ifndef __PVDEC_VEC_BE_REGS_H__
+#define __PVDEC_VEC_BE_REGS_H__
+
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_OFFSET         (0x0040)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_STRIDE         (4)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_NO_ENTRIES             (4)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_BUFFER_SIZE, GENC_BUFFER_SIZE
+ */
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_MASK          (0x0FFFF000)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_LSBMASK               (0x0000FFFF)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_SHIFT         (12)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_LENGTH                (16)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_SIZE_GENC_BUFFER_SIZE_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_OFFSET         (0x0050)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_STRIDE         (4)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_NO_ENTRIES             (4)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_BUFFER_BASE_ADDRESS, GENC_BASE_ADDRESS
+ */
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_MASK         (0xFFFFF000)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_LSBMASK              (0x000FFFFF)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_SHIFT                (12)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_LENGTH               (20)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_DEFAULT              (0)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_BASE_ADDRESS_GENC_BASE_ADDRESS_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_OFFSET         (0x0060)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_STRIDE         (4)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_NO_ENTRIES             (4)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_BUFFER_READ_POINTER, GENC_READ_POINTER
+ */
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_MASK         (0x0FFFFFF0)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_LSBMASK              (0x00FFFFFF)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_SHIFT                (4)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_LENGTH               (24)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_DEFAULT              (0)
+#define PVDEC_VEC_BE_CR_GENC_BUFFER_READ_POINTER_GENC_READ_POINTER_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_OFFSET            (0x0180)
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_STRIDE            (4)
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_NO_ENTRIES                (4)
+
+/*
+ * PVDEC_VEC_BE, CR_GDEC_BUFFER_SIGNATURE, GDEC_BUFFER_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_GDEC_BUFFER_SIGNATURE_MASK                (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_GDEC_BUFFER_SIGNATURE_LSBMASK             (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_GDEC_BUFFER_SIGNATURE_SHIFT               (0)
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_GDEC_BUFFER_SIGNATURE_LENGTH              (32)
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_GDEC_BUFFER_SIGNATURE_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_GDEC_BUFFER_SIGNATURE_GDEC_BUFFER_SIGNATURE_SIGNED_FIELD        (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_OFFSET          (0x01D0)
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_STRIDE          (4)
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_NO_ENTRIES              (4)
+
+/*
+ * PVDEC_VEC_BE, CR_GDEC_DATA_REQ_SIGNATURE, GDEC_DATA_REQ_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_GDEC_DATA_REQ_SIGNATURE_MASK            (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_GDEC_DATA_REQ_SIGNATURE_LSBMASK         (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_GDEC_DATA_REQ_SIGNATURE_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_GDEC_DATA_REQ_SIGNATURE_LENGTH          (32)
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_GDEC_DATA_REQ_SIGNATURE_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_GDEC_DATA_REQ_SIGNATURE_GDEC_DATA_REQ_SIGNATURE_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_OFFSET           (0x0000)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CONTROL, BE_CHROMA_FORMAT
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CHROMA_FORMAT_MASK            (0x70000000)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CHROMA_FORMAT_LSBMASK         (0x00000007)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CHROMA_FORMAT_SHIFT           (28)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CHROMA_FORMAT_LENGTH          (3)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CHROMA_FORMAT_DEFAULT         (1)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CHROMA_FORMAT_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CONTROL, BE_PROFILE
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_PROFILE_MASK          (0x07000000)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_PROFILE_LSBMASK               (0x00000007)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_PROFILE_SHIFT         (24)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_PROFILE_LENGTH                (3)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_PROFILE_DEFAULT               (1)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_PROFILE_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CONTROL, BE_CODEC_MODE
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CODEC_MODE_MASK               (0x000F0000)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CODEC_MODE_LSBMASK            (0x0000000F)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CODEC_MODE_SHIFT              (16)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CODEC_MODE_LENGTH             (4)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CODEC_MODE_DEFAULT            (12)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_CODEC_MODE_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CONTROL, BE_FRAGMENT_ROW_EXT
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_EXT_MASK         (0x00003000)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_EXT_LSBMASK              (0x00000003)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_EXT_SHIFT                (12)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_EXT_LENGTH               (2)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_EXT_DEFAULT              (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_EXT_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CONTROL, BE_GENC_ENABLE
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_GENC_ENABLE_MASK              (0x00000100)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_GENC_ENABLE_LSBMASK           (0x00000001)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_GENC_ENABLE_SHIFT             (8)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_GENC_ENABLE_LENGTH            (1)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_GENC_ENABLE_DEFAULT           (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_GENC_ENABLE_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CONTROL, BE_FRAGMENT_ROW
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_MASK             (0x000000FF)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_LSBMASK          (0x000000FF)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_SHIFT            (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_LENGTH           (8)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_DEFAULT          (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_CONTROL_BE_FRAGMENT_ROW_SIGNED_FIELD     (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_OFFSET               (0x0004)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_MULTIPIPE_OPERATION, PIPE_NUMBER
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_PIPE_NUMBER_MASK             (0x00000700)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_PIPE_NUMBER_LSBMASK          (0x00000007)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_PIPE_NUMBER_SHIFT            (8)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_PIPE_NUMBER_LENGTH           (3)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_PIPE_NUMBER_DEFAULT          (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_PIPE_NUMBER_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_MULTIPIPE_OPERATION, NUM_PIXEL_PIPES
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_NUM_PIXEL_PIPES_MASK         (0x00000007)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_NUM_PIXEL_PIPES_LSBMASK              (0x00000007)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_NUM_PIXEL_PIPES_SHIFT                (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_NUM_PIXEL_PIPES_LENGTH               (3)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_NUM_PIXEL_PIPES_DEFAULT              (1)
+#define PVDEC_VEC_BE_CR_VEC_BE_MULTIPIPE_OPERATION_NUM_PIXEL_PIPES_SIGNED_FIELD (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_OFFSET                (0x0010)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CODED_PICTURE_SIZE, PIC_HEIGHT_MIN1
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_HEIGHT_MIN1_MASK          (0xFFFF0000)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_HEIGHT_MIN1_LSBMASK               (0x0000FFFF)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_HEIGHT_MIN1_SHIFT         (16)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_HEIGHT_MIN1_LENGTH                (16)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_HEIGHT_MIN1_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_HEIGHT_MIN1_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_CODED_PICTURE_SIZE, PIC_WIDTH_MIN1
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_WIDTH_MIN1_MASK           (0x0000FFFF)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_WIDTH_MIN1_LSBMASK                (0x0000FFFF)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_WIDTH_MIN1_SHIFT          (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_WIDTH_MIN1_LENGTH         (16)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_WIDTH_MIN1_DEFAULT                (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_CODED_PICTURE_SIZE_PIC_WIDTH_MIN1_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_OFFSET            (0x0018)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_STATUS, COMMAND_MB_ADDR_Y
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_Y_MASK            (0x0FFF0000)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_Y_LSBMASK         (0x00000FFF)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_Y_SHIFT           (16)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_Y_LENGTH          (12)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_Y_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_Y_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_VEC_BE_STATUS, COMMAND_MB_ADDR_X
+ */
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_X_MASK            (0x00000FFF)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_X_LSBMASK         (0x00000FFF)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_X_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_X_LENGTH          (12)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_X_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_VEC_BE_STATUS_COMMAND_MB_ADDR_X_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_BASE_ADDRESS_OFFSET          (0x0020)
+
+/*
+ * PVDEC_VEC_BE, CR_MEM_TO_REG_BASE_ADDRESS, MEM_TO_REG_BASE_ADDRESS
+ */
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_BASE_ADDRESS_MEM_TO_REG_BASE_ADDRESS_MASK            (0xFFFFFFC0)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_BASE_ADDRESS_MEM_TO_REG_BASE_ADDRESS_LSBMASK         (0x03FFFFFF)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_BASE_ADDRESS_MEM_TO_REG_BASE_ADDRESS_SHIFT           (6)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_BASE_ADDRESS_MEM_TO_REG_BASE_ADDRESS_LENGTH          (26)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_BASE_ADDRESS_MEM_TO_REG_BASE_ADDRESS_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_BASE_ADDRESS_MEM_TO_REG_BASE_ADDRESS_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_OFFSET               (0x0024)
+
+/*
+ * PVDEC_VEC_BE, CR_MEM_TO_REG_CONTROL, MEM_TO_REG_ENABLE
+ */
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_ENABLE_MASK               (0x00010000)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_ENABLE_LSBMASK            (0x00000001)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_ENABLE_SHIFT              (16)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_ENABLE_LENGTH             (1)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_ENABLE_DEFAULT            (0)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_ENABLE_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_MEM_TO_REG_CONTROL, MEM_TO_REG_NUM_PAIRS
+ */
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_NUM_PAIRS_MASK            (0x000003FF)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_NUM_PAIRS_LSBMASK         (0x000003FF)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_NUM_PAIRS_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_NUM_PAIRS_LENGTH          (10)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_NUM_PAIRS_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_MEM_TO_REG_CONTROL_MEM_TO_REG_NUM_PAIRS_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GENC_FRAGMENT_BASE_ADDRESS_OFFSET               (0x0030)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_FRAGMENT_BASE_ADDRESS, FRAGMENT_BASE_ADDRESS
+ */
+#define PVDEC_VEC_BE_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_MASK           (0xFFFFFFC0)
+#define PVDEC_VEC_BE_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_LSBMASK \
+	( \
+		0x03FFFFFF)
+#define PVDEC_VEC_BE_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_SHIFT          (6)
+#define PVDEC_VEC_BE_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_LENGTH         (26)
+#define PVDEC_VEC_BE_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_DEFAULT                (0)
+#define PVDEC_VEC_BE_CR_GENC_FRAGMENT_BASE_ADDRESS_FRAGMENT_BASE_ADDRESS_SIGNED_FIELD   (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_OFFSET            (0x0080)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_CONTEXT0, GENC_CONTEXT0_3
+ */
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_MASK              (0x003F0000)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_LSBMASK           (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_SHIFT             (16)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_LENGTH            (6)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_DEFAULT           (16)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_3_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_CONTEXT0, GENC_CONTEXT0_2
+ */
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_MASK              (0x00003F00)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_LSBMASK           (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_SHIFT             (8)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_LENGTH            (6)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_DEFAULT           (16)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_2_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_CONTEXT0, GENC_CONTEXT0_1
+ */
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_MASK              (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_LSBMASK           (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_SHIFT             (0)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_LENGTH            (6)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_DEFAULT           (16)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT0_GENC_CONTEXT0_1_SIGNED_FIELD      (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_OFFSET            (0x0084)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_CONTEXT1, GENC_CONTEXT1_3
+ */
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_MASK              (0x003F0000)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_LSBMASK           (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_SHIFT             (16)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_LENGTH            (6)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_DEFAULT           (16)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_3_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_CONTEXT1, GENC_CONTEXT1_2
+ */
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_MASK              (0x00003F00)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_LSBMASK           (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_SHIFT             (8)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_LENGTH            (6)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_DEFAULT           (16)
+# define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_2_SIGNED_FIELD     (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_CONTEXT1, GENC_CONTEXT1_1
+ */
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_MASK              (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_LSBMASK           (0x0000003F)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_SHIFT             (0)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_LENGTH            (6)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_DEFAULT           (16)
+#define PVDEC_VEC_BE_CR_GENC_CONTEXT1_GENC_CONTEXT1_1_SIGNED_FIELD      (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_ABOVE_PARAM_BASE_ADDRESS_OFFSET         (0x00C0)
+
+/*
+ * PVDEC_VEC_BE, CR_ABOVE_PARAM_BASE_ADDRESS, ABOVE_PARAM_BASE_ADDRESS
+ */
+#define PVDEC_VEC_BE_CR_ABOVE_PARAM_BASE_ADDRESS_ABOVE_PARAM_BASE_ADDRESS_MASK          (0xFFFFFFC0)
+#define PVDEC_VEC_BE_CR_ABOVE_PARAM_BASE_ADDRESS_ABOVE_PARAM_BASE_ADDRESS_LSBMASK \
+	( \
+		0x03FFFFFF)
+#define PVDEC_VEC_BE_CR_ABOVE_PARAM_BASE_ADDRESS_ABOVE_PARAM_BASE_ADDRESS_SHIFT         (6)
+#define PVDEC_VEC_BE_CR_ABOVE_PARAM_BASE_ADDRESS_ABOVE_PARAM_BASE_ADDRESS_LENGTH                (26)
+#define PVDEC_VEC_BE_CR_ABOVE_PARAM_BASE_ADDRESS_ABOVE_PARAM_BASE_ADDRESS_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_ABOVE_PARAM_BASE_ADDRESS_ABOVE_PARAM_BASE_ADDRESS_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_SIGNATURE_OFFSET         (0x0178)
+
+/*
+ * PVDEC_VEC_BE, CR_SLICE_STRUCTURE_OVER1K_SIGNATURE, SLICE_STRUCTURE_OVER1K_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_SIGNATURE_SLICE_STRUCTURE_OVER1K_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_SIGNATURE_SLICE_STRUCTURE_OVER1K_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_SIGNATURE_SLICE_STRUCTURE_OVER1K_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_SIGNATURE_SLICE_STRUCTURE_OVER1K_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_SIGNATURE_SLICE_STRUCTURE_OVER1K_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_SIGNATURE_SLICE_STRUCTURE_OVER1K_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GENC_DEC_SYS_WR_CONTROL_OFFSET          (0x017C)
+
+/*
+ * PVDEC_VEC_BE, CR_GENC_DEC_SYS_WR_CONTROL, GENC_DEC_SYS_WR_DONE
+ */
+#define PVDEC_VEC_BE_CR_GENC_DEC_SYS_WR_CONTROL_GENC_DEC_SYS_WR_DONE_MASK               (0x00000001)
+#define PVDEC_VEC_BE_CR_GENC_DEC_SYS_WR_CONTROL_GENC_DEC_SYS_WR_DONE_LSBMASK            (0x00000001)
+#define PVDEC_VEC_BE_CR_GENC_DEC_SYS_WR_CONTROL_GENC_DEC_SYS_WR_DONE_SHIFT              (0)
+#define PVDEC_VEC_BE_CR_GENC_DEC_SYS_WR_CONTROL_GENC_DEC_SYS_WR_DONE_LENGTH             (1)
+#define PVDEC_VEC_BE_CR_GENC_DEC_SYS_WR_CONTROL_GENC_DEC_SYS_WR_DONE_DEFAULT            (0)
+#define PVDEC_VEC_BE_CR_GENC_DEC_SYS_WR_CONTROL_GENC_DEC_SYS_WR_DONE_SIGNED_FIELD       (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_SIGNATURE_OFFSET          (0x0190)
+
+/*
+ * PVDEC_VEC_BE, CR_GDEC_FRAGMENT_SIGNATURE, GDEC_FRAGMENT_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_SIGNATURE_GDEC_FRAGMENT_SIGNATURE_MASK            (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_SIGNATURE_GDEC_FRAGMENT_SIGNATURE_LSBMASK         (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_SIGNATURE_GDEC_FRAGMENT_SIGNATURE_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_SIGNATURE_GDEC_FRAGMENT_SIGNATURE_LENGTH          (32)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_SIGNATURE_GDEC_FRAGMENT_SIGNATURE_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_SIGNATURE_GDEC_FRAGMENT_SIGNATURE_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_SIGNATURE_OFFSET                (0x0194)
+
+/*
+ * PVDEC_VEC_BE, CR_SLICE_STRUCTURE_SIGNATURE, SLICE_STRUCTURE_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_SIGNATURE_SLICE_STRUCTURE_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_SIGNATURE_SLICE_STRUCTURE_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_SIGNATURE_SLICE_STRUCTURE_SIGNATURE_SHIFT               (0)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_SIGNATURE_SLICE_STRUCTURE_SIGNATURE_LENGTH              (32)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_SIGNATURE_SLICE_STRUCTURE_SIGNATURE_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_SIGNATURE_SLICE_STRUCTURE_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_SIGNATURE_OFFSET          (0x0198)
+
+/*
+ * PVDEC_VEC_BE, CR_MEM_STRUCTURE_SIGNATURE, MEM_STRUCTURE_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_SIGNATURE_MEM_STRUCTURE_SIGNATURE_MASK            (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_SIGNATURE_MEM_STRUCTURE_SIGNATURE_LSBMASK         (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_SIGNATURE_MEM_STRUCTURE_SIGNATURE_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_SIGNATURE_MEM_STRUCTURE_SIGNATURE_LENGTH          (32)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_SIGNATURE_MEM_STRUCTURE_SIGNATURE_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_SIGNATURE_MEM_STRUCTURE_SIGNATURE_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_PRIME_SIGNATURE_OFFSET                (0x01A0)
+
+/*
+ * PVDEC_VEC_BE, CR_DECODE_TO_COMMAND_PRIME_SIGNATURE, DECODE_COMMAND_PRIME_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_PRIME_SIGNATURE_DECODE_COMMAND_PRIME_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_PRIME_SIGNATURE_DECODE_COMMAND_PRIME_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_PRIME_SIGNATURE_DECODE_COMMAND_PRIME_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_PRIME_SIGNATURE_DECODE_COMMAND_PRIME_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_PRIME_SIGNATURE_DECODE_COMMAND_PRIME_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_PRIME_SIGNATURE_DECODE_COMMAND_PRIME_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_SECOND_SIGNATURE_OFFSET               (0x01A4)
+
+/*
+ * PVDEC_VEC_BE, CR_DECODE_TO_COMMAND_SECOND_SIGNATURE, DECODE_COMMAND_SECOND_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_SECOND_SIGNATURE_DECODE_COMMAND_SECOND_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_SECOND_SIGNATURE_DECODE_COMMAND_SECOND_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_SECOND_SIGNATURE_DECODE_COMMAND_SECOND_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_SECOND_SIGNATURE_DECODE_COMMAND_SECOND_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_SECOND_SIGNATURE_DECODE_COMMAND_SECOND_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_CR_DECODE_TO_COMMAND_SECOND_SIGNATURE_DECODE_COMMAND_SECOND_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE_OFFSET               (0x01A8)
+
+/*
+ * PVDEC_VEC_BE, CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE, DECODE_RESIDUAL_PRIME_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE_DECODE_RESIDUAL_PRIME_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE_DECODE_RESIDUAL_PRIME_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE_DECODE_RESIDUAL_PRIME_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE_DECODE_RESIDUAL_PRIME_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE_DECODE_RESIDUAL_PRIME_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_PRIME_SIGNATURE_DECODE_RESIDUAL_PRIME_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE_OFFSET              (0x01AC)
+
+/*
+ * PVDEC_VEC_BE, CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE, DECODE_RESIDUAL_SECOND_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE_DECODE_RESIDUAL_SECOND_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define \
+PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE_DECODE_RESIDUAL_SECOND_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE_DECODE_RESIDUAL_SECOND_SIGNATURE_SHIFT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE_DECODE_RESIDUAL_SECOND_SIGNATURE_LENGTH \
+	( \
+		32)
+#define \
+PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE_DECODE_RESIDUAL_SECOND_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_CR_DECODE_TO_RESIDUAL_SECOND_SIGNATURE_DECODE_RESIDUAL_SECOND_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_READ_SIGNATURE_OFFSET             (0x01B0)
+
+/*
+ * PVDEC_VEC_BE, CR_COMMAND_ABOVE_READ_SIGNATURE, COMMAND_ABOVE_READ_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_READ_SIGNATURE_COMMAND_ABOVE_READ_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_READ_SIGNATURE_COMMAND_ABOVE_READ_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_READ_SIGNATURE_COMMAND_ABOVE_READ_SIGNATURE_SHIFT         (0)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_READ_SIGNATURE_COMMAND_ABOVE_READ_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_READ_SIGNATURE_COMMAND_ABOVE_READ_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_READ_SIGNATURE_COMMAND_ABOVE_READ_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_WRITE_SIGNATURE_OFFSET            (0x01B4)
+
+/*
+ * PVDEC_VEC_BE, CR_COMMAND_ABOVE_WRITE_SIGNATURE, COMMAND_ABOVE_WRITE_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_WRITE_SIGNATURE_COMMAND_ABOVE_WRITE_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_WRITE_SIGNATURE_COMMAND_ABOVE_WRITE_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_WRITE_SIGNATURE_COMMAND_ABOVE_WRITE_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_WRITE_SIGNATURE_COMMAND_ABOVE_WRITE_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_WRITE_SIGNATURE_COMMAND_ABOVE_WRITE_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_COMMAND_ABOVE_WRITE_SIGNATURE_COMMAND_ABOVE_WRITE_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_TEMPORAL_READ_SIGNATURE_OFFSET          (0x01B8)
+
+/*
+ * PVDEC_VEC_BE, CR_TEMPORAL_READ_SIGNATURE, TEMPORAL_READ_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_TEMPORAL_READ_SIGNATURE_TEMPORAL_READ_SIGNATURE_MASK            (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_TEMPORAL_READ_SIGNATURE_TEMPORAL_READ_SIGNATURE_LSBMASK         (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_TEMPORAL_READ_SIGNATURE_TEMPORAL_READ_SIGNATURE_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_TEMPORAL_READ_SIGNATURE_TEMPORAL_READ_SIGNATURE_LENGTH          (32)
+#define PVDEC_VEC_BE_CR_TEMPORAL_READ_SIGNATURE_TEMPORAL_READ_SIGNATURE_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_TEMPORAL_READ_SIGNATURE_TEMPORAL_READ_SIGNATURE_SIGNED_FIELD    (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_TEMPORAL_WRITE_SIGNATURE_OFFSET         (0x01BC)
+
+/*
+ * PVDEC_VEC_BE, CR_TEMPORAL_WRITE_SIGNATURE, TEMPORAL_WRITE_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_TEMPORAL_WRITE_SIGNATURE_TEMPORAL_WRITE_SIGNATURE_MASK          (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_TEMPORAL_WRITE_SIGNATURE_TEMPORAL_WRITE_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_TEMPORAL_WRITE_SIGNATURE_TEMPORAL_WRITE_SIGNATURE_SHIFT         (0)
+#define PVDEC_VEC_BE_CR_TEMPORAL_WRITE_SIGNATURE_TEMPORAL_WRITE_SIGNATURE_LENGTH                (32)
+#define PVDEC_VEC_BE_CR_TEMPORAL_WRITE_SIGNATURE_TEMPORAL_WRITE_SIGNATURE_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_TEMPORAL_WRITE_SIGNATURE_TEMPORAL_WRITE_SIGNATURE_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_COMMAND_OUTPUT_SIGNATURE_OFFSET         (0x01C0)
+
+/*
+ * PVDEC_VEC_BE, CR_COMMAND_OUTPUT_SIGNATURE, COMMAND_OUTPUT_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_COMMAND_OUTPUT_SIGNATURE_COMMAND_OUTPUT_SIGNATURE_MASK          (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_COMMAND_OUTPUT_SIGNATURE_COMMAND_OUTPUT_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_COMMAND_OUTPUT_SIGNATURE_COMMAND_OUTPUT_SIGNATURE_SHIFT         (0)
+#define PVDEC_VEC_BE_CR_COMMAND_OUTPUT_SIGNATURE_COMMAND_OUTPUT_SIGNATURE_LENGTH                (32)
+#define PVDEC_VEC_BE_CR_COMMAND_OUTPUT_SIGNATURE_COMMAND_OUTPUT_SIGNATURE_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_COMMAND_OUTPUT_SIGNATURE_COMMAND_OUTPUT_SIGNATURE_SIGNED_FIELD  (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_RESIDUAL_OUTPUT_SIGNATURE_OFFSET                (0x01C4)
+
+/*
+ * PVDEC_VEC_BE, CR_RESIDUAL_OUTPUT_SIGNATURE, RESIDUAL_OUTPUT_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_RESIDUAL_OUTPUT_SIGNATURE_RESIDUAL_OUTPUT_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_RESIDUAL_OUTPUT_SIGNATURE_RESIDUAL_OUTPUT_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_RESIDUAL_OUTPUT_SIGNATURE_RESIDUAL_OUTPUT_SIGNATURE_SHIFT               (0)
+#define PVDEC_VEC_BE_CR_RESIDUAL_OUTPUT_SIGNATURE_RESIDUAL_OUTPUT_SIGNATURE_LENGTH              (32)
+#define PVDEC_VEC_BE_CR_RESIDUAL_OUTPUT_SIGNATURE_RESIDUAL_OUTPUT_SIGNATURE_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_RESIDUAL_OUTPUT_SIGNATURE_RESIDUAL_OUTPUT_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_REQ_SIGNATURE_OFFSET              (0x01E0)
+
+/*
+ * PVDEC_VEC_BE, CR_GDEC_FRAGMENT_REQ_SIGNATURE, GDEC_FRAGMENT_REQ_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_REQ_SIGNATURE_GDEC_FRAGMENT_REQ_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_REQ_SIGNATURE_GDEC_FRAGMENT_REQ_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_REQ_SIGNATURE_GDEC_FRAGMENT_REQ_SIGNATURE_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_REQ_SIGNATURE_GDEC_FRAGMENT_REQ_SIGNATURE_LENGTH          (32)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_REQ_SIGNATURE_GDEC_FRAGMENT_REQ_SIGNATURE_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_GDEC_FRAGMENT_REQ_SIGNATURE_GDEC_FRAGMENT_REQ_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_REQ_SIGNATURE_OFFSET            (0x01E4)
+
+/*
+ * PVDEC_VEC_BE, CR_SLICE_STRUCTURE_REQ_SIGNATURE, SLICE_STRUCTURE_REQ_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_REQ_SIGNATURE_SLICE_STRUCTURE_REQ_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_REQ_SIGNATURE_SLICE_STRUCTURE_REQ_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_REQ_SIGNATURE_SLICE_STRUCTURE_REQ_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_REQ_SIGNATURE_SLICE_STRUCTURE_REQ_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_REQ_SIGNATURE_SLICE_STRUCTURE_REQ_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_REQ_SIGNATURE_SLICE_STRUCTURE_REQ_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_REQ_SIGNATURE_OFFSET              (0x01E8)
+
+/*
+ * PVDEC_VEC_BE, CR_MEM_STRUCTURE_REQ_SIGNATURE, MEM_STRUCTURE_REQ_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_REQ_SIGNATURE_MEM_STRUCTURE_REQ_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_REQ_SIGNATURE_MEM_STRUCTURE_REQ_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_REQ_SIGNATURE_MEM_STRUCTURE_REQ_SIGNATURE_SHIFT           (0)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_REQ_SIGNATURE_MEM_STRUCTURE_REQ_SIGNATURE_LENGTH          (32)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_REQ_SIGNATURE_MEM_STRUCTURE_REQ_SIGNATURE_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_MEM_STRUCTURE_REQ_SIGNATURE_MEM_STRUCTURE_REQ_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GDEC_SYS_WR_SIGNATURE_OFFSET            (0x01EC)
+
+/*
+ * PVDEC_VEC_BE, CR_GDEC_SYS_WR_SIGNATURE, GDEC_SYS_WR_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_GDEC_SYS_WR_SIGNATURE_GDEC_SYS_WR_SIGNATURE_MASK                (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_SYS_WR_SIGNATURE_GDEC_SYS_WR_SIGNATURE_LSBMASK             (0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_SYS_WR_SIGNATURE_GDEC_SYS_WR_SIGNATURE_SHIFT               (0)
+#define PVDEC_VEC_BE_CR_GDEC_SYS_WR_SIGNATURE_GDEC_SYS_WR_SIGNATURE_LENGTH              (32)
+#define PVDEC_VEC_BE_CR_GDEC_SYS_WR_SIGNATURE_GDEC_SYS_WR_SIGNATURE_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_GDEC_SYS_WR_SIGNATURE_GDEC_SYS_WR_SIGNATURE_SIGNED_FIELD        (IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_GDEC_MEM2REG_SYS_WR_SIGNATURE_OFFSET            (0x01F0)
+
+/*
+ * PVDEC_VEC_BE, CR_GDEC_MEM2REG_SYS_WR_SIGNATURE, GDEC_MEM2REG_SYS_WR_SIGNATURE
+ */
+#define PVDEC_VEC_BE_CR_GDEC_MEM2REG_SYS_WR_SIGNATURE_GDEC_MEM2REG_SYS_WR_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_MEM2REG_SYS_WR_SIGNATURE_GDEC_MEM2REG_SYS_WR_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define PVDEC_VEC_BE_CR_GDEC_MEM2REG_SYS_WR_SIGNATURE_GDEC_MEM2REG_SYS_WR_SIGNATURE_SHIFT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_GDEC_MEM2REG_SYS_WR_SIGNATURE_GDEC_MEM2REG_SYS_WR_SIGNATURE_LENGTH \
+	( \
+		32)
+#define PVDEC_VEC_BE_CR_GDEC_MEM2REG_SYS_WR_SIGNATURE_GDEC_MEM2REG_SYS_WR_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_GDEC_MEM2REG_SYS_WR_SIGNATURE_GDEC_MEM2REG_SYS_WR_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_OFFSET             (0x01F4)
+
+/*
+ * PVDEC_VEC_BE, CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE, SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE
+ */
+#define \
+PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_MASK \
+	( \
+		0xFFFFFFFF)
+#define \
+PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_LSBMASK \
+	( \
+		0xFFFFFFFF)
+#define \
+PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SHIFT \
+	( \
+		0)
+#define \
+PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_LENGTH \
+	( \
+		32)
+#define \
+PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_OFFSET           (0x01FC)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_INIT_MASK \
+	( \
+		0x04000000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_INIT_SHIFT          (26)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_INIT_LENGTH         (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_INIT_DEFAULT \
+	( \
+		0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_REQ_SIGNATURE_INIT_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, GDEC_MEM2REG_SYS_WR_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_MEM2REG_SYS_WR_SIGNATURE_INIT_MASK          (0x02000000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_MEM2REG_SYS_WR_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_MEM2REG_SYS_WR_SIGNATURE_INIT_SHIFT         (25)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_MEM2REG_SYS_WR_SIGNATURE_INIT_LENGTH                (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_MEM2REG_SYS_WR_SIGNATURE_INIT_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_MEM2REG_SYS_WR_SIGNATURE_INIT_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, GDEC_SYS_WR_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_SYS_WR_SIGNATURE_INIT_MASK          (0x01000000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_SYS_WR_SIGNATURE_INIT_LSBMASK               (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_SYS_WR_SIGNATURE_INIT_SHIFT         (24)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_SYS_WR_SIGNATURE_INIT_LENGTH                (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_SYS_WR_SIGNATURE_INIT_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_SYS_WR_SIGNATURE_INIT_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, MEM_STRUCTURE_REQ_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_REQ_SIGNATURE_INIT_MASK            (0x00800000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_REQ_SIGNATURE_INIT_LSBMASK         (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_REQ_SIGNATURE_INIT_SHIFT           (23)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_REQ_SIGNATURE_INIT_LENGTH          (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_REQ_SIGNATURE_INIT_DEFAULT         (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_REQ_SIGNATURE_INIT_SIGNED_FIELD    (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, SLICE_STRUCTURE_REQ_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_REQ_SIGNATURE_INIT_MASK          (0x00400000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_REQ_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_REQ_SIGNATURE_INIT_SHIFT         (22)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_REQ_SIGNATURE_INIT_LENGTH                (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_REQ_SIGNATURE_INIT_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_REQ_SIGNATURE_INIT_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, GDEC_DATA_REQ_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_DATA_REQ_SIGNATURE_INIT_MASK                (0x003C0000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_DATA_REQ_SIGNATURE_INIT_LSBMASK             (0x0000000F)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_DATA_REQ_SIGNATURE_INIT_SHIFT               (18)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_DATA_REQ_SIGNATURE_INIT_LENGTH              (4)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_DATA_REQ_SIGNATURE_INIT_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_DATA_REQ_SIGNATURE_INIT_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, RESIDUAL_OUTPUT_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_RESIDUAL_OUTPUT_SIGNATURE_INIT_MASK              (0x00020000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_RESIDUAL_OUTPUT_SIGNATURE_INIT_LSBMASK           (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_RESIDUAL_OUTPUT_SIGNATURE_INIT_SHIFT             (17)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_RESIDUAL_OUTPUT_SIGNATURE_INIT_LENGTH            (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_RESIDUAL_OUTPUT_SIGNATURE_INIT_DEFAULT           (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_RESIDUAL_OUTPUT_SIGNATURE_INIT_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, COMMAND_OUTPUT_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_OUTPUT_SIGNATURE_INIT_MASK               (0x00010000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_OUTPUT_SIGNATURE_INIT_LSBMASK            (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_OUTPUT_SIGNATURE_INIT_SHIFT              (16)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_OUTPUT_SIGNATURE_INIT_LENGTH             (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_OUTPUT_SIGNATURE_INIT_DEFAULT            (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_OUTPUT_SIGNATURE_INIT_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, TEMPORAL_WRITE_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_WRITE_SIGNATURE_INIT_MASK               (0x00008000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_WRITE_SIGNATURE_INIT_LSBMASK            (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_WRITE_SIGNATURE_INIT_SHIFT              (15)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_WRITE_SIGNATURE_INIT_LENGTH             (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_WRITE_SIGNATURE_INIT_DEFAULT            (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_WRITE_SIGNATURE_INIT_SIGNED_FIELD       (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, TEMPORAL_READ_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_READ_SIGNATURE_INIT_MASK                (0x00004000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_READ_SIGNATURE_INIT_LSBMASK             (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_READ_SIGNATURE_INIT_SHIFT               (14)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_READ_SIGNATURE_INIT_LENGTH              (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_READ_SIGNATURE_INIT_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_TEMPORAL_READ_SIGNATURE_INIT_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, COMMAND_ABOVE_WRITE_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_WRITE_SIGNATURE_INIT_MASK          (0x00002000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_WRITE_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_WRITE_SIGNATURE_INIT_SHIFT         (13)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_WRITE_SIGNATURE_INIT_LENGTH                (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_WRITE_SIGNATURE_INIT_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_WRITE_SIGNATURE_INIT_SIGNED_FIELD  (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, COMMAND_ABOVE_READ_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_READ_SIGNATURE_INIT_MASK           (0x00001000)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_READ_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_READ_SIGNATURE_INIT_SHIFT          (12)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_READ_SIGNATURE_INIT_LENGTH         (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_READ_SIGNATURE_INIT_DEFAULT                (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_COMMAND_ABOVE_READ_SIGNATURE_INIT_SIGNED_FIELD   (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, DECODE_RESIDUAL_SECOND_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_SECOND_SIGNATURE_INIT_MASK \
+	( \
+		0x00000800)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_SECOND_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_SECOND_SIGNATURE_INIT_SHIFT              (11)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_SECOND_SIGNATURE_INIT_LENGTH             (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_SECOND_SIGNATURE_INIT_DEFAULT            (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_SECOND_SIGNATURE_INIT_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, DECODE_RESIDUAL_PRIME_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_PRIME_SIGNATURE_INIT_MASK \
+	( \
+		0x00000400)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_PRIME_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_PRIME_SIGNATURE_INIT_SHIFT               (10)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_PRIME_SIGNATURE_INIT_LENGTH              (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_PRIME_SIGNATURE_INIT_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_RESIDUAL_PRIME_SIGNATURE_INIT_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, DECODE_COMMAND_SECOND_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_SECOND_SIGNATURE_INIT_MASK \
+	( \
+		0x00000200)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_SECOND_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_SECOND_SIGNATURE_INIT_SHIFT               (9)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_SECOND_SIGNATURE_INIT_LENGTH              (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_SECOND_SIGNATURE_INIT_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_SECOND_SIGNATURE_INIT_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, DECODE_COMMAND_PRIME_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_PRIME_SIGNATURE_INIT_MASK         (0x00000100)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_PRIME_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_PRIME_SIGNATURE_INIT_SHIFT                (8)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_PRIME_SIGNATURE_INIT_LENGTH               (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_PRIME_SIGNATURE_INIT_DEFAULT              (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_DECODE_COMMAND_PRIME_SIGNATURE_INIT_SIGNED_FIELD (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, SLICE_STRUCTURE_OVER1K_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_SIGNATURE_INIT_MASK \
+	( \
+		0x00000080)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_SIGNATURE_INIT_LSBMASK \
+	( \
+		0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_SIGNATURE_INIT_SHIFT              (7)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_SIGNATURE_INIT_LENGTH             (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_SIGNATURE_INIT_DEFAULT            (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_OVER1K_SIGNATURE_INIT_SIGNED_FIELD \
+	( \
+		IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, MEM_STRUCTURE_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_SIGNATURE_INIT_MASK                (0x00000040)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_SIGNATURE_INIT_LSBMASK             (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_SIGNATURE_INIT_SHIFT               (6)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_SIGNATURE_INIT_LENGTH              (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_SIGNATURE_INIT_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_MEM_STRUCTURE_SIGNATURE_INIT_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, SLICE_STRUCTURE_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_SIGNATURE_INIT_MASK              (0x00000020)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_SIGNATURE_INIT_LSBMASK           (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_SIGNATURE_INIT_SHIFT             (5)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_SIGNATURE_INIT_LENGTH            (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_SIGNATURE_INIT_DEFAULT           (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_SLICE_STRUCTURE_SIGNATURE_INIT_SIGNED_FIELD      (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, GDEC_FRAGMENT_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_FRAGMENT_SIGNATURE_INIT_MASK                (0x00000010)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_FRAGMENT_SIGNATURE_INIT_LSBMASK             (0x00000001)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_FRAGMENT_SIGNATURE_INIT_SHIFT               (4)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_FRAGMENT_SIGNATURE_INIT_LENGTH              (1)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_FRAGMENT_SIGNATURE_INIT_DEFAULT             (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_FRAGMENT_SIGNATURE_INIT_SIGNED_FIELD        (IMG_FALSE)
+
+/*
+ * PVDEC_VEC_BE, CR_SIGNATURE_INIT, GDEC_BUFFER_SIGNATURE_INIT
+ */
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_BUFFER_SIGNATURE_INIT_MASK          (0x0000000F)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_BUFFER_SIGNATURE_INIT_LSBMASK               (0x0000000F)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_BUFFER_SIGNATURE_INIT_SHIFT         (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_BUFFER_SIGNATURE_INIT_LENGTH                (4)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_BUFFER_SIGNATURE_INIT_DEFAULT               (0)
+#define PVDEC_VEC_BE_CR_SIGNATURE_INIT_GDEC_BUFFER_SIGNATURE_INIT_SIGNED_FIELD  (IMG_FALSE)
+
+#endif
diff --git a/drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c b/drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c
new file mode 100644
index 000000000000..afaeb0291c66
--- /dev/null
+++ b/drivers/media/platform/vxe-vxd/decoder/vxd_v4l2.c
@@ -0,0 +1,2125 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * IMG DEC V4L2 Interface function implementations
+ *
+ * Copyright (c) Imagination Technologies Ltd.
+ * Copyright (c) 2021 Texas Instruments Incorporated - http://www.ti.com/
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_irq.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/pm_runtime.h>
+#include <linux/videodev2.h>
+#include <linux/idr.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <linux/printk.h>
+#include <linux/mutex.h>
+
+#ifdef ERROR_RECOVERY_SIMULATION
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
+#include <linux/types.h>
+#endif
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-ctrls.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-event.h>
+#include <media/v4l2-ioctl.h>
+#include <media/v4l2-mem2mem.h>
+#include <media/videobuf2-core.h>
+#include <media/videobuf2-dma-sg.h>
+#ifdef CAPTURE_CONTIG_ALLOC
+#include <media/videobuf2-dma-contig.h>
+#endif
+
+#include "core.h"
+#include "h264fw_data.h"
+#include "hevcfw_data.h"
+#include "img_dec_common.h"
+#include "vxd_pvdec_priv.h"
+#include "vxd_dec.h"
+
+#define VXD_DEC_SPIN_LOCK_NAME  "vxd-dec"
+#define IMG_VXD_DEC_MODULE_NAME "vxd-dec"
+
+#ifdef ERROR_RECOVERY_SIMULATION
+/* This code should be execute only in debug flag */
+/*
+ * vxd decoder kernel object to create sysfs to debug error recovery and firmware
+ * watchdog timer. This kernel object will create a directory under /sys/kernel,
+ * containing two files fw_error_value and disable_fw_irq.
+ */
+struct kobject *vxd_dec_kobject;
+
+/* fw_error_value is the variable used to handle fw_error_attr */
+int fw_error_value = VDEC_ERROR_MAX;
+
+/* irq for the module, stored globally so can be accessed from sysfs */
+int g_module_irq;
+
+/*
+ * fw_error_attr. Application can set the value of this attribute, based on the
+ * firmware error that needs to be reproduced.
+ */
+struct kobj_attribute fw_error_attr =
+	__ATTR(fw_error_value, 0660, vxd_sysfs_show, vxd_sysfs_store);
+
+/* disable_fw_irq_value is variable to handle disable_fw_irq_attr */
+int disable_fw_irq_value;
+
+/*
+ * disable_fw_irq_attr. Application can set the value of this attribute. 1 to
+ * disable irq. 0 to enable irq.
+ */
+struct kobj_attribute disable_fw_irq_attr =
+	__ATTR(disable_fw_irq_value, 0660, vxd_sysfs_show, vxd_sysfs_store);
+
+/*
+ * Group attribute so that we can create and destroy all of them at once.
+ */
+struct attribute *attrs[] = {
+	&fw_error_attr.attr,
+	&disable_fw_irq_attr.attr,
+	NULL,         /* Terminate list of attributes with NULL */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory.  If we specify a name, a sub directory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group
+ */
+struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+#endif
+
+static struct heap_config vxd_dec_heap_configs[] = {
+	{
+		.type = MEM_HEAP_TYPE_UNIFIED,
+		.options.unified = {
+			.gfp_type = __GFP_DMA32 | __GFP_ZERO,
+		},
+		.to_dev_addr = NULL,
+	},
+};
+
+static struct vxd_dec_fmt vxd_dec_formats[] = {
+	{
+		.fourcc = V4L2_PIX_FMT_NV12,
+		.num_planes = 1,
+		.type = IMG_DEC_FMT_TYPE_CAPTURE,
+		.std = VDEC_STD_UNDEFINED,
+		.pixfmt = IMG_PIXFMT_420PL12YUV8,
+		.interleave = PIXEL_UV_ORDER,
+		.idc = PIXEL_FORMAT_420,
+		.size_num = 3,
+		.size_den = 2,
+		.bytes_pp = 1,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_NV16,
+		.num_planes = 1,
+		.type = IMG_DEC_FMT_TYPE_CAPTURE,
+		.std = VDEC_STD_UNDEFINED,
+		.pixfmt = IMG_PIXFMT_422PL12YUV8,
+		.interleave = PIXEL_UV_ORDER,
+		.idc = PIXEL_FORMAT_422,
+		.size_num = 2,
+		.size_den = 1,
+		.bytes_pp = 1,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_TI1210,
+		.num_planes = 1,
+		.type = IMG_DEC_FMT_TYPE_CAPTURE,
+		.std = VDEC_STD_UNDEFINED,
+		.pixfmt = IMG_PIXFMT_420PL12YUV10_MSB,
+		.interleave = PIXEL_UV_ORDER,
+		.idc = PIXEL_FORMAT_420,
+		.size_num = 3,
+		.size_den = 2,
+		.bytes_pp = 2,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_TI1610,
+		.num_planes = 1,
+		.type = IMG_DEC_FMT_TYPE_CAPTURE,
+		.std = VDEC_STD_UNDEFINED,
+		.pixfmt = IMG_PIXFMT_422PL12YUV10_MSB,
+		.interleave = PIXEL_UV_ORDER,
+		.idc = PIXEL_FORMAT_422,
+		.size_num = 2,
+		.size_den = 1,
+		.bytes_pp = 2,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_H264,
+		.num_planes = 1,
+		.type = IMG_DEC_FMT_TYPE_OUTPUT,
+		.std = VDEC_STD_H264,
+		.pixfmt = IMG_PIXFMT_UNDEFINED,
+		.interleave = PIXEL_INVALID_CI,
+		.idc = PIXEL_FORMAT_INVALID,
+		.size_num = 1,
+		.size_den = 1,
+		.bytes_pp = 1,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_HEVC,
+		.num_planes = 1,
+		.type = IMG_DEC_FMT_TYPE_OUTPUT,
+		.std = VDEC_STD_HEVC,
+		.pixfmt = IMG_PIXFMT_UNDEFINED,
+		.interleave = PIXEL_INVALID_CI,
+		.idc = PIXEL_FORMAT_INVALID,
+		.size_num = 1,
+		.size_den = 1,
+		.bytes_pp = 1,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_MJPEG,
+		.num_planes = 1,
+		.type = IMG_DEC_FMT_TYPE_OUTPUT,
+		.std = VDEC_STD_JPEG,
+		.pixfmt = IMG_PIXFMT_UNDEFINED,
+		.interleave = PIXEL_INVALID_CI,
+		.idc = PIXEL_FORMAT_INVALID,
+		.size_num = 1,
+		.size_den = 1,
+		.bytes_pp = 1,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUV420M,
+		.num_planes = 3,
+		.type = IMG_DEC_FMT_TYPE_CAPTURE,
+		.std = VDEC_STD_UNDEFINED,
+		.pixfmt = 86031,
+		.interleave = PIXEL_UV_ORDER,
+		.idc = PIXEL_FORMAT_420,
+		.size_num = 2,
+		.size_den = 1,
+		.bytes_pp = 1,
+	},
+	{
+		.fourcc = V4L2_PIX_FMT_YUV422M,
+		.num_planes = 3,
+		.type = IMG_DEC_FMT_TYPE_CAPTURE,
+		.std = VDEC_STD_UNDEFINED,
+		.pixfmt = 81935,
+		.interleave = PIXEL_UV_ORDER,
+		.idc = PIXEL_FORMAT_422,
+		.size_num = 3,
+		.size_den = 1,
+		.bytes_pp = 1,
+	},
+};
+
+#ifdef ERROR_RECOVERY_SIMULATION
+ssize_t vxd_sysfs_show(struct kobject *vxd_dec_kobject,
+		       struct kobj_attribute *attr, char *buf)
+
+{
+	int var = 0;
+
+	if (strcmp(attr->attr.name, "fw_error_value") == 0)
+		var = fw_error_value;
+
+	else
+		var = disable_fw_irq_value;
+
+	return sprintf(buf, "%d\n", var);
+}
+
+ssize_t vxd_sysfs_store(struct kobject *vxd_dec_kobject,
+			struct kobj_attribute *attr,
+			const char *buf, unsigned long count)
+{
+	int var = 0, rv = 0;
+
+	rv = sscanf(buf, "%du", &var);
+
+	if (strcmp(attr->attr.name, "fw_error_value") == 0) {
+		fw_error_value = var;
+	} else {
+		disable_fw_irq_value = var;
+		/*
+		 * if disable_fw_irq_value is not zero, disable the irq to reproduce
+		 * firmware non responsiveness in vxd_worker.
+		 */
+		if (disable_fw_irq_value != 0) {
+			/* just ignore the irq */
+			disable_irq(g_module_irq);
+		}
+	}
+	return sprintf((char *)buf, "%d\n", var);
+}
+#endif
+
+static struct vxd_dec_ctx *file2ctx(struct file *file)
+{
+	return container_of(file->private_data, struct vxd_dec_ctx, fh);
+}
+
+static irqreturn_t soft_thread_irq(int irq, void *dev_id)
+{
+	struct platform_device *pdev = (struct platform_device *)dev_id;
+
+	if (!pdev)
+		return IRQ_NONE;
+
+	return vxd_handle_thread_irq(&pdev->dev);
+}
+
+static irqreturn_t hard_isrcb(int irq, void *dev_id)
+{
+	struct platform_device *pdev = (struct platform_device *)dev_id;
+
+	if (!pdev)
+		return IRQ_NONE;
+
+	return vxd_handle_irq(&pdev->dev);
+}
+
+static struct vxd_buffer *find_buffer(unsigned int buf_map_id, struct list_head *head)
+{
+	struct list_head *list;
+	struct vxd_buffer *buf = NULL;
+
+	list_for_each(list, head) {
+		buf = list_entry(list, struct vxd_buffer, list);
+		if (buf->buf_map_id == buf_map_id)
+			break;
+		buf = NULL;
+	}
+	return buf;
+}
+
+static void return_worker(void *work)
+{
+	struct vxd_dec_ctx *ctx;
+	struct vxd_return *res;
+	struct device *dev;
+	struct timespec64 time;
+	int loop;
+
+	work = get_work_buff(work, TRUE);
+
+	res = container_of(work, struct vxd_return, work);
+	ctx = res->ctx;
+	dev = ctx->dev->dev;
+	switch (res->type) {
+	case VXD_CB_PICT_DECODED:
+		v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
+		ktime_get_real_ts64(&time);
+		for (loop = 0; loop < ARRAY_SIZE(ctx->dev->time_drv); loop++) {
+			if (ctx->dev->time_drv[loop].id == res->buf_map_id) {
+				ctx->dev->time_drv[loop].end_time =
+				timespec64_to_ns(&time);
+#ifdef DEBUG_DECODER_DRIVER
+				dev_info(dev, "picture buf decode time is %llu us for buf_map_id 0x%x\n",
+					 div_s64(ctx->dev->time_drv[loop].end_time -
+						 ctx->dev->time_drv[loop].start_time, 1000),
+					 res->buf_map_id);
+#endif
+				break;
+				}
+			}
+
+		if (loop == ARRAY_SIZE(ctx->dev->time_drv))
+			dev_err(dev, "picture buf decode for buf_map_id x%0x is not measured\n",
+				res->buf_map_id);
+		break;
+
+	default:
+		break;
+	}
+	kfree(res->work);
+	kfree(res);
+}
+
+static void vxd_error_recovery(struct vxd_dec_ctx *ctx)
+{
+	int ret = -1;
+
+	/*
+	 * In the previous frame decoding fatal error has been detected
+	 * so we need to reload the firmware to make it alive.
+	 */
+	pr_debug("Reloading the firmware because of previous error\n");
+	vxd_clean_fw_resources(ctx->dev);
+	ret = vxd_prepare_fw(ctx->dev);
+	if (ret)
+		pr_err("Reloading the firmware failed!!");
+}
+
+static struct vxd_dec_q_data *get_q_data(struct vxd_dec_ctx *ctx,
+					 enum v4l2_buf_type type)
+{
+	switch (type) {
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
+		return &ctx->q_data[Q_DATA_SRC];
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
+		return &ctx->q_data[Q_DATA_DST];
+	default:
+		return NULL;
+	}
+	return NULL;
+}
+
+static void vxd_return_resource(void *ctx_handle, enum vxd_cb_type type,
+				unsigned int buf_map_id)
+{
+	struct vxd_return *res;
+	struct vxd_buffer *buf = NULL;
+	struct vb2_v4l2_buffer *vb;
+	struct vxd_dec_ctx *ctx = (struct vxd_dec_ctx *)ctx_handle;
+	struct v4l2_event event = {};
+	struct device *dev = ctx->dev->dev;
+	int i;
+	struct vxd_dec_q_data *q_data;
+
+	if (ctx->aborting) {
+		v4l2_m2m_job_finish(ctx->dev->m2m_dev, ctx->fh.m2m_ctx);
+		ctx->aborting = 0;
+		return;
+	}
+
+	switch (type) {
+	case VXD_CB_STRUNIT_PROCESSED:
+
+		buf = find_buffer(buf_map_id, &ctx->out_buffers);
+		if (!buf) {
+			dev_err(dev, "Could not locate buf_map_id=0x%x in OUTPUT buffers list\n",
+				buf_map_id);
+			break;
+		}
+		buf->buffer.vb.field = V4L2_FIELD_NONE;
+		q_data = get_q_data(ctx, buf->buffer.vb.vb2_buf.vb2_queue->type);
+		if (!q_data)
+			return;
+
+		for (i = 0; i < q_data->fmt->num_planes; i++)
+			vb2_set_plane_payload(&buf->buffer.vb.vb2_buf, i,
+					      ctx->pict_bufcfg.plane_size[i]);
+
+		v4l2_m2m_buf_done(&buf->buffer.vb, VB2_BUF_STATE_DONE);
+		break;
+	case VXD_CB_SPS_RELEASE:
+		break;
+	case VXD_CB_PPS_RELEASE:
+		break;
+	case VXD_CB_PICT_DECODED:
+		res = kzalloc(sizeof(*res), GFP_KERNEL);
+		if (!res)
+			return;
+		res->ctx = ctx;
+		res->type = type;
+		res->buf_map_id = buf_map_id;
+
+		init_work(&res->work, return_worker, HWA_DECODER);
+		if (!res->work)
+			return;
+
+		schedule_work(res->work);
+
+		break;
+	case VXD_CB_PICT_DISPLAY:
+		buf = find_buffer(buf_map_id, &ctx->cap_buffers);
+		if (!buf) {
+			dev_err(dev, "Could not locate buf_map_id=0x%x in CAPTURE buffers list\n",
+				buf_map_id);
+			break;
+		}
+		buf->reuse = FALSE;
+		buf->buffer.vb.field = V4L2_FIELD_NONE;
+		q_data = get_q_data(ctx, buf->buffer.vb.vb2_buf.vb2_queue->type);
+		if (!q_data)
+			return;
+
+		for (i = 0; i < q_data->fmt->num_planes; i++)
+			vb2_set_plane_payload(&buf->buffer.vb.vb2_buf, i,
+					      ctx->pict_bufcfg.plane_size[i]);
+
+		v4l2_m2m_buf_done(&buf->buffer.vb, VB2_BUF_STATE_DONE);
+		break;
+	case VXD_CB_PICT_RELEASE:
+		buf = find_buffer(buf_map_id, &ctx->reuse_queue);
+		if (buf) {
+			buf->reuse = TRUE;
+			list_move_tail(&buf->list, &ctx->cap_buffers);
+
+			v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, &buf->buffer.vb);
+			break;
+		}
+		buf = find_buffer(buf_map_id, &ctx->cap_buffers);
+		if (!buf) {
+			dev_err(dev, "Could not locate buf_map_id=0x%x in CAPTURE buffers list\n",
+				buf_map_id);
+
+			break;
+		}
+		buf->reuse = TRUE;
+
+		break;
+	case VXD_CB_PICT_END:
+		break;
+	case VXD_CB_STR_END:
+		event.type = V4L2_EVENT_EOS;
+		v4l2_event_queue_fh(&ctx->fh, &event);
+		if (v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) > 0) {
+			vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+			vb->flags |= V4L2_BUF_FLAG_LAST;
+
+			q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+			if (!q_data)
+				break;
+
+			for (i = 0; i < q_data->fmt->num_planes; i++)
+				vb2_set_plane_payload(&vb->vb2_buf, i, 0);
+
+			v4l2_m2m_buf_done(vb, VB2_BUF_STATE_DONE);
+		} else {
+			ctx->flag_last = TRUE;
+		}
+		break;
+	case VXD_CB_ERROR_FATAL:
+		/*
+		 * There has been FW error, so we need to reload the firmware.
+		 */
+		vxd_error_recovery(ctx);
+
+		/*
+		 * Just send zero size buffer to v4l2 application,
+		 * informing the error condition.
+		 */
+		if (v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) > 0) {
+			vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+
+			q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+			if (!q_data)
+				break;
+
+			for (i = 0; i < q_data->fmt->num_planes; i++)
+				vb2_set_plane_payload(&vb->vb2_buf, i, 0);
+
+			v4l2_m2m_buf_done(vb, VB2_BUF_STATE_DONE);
+		} else {
+			ctx->flag_last = TRUE;
+		}
+		break;
+	default:
+		break;
+	}
+}
+
+static int vxd_dec_submit_opconfig(struct vxd_dec_ctx *ctx)
+{
+	int ret = 0;
+
+	if (ctx->stream_created) {
+		ret = core_stream_set_output_config(ctx->res_str_id,
+						    &ctx->str_opcfg,
+						    &ctx->pict_bufcfg);
+		if (ret) {
+			dev_err(ctx->dev->dev, "core_stream_set_output_config failed\n");
+			ctx->opconfig_pending = TRUE;
+			return ret;
+		}
+		ctx->opconfig_pending = FALSE;
+		ctx->stream_configured = TRUE;
+	} else {
+		ctx->opconfig_pending = TRUE;
+	}
+	return ret;
+}
+
+static int vxd_dec_queue_setup(struct vb2_queue *vq,
+			       unsigned int *nbuffers,
+			       unsigned int *nplanes,
+			       unsigned int sizes[],
+			       struct device *alloc_devs[])
+{
+	struct vxd_dec_ctx *ctx = vb2_get_drv_priv(vq);
+	struct vxd_dec_q_data *q_data;
+	struct vxd_dec_q_data *src_q_data;
+	int i;
+	unsigned int hw_nbuffers = 0;
+
+	q_data = get_q_data(ctx, vq->type);
+	if (!q_data)
+		return -EINVAL;
+
+	if (*nplanes) {
+		/* This is being called from CREATEBUFS, perform validation */
+		if (*nplanes != q_data->fmt->num_planes)
+			return -EINVAL;
+
+		for (i = 0; i < *nplanes; i++) {
+			if (sizes[i] != q_data->size_image[i])
+				return -EINVAL;
+		}
+
+		return 0;
+	}
+
+	*nplanes = q_data->fmt->num_planes;
+
+	if (!V4L2_TYPE_IS_OUTPUT(vq->type)) {
+		src_q_data = &ctx->q_data[Q_DATA_SRC];
+		if (src_q_data)
+			hw_nbuffers = get_nbuffers(src_q_data->fmt->std,
+						   q_data->width,
+						   q_data->height,
+						   ctx->max_num_ref_frames);
+	}
+
+	*nbuffers = max(*nbuffers, hw_nbuffers);
+
+	for (i = 0; i < *nplanes; i++)
+		sizes[i] = q_data->size_image[i];
+
+	return 0;
+}
+
+static int vxd_dec_buf_prepare(struct vb2_buffer *vb)
+{
+	struct vxd_dec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct device *dev = ctx->dev->dev;
+	struct vxd_dec_q_data *q_data;
+	void *sgt;
+#ifdef CAPTURE_CONTIG_ALLOC
+	struct page *new_page;
+#else
+	void *sgl;
+#endif
+	struct sg_table *sgt_new;
+	void *sgl_new;
+	int pages;
+	int nents = 0;
+	int size = 0;
+	int plane, num_planes, ret = 0;
+	struct vxd_buffer *buf =
+		container_of(vb, struct vxd_buffer, buffer.vb.vb2_buf);
+
+	q_data = get_q_data(ctx, vb->vb2_queue->type);
+	if (!q_data)
+		return -EINVAL;
+
+	num_planes = q_data->fmt->num_planes;
+
+	for (plane = 0; plane < num_planes; plane++) {
+		if (vb2_plane_size(vb, plane) < q_data->size_image[plane]) {
+			dev_err(dev, "data will not fit into plane (%lu < %lu)\n",
+				vb2_plane_size(vb, plane),
+				(long)q_data->size_image[plane]);
+			return -EINVAL;
+		}
+	}
+
+	if (buf->mapped)
+		return 0;
+
+	buf->buf_info.cpu_linear_addr = vb2_plane_vaddr(vb, 0);
+	buf->buf_info.buf_size = vb2_plane_size(vb, 0);
+	buf->buf_info.fd = -1;
+	sgt = vb2_dma_sg_plane_desc(vb, 0);
+	if (!sgt) {
+		dev_err(dev, "Could not get sg_table from plane 0\n");
+		return -EINVAL;
+	}
+
+	if (V4L2_TYPE_IS_OUTPUT(vb->type)) {
+		ret = core_stream_map_buf_sg(ctx->res_str_id,
+					     VDEC_BUFTYPE_BITSTREAM,
+					     &buf->buf_info, sgt,
+					     &buf->buf_map_id);
+		if (ret) {
+			dev_err(dev, "OUTPUT core_stream_map_buf_sg failed\n");
+			return ret;
+		}
+
+		buf->bstr_info.buf_size = q_data->size_image[0];
+		buf->bstr_info.cpu_virt_addr = buf->buf_info.cpu_linear_addr;
+		buf->bstr_info.mem_attrib =
+			SYS_MEMATTRIB_UNCACHED | SYS_MEMATTRIB_WRITECOMBINE |
+			SYS_MEMATTRIB_INPUT | SYS_MEMATTRIB_CPU_WRITE;
+		buf->bstr_info.bufmap_id = buf->buf_map_id;
+		lst_init(&buf->seq_unit.bstr_seg_list);
+		lst_init(&buf->pic_unit.bstr_seg_list);
+		lst_init(&buf->end_unit.bstr_seg_list);
+
+		list_add_tail(&buf->list, &ctx->out_buffers);
+	} else {
+		/* Create a single sgt from the plane(s) */
+		sgt_new = kmalloc(sizeof(*sgt_new), GFP_KERNEL);
+		if (!sgt_new)
+			return -EINVAL;
+
+		for (plane = 0; plane < num_planes; plane++) {
+			size += ALIGN(vb2_plane_size(vb, plane), PAGE_SIZE);
+			sgt = vb2_dma_sg_plane_desc(vb, plane);
+			if (!sgt) {
+				dev_err(dev, "Could not get sg_table from plane %d\n", plane);
+				kfree(sgt_new);
+				return -EINVAL;
+			}
+#ifdef CAPTURE_CONTIG_ALLOC
+			nents += 1;
+#else
+			nents += sg_nents(img_mmu_get_sgl(sgt));
+#endif
+		}
+		buf->buf_info.buf_size = size;
+
+		pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
+		ret = sg_alloc_table(sgt_new, nents, GFP_KERNEL);
+		if (ret) {
+			kfree(sgt_new);
+			return -EINVAL;
+		}
+		sgl_new = img_mmu_get_sgl(sgt_new);
+
+		for (plane = 0; plane < num_planes; plane++) {
+			sgt = vb2_dma_sg_plane_desc(vb, plane);
+			if (!sgt) {
+				dev_err(dev, "Could not get sg_table from plane %d\n", plane);
+				sg_free_table(sgt_new);
+				kfree(sgt_new);
+				return -EINVAL;
+			}
+#ifdef CAPTURE_CONTIG_ALLOC
+			new_page = phys_to_page(vb2_dma_contig_plane_dma_addr(vb, plane));
+			sg_set_page(sgl_new, new_page, ALIGN(vb2_plane_size(vb, plane),
+							     PAGE_SIZE), 0);
+			sgl_new = sg_next(sgl_new);
+#else
+			sgl = img_mmu_get_sgl(sgt);
+
+			while (sgl) {
+				sg_set_page(sgl_new, sg_page(sgl), img_mmu_get_sgl_length(sgl), 0);
+				sgl = sg_next(sgl);
+				sgl_new = sg_next(sgl_new);
+			}
+#endif
+		}
+
+		buf->buf_info.pictbuf_cfg = ctx->pict_bufcfg;
+		ret = core_stream_map_buf_sg(ctx->res_str_id,
+					     VDEC_BUFTYPE_PICTURE,
+					     &buf->buf_info, sgt_new,
+					     &buf->buf_map_id);
+		sg_free_table(sgt_new);
+		kfree(sgt_new);
+		if (ret) {
+			dev_err(dev, "CAPTURE core_stream_map_buf_sg failed\n");
+			return ret;
+		}
+		list_add_tail(&buf->list, &ctx->cap_buffers);
+	}
+	buf->mapped = TRUE;
+	buf->reuse = TRUE;
+
+	return 0;
+}
+
+static void vxd_dec_buf_queue(struct vb2_buffer *vb)
+{
+	struct vb2_v4l2_buffer *vbuf = to_vb2_v4l2_buffer(vb);
+	struct vxd_dec_ctx *ctx = vb2_get_drv_priv(vb->vb2_queue);
+	struct vxd_buffer *buf =
+		container_of(vb, struct vxd_buffer, buffer.vb.vb2_buf);
+	struct vxd_dec_q_data *q_data;
+	int i;
+
+	if (V4L2_TYPE_IS_OUTPUT(vb->type)) {
+		v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);
+	} else {
+		mutex_lock_nested(ctx->mutex, SUBCLASS_VXD_V4L2);
+		if (buf->reuse) {
+			mutex_unlock(ctx->mutex);
+			if (ctx->flag_last) {
+				q_data = get_q_data(ctx, V4L2_BUF_TYPE_VIDEO_CAPTURE);
+				vbuf->flags |= V4L2_BUF_FLAG_LAST;
+
+				for (i = 0; i < q_data->fmt->num_planes; i++)
+					vb2_set_plane_payload(&vbuf->vb2_buf, i, 0);
+
+				v4l2_m2m_buf_done(vbuf, VB2_BUF_STATE_DONE);
+			} else {
+				v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, vbuf);
+			}
+		} else {
+			list_move_tail(&buf->list, &ctx->reuse_queue);
+			mutex_unlock(ctx->mutex);
+		}
+	}
+}
+
+static void vxd_dec_return_all_buffers(struct vxd_dec_ctx *ctx,
+				       struct vb2_queue *q,
+				       enum vb2_buffer_state state)
+{
+	struct vb2_v4l2_buffer *vb;
+	unsigned long flags;
+
+	for (;;) {
+		if (V4L2_TYPE_IS_OUTPUT(q->type))
+			vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+		else
+			vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+
+		if (!vb)
+			break;
+
+		spin_lock_irqsave(ctx->dev->lock, flags);
+		v4l2_m2m_buf_done(vb, state);
+		spin_unlock_irqrestore(ctx->dev->lock, (unsigned long)flags);
+	}
+}
+
+static int vxd_dec_start_streaming(struct vb2_queue *vq, unsigned int count)
+{
+	int ret = 0;
+	struct vxd_dec_ctx *ctx = vb2_get_drv_priv(vq);
+
+	if (V4L2_TYPE_IS_OUTPUT(vq->type))
+		ctx->dst_streaming = TRUE;
+	else
+		ctx->src_streaming = TRUE;
+
+	if (ctx->dst_streaming && ctx->src_streaming && !ctx->core_streaming) {
+		if (!ctx->stream_configured) {
+			vxd_dec_return_all_buffers(ctx, vq, VB2_BUF_STATE_ERROR);
+			return -EINVAL;
+		}
+		ctx->eos = FALSE;
+		ctx->stop_initiated = FALSE;
+		ctx->flag_last = FALSE;
+		ret = core_stream_play(ctx->res_str_id);
+		if (ret) {
+			vxd_dec_return_all_buffers(ctx, vq, VB2_BUF_STATE_ERROR);
+			return ret;
+		}
+		ctx->core_streaming = TRUE;
+	}
+
+	return 0;
+}
+
+static void vxd_dec_stop_streaming(struct vb2_queue *vq)
+{
+	struct vxd_dec_ctx *ctx = vb2_get_drv_priv(vq);
+	struct list_head *list;
+	struct list_head *temp;
+	struct vxd_buffer *buf = NULL;
+
+	if (V4L2_TYPE_IS_OUTPUT(vq->type))
+		ctx->dst_streaming = FALSE;
+	else
+		ctx->src_streaming = FALSE;
+
+	if (ctx->core_streaming) {
+		core_stream_stop(ctx->res_str_id);
+		ctx->core_streaming = FALSE;
+
+		core_stream_flush(ctx->res_str_id, TRUE);
+	}
+
+	/* unmap all the output and capture plane buffers */
+	if (V4L2_TYPE_IS_OUTPUT(vq->type)) {
+		list_for_each(list, &ctx->out_buffers) {
+			buf = list_entry(list, struct vxd_buffer, list);
+			core_stream_unmap_buf_sg(buf->buf_map_id);
+			buf->mapped = FALSE;
+			__list_del_entry(&buf->list);
+		}
+	} else {
+		list_for_each_safe(list, temp, &ctx->reuse_queue) {
+			buf = list_entry(list, struct vxd_buffer, list);
+			list_move_tail(&buf->list, &ctx->cap_buffers);
+			v4l2_m2m_buf_queue(ctx->fh.m2m_ctx, &buf->buffer.vb);
+		}
+
+		list_for_each(list, &ctx->cap_buffers) {
+			buf = list_entry(list, struct vxd_buffer, list);
+			core_stream_unmap_buf_sg(buf->buf_map_id);
+			buf->mapped = FALSE;
+			__list_del_entry(&buf->list);
+		}
+	}
+
+	vxd_dec_return_all_buffers(ctx, vq, VB2_BUF_STATE_ERROR);
+}
+
+static struct vb2_ops vxd_dec_video_ops = {
+	.queue_setup = vxd_dec_queue_setup,
+	.buf_prepare = vxd_dec_buf_prepare,
+	.buf_queue = vxd_dec_buf_queue,
+	.wait_prepare = vb2_ops_wait_prepare,
+	.wait_finish = vb2_ops_wait_finish,
+	.start_streaming = vxd_dec_start_streaming,
+	.stop_streaming = vxd_dec_stop_streaming,
+};
+
+static int queue_init(void *priv, struct vb2_queue *src_vq, struct vb2_queue *dst_vq)
+{
+	struct vxd_dec_ctx *ctx = priv;
+	struct vxd_dev *vxd = ctx->dev;
+	int ret = 0;
+
+	/* src_vq */
+	memset(src_vq, 0, sizeof(*src_vq));
+	src_vq->type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
+	src_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	src_vq->drv_priv = ctx;
+	src_vq->buf_struct_size = sizeof(struct vxd_buffer);
+	src_vq->ops = &vxd_dec_video_ops;
+	src_vq->mem_ops = &vb2_dma_sg_memops;
+	src_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	src_vq->lock = vxd->mutex;
+	src_vq->dev = vxd->v4l2_dev.dev;
+	ret = vb2_queue_init(src_vq);
+	if (ret)
+		return ret;
+
+	/* dst_vq */
+	memset(dst_vq, 0, sizeof(*dst_vq));
+	dst_vq->type = V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE;
+	dst_vq->io_modes = VB2_MMAP | VB2_DMABUF;
+	dst_vq->drv_priv = ctx;
+	dst_vq->buf_struct_size = sizeof(struct vxd_buffer);
+	dst_vq->ops = &vxd_dec_video_ops;
+#ifdef CAPTURE_CONTIG_ALLOC
+	dst_vq->mem_ops = &vb2_dma_contig_memops;
+#else
+	dst_vq->mem_ops = &vb2_dma_sg_memops;
+#endif
+	dst_vq->timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_COPY;
+	dst_vq->lock = vxd->mutex;
+	dst_vq->dev = vxd->v4l2_dev.dev;
+	ret = vb2_queue_init(dst_vq);
+	if (ret) {
+		vb2_queue_release(src_vq);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int vxd_dec_open(struct file *file)
+{
+	struct vxd_dev *vxd = video_drvdata(file);
+	struct vxd_dec_ctx *ctx;
+	struct vxd_dec_q_data *s_q_data;
+	int i, ret = 0;
+
+	dev_dbg(vxd->dev, "%s:%d vxd %p\n", __func__, __LINE__, vxd);
+
+	if (vxd->no_fw) {
+		dev_err(vxd->dev, "Error!! fw binary is not present");
+		return -1;
+	}
+
+	mutex_lock_nested(vxd->mutex, SUBCLASS_BASE);
+
+	ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	if (!ctx) {
+		mutex_unlock(vxd->mutex);
+		return -ENOMEM;
+	}
+	ctx->dev = vxd;
+
+	v4l2_fh_init(&ctx->fh, video_devdata(file));
+	file->private_data = &ctx->fh;
+
+	s_q_data = &ctx->q_data[Q_DATA_SRC];
+	s_q_data->fmt = &vxd_dec_formats[0];
+	s_q_data->width = 1920;
+	s_q_data->height = 1080;
+	for (i = 0; i < s_q_data->fmt->num_planes; i++) {
+		s_q_data->bytesperline[i] = s_q_data->width;
+		s_q_data->size_image[i] = s_q_data->bytesperline[i] * s_q_data->height;
+	}
+
+	ctx->q_data[Q_DATA_DST] = *s_q_data;
+
+	ctx->fh.m2m_ctx = v4l2_m2m_ctx_init(vxd->m2m_dev, ctx, &queue_init);
+	if (IS_ERR_VALUE((unsigned long)ctx->fh.m2m_ctx)) {
+		ret = (long)(ctx->fh.m2m_ctx);
+		goto exit;
+	}
+
+	v4l2_fh_add(&ctx->fh);
+
+	ret = idr_alloc_cyclic(vxd->streams, &ctx->stream, VXD_MIN_STREAM_ID, VXD_MAX_STREAM_ID,
+			       GFP_KERNEL);
+	if (ret < VXD_MIN_STREAM_ID || ret > VXD_MAX_STREAM_ID) {
+		dev_err(vxd->dev, "%s: stream id creation failed!\n",
+			__func__);
+		ret = -EFAULT;
+		goto exit;
+	}
+
+	ctx->stream.id = ret;
+	ctx->stream.ctx = ctx;
+
+	ctx->stream_created = FALSE;
+	ctx->stream_configured = FALSE;
+	ctx->src_streaming = FALSE;
+	ctx->dst_streaming = FALSE;
+	ctx->core_streaming = FALSE;
+	ctx->eos = FALSE;
+	ctx->stop_initiated = FALSE;
+	ctx->flag_last = FALSE;
+
+	lst_init(&ctx->seg_list);
+	for (i = 0; i < MAX_SEGMENTS; i++)
+		lst_add(&ctx->seg_list, &ctx->bstr_segments[i]);
+
+	if (vxd_create_ctx(vxd, ctx))
+		goto out_idr_remove;
+
+	ctx->stream.mmu_ctx = ctx->mmu_ctx;
+	ctx->stream.ptd = ctx->ptd;
+
+	ctx->mutex = kzalloc(sizeof(*ctx->mutex), GFP_KERNEL);
+	if (!ctx->mutex) {
+		ret = -ENOMEM;
+		goto out_idr_remove;
+	}
+	mutex_init(ctx->mutex);
+
+	INIT_LIST_HEAD(&ctx->items_done);
+	INIT_LIST_HEAD(&ctx->reuse_queue);
+	INIT_LIST_HEAD(&ctx->return_queue);
+	INIT_LIST_HEAD(&ctx->out_buffers);
+	INIT_LIST_HEAD(&ctx->cap_buffers);
+
+	mutex_unlock(vxd->mutex);
+
+	return 0;
+
+out_idr_remove:
+	idr_remove(vxd->streams, ctx->stream.id);
+
+exit:
+	v4l2_fh_exit(&ctx->fh);
+	get_work_buff(ctx->work, TRUE);
+	kfree(ctx->work);
+	kfree(ctx);
+	mutex_unlock(vxd->mutex);
+	return ret;
+}
+
+static int vxd_dec_release(struct file *file)
+{
+	struct vxd_dev *vxd = video_drvdata(file);
+	struct vxd_dec_ctx *ctx = file2ctx(file);
+	struct bspp_ddbuf_array_info *fw_sequ = ctx->fw_sequ;
+	struct bspp_ddbuf_array_info *fw_pps = ctx->fw_pps;
+	int i, ret = 0;
+	struct vxd_dec_q_data *s_q_data;
+
+	s_q_data = &ctx->q_data[Q_DATA_SRC];
+
+	if (ctx->stream_created) {
+		bspp_stream_destroy(ctx->bspp_context);
+
+		for (i = 0; i < MAX_SEQUENCES; i++) {
+			core_stream_unmap_buf(fw_sequ[i].ddbuf_info.bufmap_id);
+			img_mem_free(ctx->mem_ctx, fw_sequ[i].ddbuf_info.buf_id);
+		}
+
+		if (s_q_data->fmt->std != VDEC_STD_JPEG) {
+			for (i = 0; i < MAX_PPSS; i++) {
+				core_stream_unmap_buf(fw_pps[i].ddbuf_info.bufmap_id);
+				img_mem_free(ctx->mem_ctx, fw_pps[i].ddbuf_info.buf_id);
+			}
+		}
+		core_stream_destroy(ctx->res_str_id);
+		ctx->stream_created = FALSE;
+	}
+
+	mutex_lock_nested(vxd->mutex, SUBCLASS_BASE);
+
+	vxd_destroy_ctx(vxd, ctx);
+
+	idr_remove(vxd->streams, ctx->stream.id);
+
+	v4l2_fh_del(&ctx->fh);
+
+	v4l2_fh_exit(&ctx->fh);
+
+	v4l2_m2m_ctx_release(ctx->fh.m2m_ctx);
+
+	mutex_destroy(ctx->mutex);
+	kfree(ctx->mutex);
+	ctx->mutex = NULL;
+
+	get_work_buff(ctx->work, TRUE);
+	kfree(ctx->work);
+	kfree(ctx);
+
+	mutex_unlock(vxd->mutex);
+
+	return ret;
+}
+
+static int vxd_dec_querycap(struct file *file, void *priv, struct v4l2_capability *cap)
+{
+	strncpy(cap->driver, IMG_VXD_DEC_MODULE_NAME, sizeof(cap->driver) - 1);
+	strncpy(cap->card, IMG_VXD_DEC_MODULE_NAME, sizeof(cap->card) - 1);
+	snprintf(cap->bus_info, sizeof(cap->bus_info), "platform:%s", IMG_VXD_DEC_MODULE_NAME);
+	cap->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	cap->capabilities = cap->device_caps | V4L2_CAP_DEVICE_CAPS;
+	return 0;
+}
+
+static int __enum_fmt(struct v4l2_fmtdesc *f, unsigned int type)
+{
+	int i, index;
+	struct vxd_dec_fmt *fmt = NULL;
+
+	index = 0;
+	for (i = 0; i < ARRAY_SIZE(vxd_dec_formats); ++i) {
+		if (vxd_dec_formats[i].type & type) {
+			if (index == f->index) {
+				fmt = &vxd_dec_formats[i];
+				break;
+			}
+			index++;
+		}
+	}
+
+	if (!fmt)
+		return -EINVAL;
+
+	f->pixelformat = fmt->fourcc;
+	return 0;
+}
+
+static int vxd_dec_enum_fmt(struct file *file, void *priv, struct v4l2_fmtdesc *f)
+{
+	if (V4L2_TYPE_IS_OUTPUT(f->type))
+		return __enum_fmt(f, IMG_DEC_FMT_TYPE_OUTPUT);
+
+	return __enum_fmt(f, IMG_DEC_FMT_TYPE_CAPTURE);
+}
+
+static struct vxd_dec_fmt *find_format(struct v4l2_format *f, unsigned int type)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vxd_dec_formats); ++i) {
+		if (vxd_dec_formats[i].fourcc == f->fmt.pix_mp.pixelformat &&
+		    vxd_dec_formats[i].type == type)
+			return &vxd_dec_formats[i];
+	}
+	return NULL;
+}
+
+static unsigned int get_sizeimage(int w, int h, struct vxd_dec_fmt *fmt, int plane)
+{
+	switch (fmt->fourcc) {
+	case V4L2_PIX_FMT_YUV420M:
+		return ((plane == 0) ? (w * h) : (w * h / 2));
+	case V4L2_PIX_FMT_YUV422M:
+		return (w * h);
+	default:
+		return (w * h * fmt->size_num / fmt->size_den);
+	}
+
+	return 0;
+}
+
+static unsigned int get_stride(int w, struct vxd_dec_fmt *fmt)
+{
+	return (ALIGN(w, HW_ALIGN) * fmt->bytes_pp);
+}
+
+/*
+ * @ Function vxd_get_header_info
+ * Run bspp stream submit and preparse once before device_run
+ * To retrieve header information
+ */
+static int vxd_get_header_info(void *priv)
+{
+	struct vxd_dec_ctx *ctx = priv;
+	struct vxd_dev *vxd_dev = ctx->dev;
+	struct device *dev = vxd_dev->v4l2_dev.dev;
+	struct vb2_v4l2_buffer  *src_vb;
+	struct vxd_buffer *src_vxdb;
+	struct vxd_buffer *dst_vxdb;
+	struct bspp_preparsed_data *preparsed_data;
+	unsigned int data_size;
+	int ret;
+
+	/*
+	 * Checking for queued buffer.
+	 * If no next buffer present, do not get information from header.
+	 * Else, get header information and store for later use.
+	 */
+	src_vb =  v4l2_m2m_next_src_buf(ctx->fh.m2m_ctx);
+	if (!src_vb) {
+		dev_warn(dev, "get_header_info Next src buffer is null\n");
+		return IMG_ERROR_INVALID_PARAMETERS;
+	}
+	mutex_lock_nested(ctx->mutex, SUBCLASS_VXD_V4L2);
+
+	src_vxdb = container_of(src_vb, struct vxd_buffer, buffer.vb);
+	/* Setting dst_vxdb to arbitrary value (using src_vb) for now */
+	dst_vxdb = container_of(src_vb, struct vxd_buffer, buffer.vb);
+
+	preparsed_data = &dst_vxdb->preparsed_data;
+
+	data_size = vb2_get_plane_payload(&src_vxdb->buffer.vb.vb2_buf, 0);
+
+	ret = bspp_stream_submit_buffer(ctx->bspp_context,
+					&src_vxdb->bstr_info,
+					src_vxdb->buf_map_id,
+					data_size, NULL,
+					VDEC_BSTRELEMENT_UNSPECIFIED);
+	if (ret) {
+		dev_err(dev, "get_header_info bspp_stream_submit_buffer failed %d\n", ret);
+		return ret;
+	}
+	mutex_unlock(ctx->mutex);
+
+	ret = bspp_stream_preparse_buffers(ctx->bspp_context, NULL, 0,
+					   &ctx->seg_list,
+					   preparsed_data, ctx->eos);
+	if (ret) {
+		dev_err(dev, "get_header_info bspp_stream_preparse_buffers failed %d\n", ret);
+		return ret;
+	}
+
+	if (preparsed_data->sequ_hdr_info.com_sequ_hdr_info.max_frame_size.height &&
+	    preparsed_data->sequ_hdr_info.com_sequ_hdr_info.max_ref_frame_num) {
+		ctx->height = preparsed_data->sequ_hdr_info.com_sequ_hdr_info.max_frame_size.height;
+		ctx->max_num_ref_frames =
+			preparsed_data->sequ_hdr_info.com_sequ_hdr_info.max_ref_frame_num;
+	} else {
+		dev_err(dev, "get_header_info preparsed data is null %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int vxd_dec_g_fmt(struct file *file, void *priv, struct v4l2_format *f)
+{
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	struct vxd_dec_ctx *ctx = file2ctx(file);
+	struct vxd_dec_q_data *q_data;
+	struct vxd_dev *vxd_dev = ctx->dev;
+	unsigned int i = 0;
+	int ret = 0;
+
+	q_data = get_q_data(ctx, f->type);
+	if (!q_data)
+		return -EINVAL;
+
+	pix_mp->field = V4L2_FIELD_NONE;
+	pix_mp->pixelformat = q_data->fmt->fourcc;
+	pix_mp->num_planes = q_data->fmt->num_planes;
+
+	if (f->type == V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE) {
+		/* The buffer contains compressed image. */
+		pix_mp->width = ctx->width;
+		pix_mp->height = ctx->height;
+		pix_mp->plane_fmt[0].bytesperline = 0;
+		pix_mp->plane_fmt[0].sizeimage = q_data->size_image[0];
+	} else if (f->type == V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE) {
+		/* The buffer contains decoded YUV image. */
+		pix_mp->width = ctx->width;
+		pix_mp->height = ctx->height;
+		for (i = 0; i < q_data->fmt->num_planes; i++) {
+			pix_mp->plane_fmt[i].bytesperline = get_stride(pix_mp->width, q_data->fmt);
+			pix_mp->plane_fmt[i].sizeimage = get_sizeimage
+							(pix_mp->plane_fmt[i].bytesperline,
+							 ctx->height, q_data->fmt, i);
+		}
+	} else {
+		dev_err(vxd_dev->v4l2_dev.dev, "Wrong V4L2_format type\n");
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+static int vxd_dec_try_fmt(struct file *file, void *priv, struct v4l2_format *f)
+{
+	struct vxd_dec_ctx *ctx = file2ctx(file);
+	struct vxd_dev *vxd_dev = ctx->dev;
+	struct vxd_dec_fmt *fmt;
+	struct v4l2_pix_format_mplane *pix_mp = &f->fmt.pix_mp;
+	struct v4l2_plane_pix_format *plane_fmt = pix_mp->plane_fmt;
+	unsigned int i = 0;
+	int ret = 0;
+
+	if (V4L2_TYPE_IS_OUTPUT(f->type)) {
+		fmt = find_format(f, IMG_DEC_FMT_TYPE_OUTPUT);
+		if (!fmt) {
+			dev_err(vxd_dev->v4l2_dev.dev, "Unsupported format for source.\n");
+			return -EINVAL;
+		}
+		/*
+		 * Allocation for worst case input frame size:
+		 * I frame with full YUV size (YUV422)
+		 */
+		plane_fmt[0].sizeimage = ALIGN(pix_mp->width, HW_ALIGN) *
+			ALIGN(pix_mp->height, HW_ALIGN) * 2;
+	} else {
+		fmt = find_format(f, IMG_DEC_FMT_TYPE_CAPTURE);
+		if (!fmt) {
+			dev_err(vxd_dev->v4l2_dev.dev, "Unsupported format for dest.\n");
+			return -EINVAL;
+		}
+		for (i = 0; i < fmt->num_planes; i++) {
+			plane_fmt[i].bytesperline = get_stride(pix_mp->width, fmt);
+			plane_fmt[i].sizeimage = get_sizeimage(plane_fmt[i].bytesperline,
+							       pix_mp->height, fmt, i);
+		}
+		pix_mp->num_planes = fmt->num_planes;
+		pix_mp->flags = 0;
+	}
+
+	if (pix_mp->field == V4L2_FIELD_ANY)
+		pix_mp->field = V4L2_FIELD_NONE;
+
+	return ret;
+}
+
+static int vxd_dec_s_fmt(struct file *file, void *priv, struct v4l2_format *f)
+{
+	struct v4l2_pix_format_mplane *pix_mp;
+	struct vxd_dec_ctx *ctx = file2ctx(file);
+	struct vxd_dev *vxd_dev = ctx->dev;
+	struct device *dev = vxd_dev->v4l2_dev.dev;
+	struct vxd_dec_q_data *q_data;
+	struct vb2_queue *vq;
+	struct vdec_str_configdata strcfgdata;
+	int ret = 0;
+	unsigned char i = 0, j = 0;
+
+	pix_mp = &f->fmt.pix_mp;
+
+	if (!V4L2_TYPE_IS_OUTPUT(f->type)) {
+		int res = vxd_get_header_info(ctx);
+
+		if (res == 0)
+			pix_mp->height = ctx->height;
+	}
+
+	ret = vxd_dec_try_fmt(file, priv, f);
+	if (ret)
+		return ret;
+
+	vq = v4l2_m2m_get_vq(ctx->fh.m2m_ctx, f->type);
+	if (!vq)
+		return -EINVAL;
+
+	if (vb2_is_busy(vq)) {
+		dev_err(dev, "Queue is busy\n");
+		return -EBUSY;
+	}
+
+	q_data = get_q_data(ctx, f->type);
+
+	if (!q_data)
+		return -EINVAL;
+
+	/*
+	 * saving the original dimensions to pass to gstreamer (to remove the green
+	 * padding on kmsink)
+	 */
+	ctx->width_orig = pix_mp->width;
+	ctx->height_orig = pix_mp->height;
+
+	ctx->width = pix_mp->width;
+	ctx->height = pix_mp->height;
+
+	q_data->width = pix_mp->width;
+	q_data->height = pix_mp->height;
+
+	if (V4L2_TYPE_IS_OUTPUT(f->type)) {
+		q_data->fmt = find_format(f, IMG_DEC_FMT_TYPE_OUTPUT);
+		q_data->size_image[0] = pix_mp->plane_fmt[0].sizeimage;
+
+		if (!ctx->stream_created) {
+			strcfgdata.vid_std = q_data->fmt->std;
+
+			if (strcfgdata.vid_std == VDEC_STD_UNDEFINED) {
+				dev_err(dev, "Invalid input format\n");
+				return -EINVAL;
+			}
+			strcfgdata.bstr_format = VDEC_BSTRFORMAT_ELEMENTARY;
+			strcfgdata.user_str_id = ctx->stream.id;
+			strcfgdata.update_yuv = FALSE;
+			strcfgdata.bandwidth_efficient = FALSE;
+			strcfgdata.disable_mvc = FALSE;
+			strcfgdata.full_scan = FALSE;
+			strcfgdata.immediate_decode = TRUE;
+			strcfgdata.intra_frame_closed_gop = TRUE;
+
+			ret = core_stream_create(ctx, &strcfgdata, &ctx->res_str_id);
+			if (ret) {
+				dev_err(dev, "Core stream create failed\n");
+				return -EINVAL;
+			}
+			ctx->stream_created = TRUE;
+			if (ctx->opconfig_pending) {
+				ret = vxd_dec_submit_opconfig(ctx);
+				if (ret) {
+					dev_err(dev, "Output config failed\n");
+					return -EINVAL;
+				}
+			}
+
+			vxd_dec_alloc_bspp_resource(ctx, strcfgdata.vid_std);
+			ret = bspp_stream_create(&strcfgdata,
+						 &ctx->bspp_context,
+						 ctx->fw_sequ,
+						 ctx->fw_pps);
+			if (ret) {
+				dev_err(dev, "BSPP stream create failed %d\n", ret);
+				return ret;
+			}
+		} else if (q_data->fmt !=
+			find_format(f, IMG_DEC_FMT_TYPE_OUTPUT)) {
+			dev_err(dev, "Input format already set\n");
+			return -EBUSY;
+		}
+	} else {
+		q_data->fmt = find_format(f, IMG_DEC_FMT_TYPE_CAPTURE);
+		for (i = 0; i < q_data->fmt->num_planes; i++) {
+			q_data->size_image[i] =
+				get_sizeimage(get_stride(pix_mp->width, q_data->fmt),
+					      ctx->height, q_data->fmt, i);
+		}
+
+		ctx->str_opcfg.pixel_info.pixfmt = q_data->fmt->pixfmt;
+		ctx->str_opcfg.pixel_info.chroma_interleave = q_data->fmt->interleave;
+		ctx->str_opcfg.pixel_info.chroma_fmt = TRUE;
+		ctx->str_opcfg.pixel_info.chroma_fmt_idc = q_data->fmt->idc;
+
+		if (q_data->fmt->pixfmt == IMG_PIXFMT_420PL12YUV10_MSB ||
+		    q_data->fmt->pixfmt == IMG_PIXFMT_422PL12YUV10_MSB) {
+			ctx->str_opcfg.pixel_info.mem_pkg = PIXEL_BIT10_MSB_MP;
+			ctx->str_opcfg.pixel_info.bitdepth_y = 10;
+			ctx->str_opcfg.pixel_info.bitdepth_c = 10;
+		} else {
+			ctx->str_opcfg.pixel_info.mem_pkg = PIXEL_BIT8_MP;
+			ctx->str_opcfg.pixel_info.bitdepth_y = 8;
+			ctx->str_opcfg.pixel_info.bitdepth_c = 8;
+		}
+
+		ctx->str_opcfg.force_oold = FALSE;
+
+		ctx->pict_bufcfg.coded_width = pix_mp->width;
+		ctx->pict_bufcfg.coded_height = pix_mp->height;
+		ctx->pict_bufcfg.pixel_fmt = q_data->fmt->pixfmt;
+		for (i = 0; i < pix_mp->num_planes; i++) {
+			q_data->bytesperline[i] = get_stride(q_data->width, q_data->fmt);
+			if (q_data->bytesperline[i] <
+				pix_mp->plane_fmt[0].bytesperline)
+				q_data->bytesperline[i] =
+					ALIGN(pix_mp->plane_fmt[0].bytesperline, HW_ALIGN);
+			pix_mp->plane_fmt[0].bytesperline =
+				q_data->bytesperline[i];
+			ctx->pict_bufcfg.stride[i] = q_data->bytesperline[i];
+		}
+		for (j = i; j < IMG_MAX_NUM_PLANES; j++) {
+			if ((i - 1) < 0)
+				i++;
+			ctx->pict_bufcfg.stride[j] =
+				q_data->bytesperline[i - 1];
+		}
+		ctx->pict_bufcfg.stride_alignment = HW_ALIGN;
+		ctx->pict_bufcfg.byte_interleave = FALSE;
+		for (i = 0; i < pix_mp->num_planes; i++) {
+			unsigned int plane_size =
+				get_sizeimage(ctx->pict_bufcfg.stride[i],
+					      ctx->pict_bufcfg.coded_height,
+					      q_data->fmt, i);
+			ctx->pict_bufcfg.buf_size += ALIGN(plane_size, PAGE_SIZE);
+			ctx->pict_bufcfg.plane_size[i] = plane_size;
+			pix_mp->plane_fmt[i].sizeimage = plane_size;
+		}
+		if (q_data->fmt->pixfmt == 86031 ||
+		    q_data->fmt->pixfmt == 81935) {
+			/* Handle the v4l2 multi-planar formats */
+			ctx->str_opcfg.pixel_info.num_planes = 3;
+			ctx->pict_bufcfg.packed = FALSE;
+			for (i = 0; i < pix_mp->num_planes; i++) {
+				ctx->pict_bufcfg.chroma_offset[i] =
+					ALIGN(pix_mp->plane_fmt[i].sizeimage, PAGE_SIZE);
+				ctx->pict_bufcfg.chroma_offset[i] +=
+					(i ? ctx->pict_bufcfg.chroma_offset[i - 1] : 0);
+			}
+		} else {
+			/* IMG Decoders support only multi-planar formats */
+			ctx->str_opcfg.pixel_info.num_planes = 2;
+			ctx->pict_bufcfg.packed = TRUE;
+			ctx->pict_bufcfg.chroma_offset[0] = 0;
+			ctx->pict_bufcfg.chroma_offset[1] = 0;
+		}
+
+		vxd_dec_submit_opconfig(ctx);
+	}
+
+	return ret;
+}
+
+static int vxd_dec_subscribe_event(struct v4l2_fh *fh, const struct v4l2_event_subscription *sub)
+{
+	if (sub->type != V4L2_EVENT_EOS)
+		return -EINVAL;
+
+	v4l2_event_subscribe(fh, sub, 0, NULL);
+	return 0;
+}
+
+static int vxd_dec_try_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)
+{
+	if (cmd->cmd != V4L2_DEC_CMD_STOP)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int vxd_dec_cmd(struct file *file, void *fh, struct v4l2_decoder_cmd *cmd)
+{
+	struct vxd_dec_ctx *ctx = file2ctx(file);
+
+	if (cmd->cmd != V4L2_DEC_CMD_STOP)
+		return -EINVAL;
+
+#ifdef DEBUG_DECODER_DRIVER
+	pr_info("%s CMD_STOP\n", __func__);
+#endif
+	/*
+	 * When stop command is received, notify device_run if it is
+	 * scheduled to run, or tell the decoder that eos has
+	 * happened.
+	 */
+	mutex_lock_nested(ctx->mutex, SUBCLASS_VXD_V4L2);
+	if (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) > 0) {
+#ifdef DEBUG_DECODER_DRIVER
+		pr_info("V4L2 src bufs not empty, set a flag to notify device_run\n");
+#endif
+		ctx->stop_initiated = TRUE;
+		mutex_unlock(ctx->mutex);
+	} else {
+		if (ctx->num_decoding) {
+#ifdef DEBUG_DECODER_DRIVER
+			pr_info("buffers are still being decoded, so just set eos flag\n");
+#endif
+			ctx->eos = TRUE;
+			mutex_unlock(ctx->mutex);
+		} else {
+			mutex_unlock(ctx->mutex);
+#ifdef DEBUG_DECODER_DRIVER
+			pr_info("All buffers are decoded, so issue dummy stream end\n");
+#endif
+			vxd_return_resource((void *)ctx, VXD_CB_STR_END, 0);
+		}
+	}
+
+	return 0;
+}
+
+static int vxd_g_selection(struct file *file, void *fh, struct v4l2_selection *s)
+{
+	struct vxd_dec_ctx *ctx = file2ctx(file);
+	bool def_bounds = true;
+
+	if (s->type != V4L2_BUF_TYPE_VIDEO_CAPTURE &&
+	    s->type != V4L2_BUF_TYPE_VIDEO_OUTPUT)
+		return -EINVAL;
+
+	switch (s->target) {
+	case V4L2_SEL_TGT_COMPOSE_DEFAULT:
+	case V4L2_SEL_TGT_COMPOSE_BOUNDS:
+		if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			return -EINVAL;
+		break;
+	case V4L2_SEL_TGT_CROP_BOUNDS:
+	case V4L2_SEL_TGT_CROP_DEFAULT:
+		if (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			return -EINVAL;
+		break;
+	case V4L2_SEL_TGT_COMPOSE:
+		if (s->type == V4L2_BUF_TYPE_VIDEO_OUTPUT)
+			return -EINVAL;
+		def_bounds = false;
+		break;
+	case V4L2_SEL_TGT_CROP:
+		if (s->type == V4L2_BUF_TYPE_VIDEO_CAPTURE)
+			return -EINVAL;
+		def_bounds = false;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	if (def_bounds) {
+		s->r.left = 0;
+		s->r.top = 0;
+		s->r.width = ctx->width_orig;
+		s->r.height = ctx->height_orig;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ioctl_ops vxd_dec_ioctl_ops = {
+	.vidioc_querycap = vxd_dec_querycap,
+
+	.vidioc_enum_fmt_vid_cap = vxd_dec_enum_fmt,
+	.vidioc_g_fmt_vid_cap_mplane = vxd_dec_g_fmt,
+	.vidioc_try_fmt_vid_cap_mplane = vxd_dec_try_fmt,
+	.vidioc_s_fmt_vid_cap_mplane = vxd_dec_s_fmt,
+
+	.vidioc_enum_fmt_vid_out = vxd_dec_enum_fmt,
+	.vidioc_g_fmt_vid_out_mplane = vxd_dec_g_fmt,
+	.vidioc_try_fmt_vid_out_mplane = vxd_dec_try_fmt,
+	.vidioc_s_fmt_vid_out_mplane = vxd_dec_s_fmt,
+
+	.vidioc_reqbufs = v4l2_m2m_ioctl_reqbufs,
+	.vidioc_querybuf = v4l2_m2m_ioctl_querybuf,
+	.vidioc_qbuf = v4l2_m2m_ioctl_qbuf,
+	.vidioc_dqbuf = v4l2_m2m_ioctl_dqbuf,
+	.vidioc_expbuf = v4l2_m2m_ioctl_expbuf,
+
+	.vidioc_streamon = v4l2_m2m_ioctl_streamon,
+	.vidioc_streamoff = v4l2_m2m_ioctl_streamoff,
+	.vidioc_log_status = v4l2_ctrl_log_status,
+	.vidioc_subscribe_event = vxd_dec_subscribe_event,
+	.vidioc_unsubscribe_event = v4l2_event_unsubscribe,
+	.vidioc_try_decoder_cmd = vxd_dec_try_cmd,
+	.vidioc_decoder_cmd = vxd_dec_cmd,
+
+	.vidioc_g_selection = vxd_g_selection,
+};
+
+static const struct v4l2_file_operations vxd_dec_fops = {
+	.owner = THIS_MODULE,
+	.open = vxd_dec_open,
+	.release = vxd_dec_release,
+	.poll = v4l2_m2m_fop_poll,
+	.unlocked_ioctl = video_ioctl2,
+	.mmap = v4l2_m2m_fop_mmap,
+};
+
+static struct video_device vxd_dec_videodev = {
+	.name = IMG_VXD_DEC_MODULE_NAME,
+	.fops = &vxd_dec_fops,
+	.ioctl_ops = &vxd_dec_ioctl_ops,
+	.minor = -1,
+	.release = video_device_release,
+	.vfl_dir = VFL_DIR_M2M,
+};
+
+static void device_run(void *priv)
+{
+	struct vxd_dec_ctx *ctx = priv;
+	struct vxd_dev *vxd_dev = ctx->dev;
+	struct device *dev = vxd_dev->v4l2_dev.dev;
+	struct vb2_v4l2_buffer  *src_vb;
+	struct vb2_v4l2_buffer  *dst_vb;
+	struct vxd_buffer *src_vxdb;
+	struct vxd_buffer *dst_vxdb;
+	struct bspp_bitstr_seg *item = NULL, *next = NULL;
+	struct bspp_preparsed_data *preparsed_data;
+	unsigned int data_size;
+	int ret;
+	struct timespec64 time;
+	static int cnt;
+	int i;
+
+	mutex_lock_nested(ctx->mutex, SUBCLASS_VXD_V4L2);
+	ctx->num_decoding++;
+
+	src_vb = v4l2_m2m_src_buf_remove(ctx->fh.m2m_ctx);
+	if (!src_vb)
+		dev_err(dev, "Next src buffer is null\n");
+
+	dst_vb = v4l2_m2m_dst_buf_remove(ctx->fh.m2m_ctx);
+	if (!dst_vb)
+		dev_err(dev, "Next dst buffer is null\n");
+
+	src_vxdb = container_of(src_vb, struct vxd_buffer, buffer.vb);
+	dst_vxdb = container_of(dst_vb, struct vxd_buffer, buffer.vb);
+
+	preparsed_data = &dst_vxdb->preparsed_data;
+
+	data_size = vb2_get_plane_payload(&src_vxdb->buffer.vb.vb2_buf, 0);
+
+	ret = bspp_stream_submit_buffer(ctx->bspp_context,
+					&src_vxdb->bstr_info,
+					src_vxdb->buf_map_id,
+					data_size, NULL,
+					VDEC_BSTRELEMENT_UNSPECIFIED);
+	if (ret)
+		dev_err(dev, "bspp_stream_submit_buffer failed %d\n", ret);
+
+	if (ctx->stop_initiated &&
+	    (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) == 0))
+		ctx->eos = TRUE;
+
+	mutex_unlock(ctx->mutex);
+
+	ret = bspp_stream_preparse_buffers(ctx->bspp_context, NULL, 0, &ctx->seg_list,
+					   preparsed_data, ctx->eos);
+	if (ret)
+		dev_err(dev, "bspp_stream_preparse_buffers failed %d\n", ret);
+
+	ktime_get_real_ts64(&time);
+	vxd_dev->time_drv[cnt].start_time = timespec64_to_ns(&time);
+	vxd_dev->time_drv[cnt].id = dst_vxdb->buf_map_id;
+	cnt++;
+
+	if (cnt >= ARRAY_SIZE(vxd_dev->time_drv))
+		cnt = 0;
+
+	core_stream_fill_pictbuf(dst_vxdb->buf_map_id);
+
+	if (preparsed_data->new_sequence) {
+		src_vxdb->seq_unit.str_unit_type =
+			VDECDD_STRUNIT_SEQUENCE_START;
+		src_vxdb->seq_unit.str_unit_handle = ctx;
+		src_vxdb->seq_unit.err_flags = 0;
+		src_vxdb->seq_unit.dd_data = NULL;
+		src_vxdb->seq_unit.seq_hdr_info =
+			&preparsed_data->sequ_hdr_info;
+		src_vxdb->seq_unit.seq_hdr_id = 0;
+		src_vxdb->seq_unit.closed_gop = TRUE;
+		src_vxdb->seq_unit.eop = FALSE;
+		src_vxdb->seq_unit.pict_hdr_info = NULL;
+		src_vxdb->seq_unit.dd_pict_data = NULL;
+		src_vxdb->seq_unit.last_pict_in_seq = FALSE;
+		src_vxdb->seq_unit.str_unit_tag = NULL;
+		src_vxdb->seq_unit.decode = FALSE;
+		src_vxdb->seq_unit.features = 0;
+		core_stream_submit_unit(ctx->res_str_id, &src_vxdb->seq_unit);
+	}
+
+	src_vxdb->pic_unit.str_unit_type = VDECDD_STRUNIT_PICTURE_START;
+	src_vxdb->pic_unit.str_unit_handle = ctx;
+	src_vxdb->pic_unit.err_flags = 0;
+	/* Move the processed segments to the submission buffer */
+	for (i = 0; i < BSPP_MAX_PICTURES_PER_BUFFER; i++) {
+		item = lst_first(&preparsed_data->picture_data.pre_pict_seg_list[i]);
+		while (item) {
+			next = lst_next(item);
+			lst_remove(&preparsed_data->picture_data.pre_pict_seg_list[i], item);
+			lst_add(&src_vxdb->pic_unit.bstr_seg_list, item);
+			item = next;
+		}
+		/* Move the processed segments to the submission buffer */
+		item = lst_first(&preparsed_data->picture_data.pict_seg_list[i]);
+		while (item) {
+			next = lst_next(item);
+			lst_remove(&preparsed_data->picture_data.pict_seg_list[i], item);
+			lst_add(&src_vxdb->pic_unit.bstr_seg_list, item);
+			item = next;
+		}
+	}
+
+	src_vxdb->pic_unit.dd_data = NULL;
+	src_vxdb->pic_unit.seq_hdr_info = NULL;
+	src_vxdb->pic_unit.seq_hdr_id = 0;
+	if (preparsed_data->new_sequence)
+		src_vxdb->pic_unit.closed_gop = TRUE;
+	else
+		src_vxdb->pic_unit.closed_gop = FALSE;
+	src_vxdb->pic_unit.eop = TRUE;
+	src_vxdb->pic_unit.eos = ctx->eos;
+	src_vxdb->pic_unit.pict_hdr_info =
+		&preparsed_data->picture_data.pict_hdr_info;
+	src_vxdb->pic_unit.dd_pict_data = NULL;
+	src_vxdb->pic_unit.last_pict_in_seq = FALSE;
+	src_vxdb->pic_unit.str_unit_tag = NULL;
+	src_vxdb->pic_unit.decode = FALSE;
+	src_vxdb->pic_unit.features = 0;
+	core_stream_submit_unit(ctx->res_str_id, &src_vxdb->pic_unit);
+
+	src_vxdb->end_unit.str_unit_type = VDECDD_STRUNIT_PICTURE_END;
+	src_vxdb->end_unit.str_unit_handle = ctx;
+	src_vxdb->end_unit.err_flags = 0;
+	src_vxdb->end_unit.dd_data = NULL;
+	src_vxdb->end_unit.seq_hdr_info = NULL;
+	src_vxdb->end_unit.seq_hdr_id = 0;
+	src_vxdb->end_unit.closed_gop = FALSE;
+	src_vxdb->end_unit.eop = FALSE;
+	src_vxdb->end_unit.eos = ctx->eos;
+	src_vxdb->end_unit.pict_hdr_info = NULL;
+	src_vxdb->end_unit.dd_pict_data = NULL;
+	src_vxdb->end_unit.last_pict_in_seq = FALSE;
+	src_vxdb->end_unit.str_unit_tag = NULL;
+	src_vxdb->end_unit.decode = FALSE;
+	src_vxdb->end_unit.features = 0;
+	core_stream_submit_unit(ctx->res_str_id, &src_vxdb->end_unit);
+}
+
+static int job_ready(void *priv)
+{
+	struct vxd_dec_ctx *ctx = priv;
+
+	if (v4l2_m2m_num_src_bufs_ready(ctx->fh.m2m_ctx) < 1 ||
+	    v4l2_m2m_num_dst_bufs_ready(ctx->fh.m2m_ctx) < 1 ||
+	    !ctx->core_streaming)
+		return 0;
+
+	return 1;
+}
+
+static void job_abort(void *priv)
+{
+	struct vxd_dec_ctx *ctx = priv;
+
+	/* Cancel the transaction at next callback */
+	ctx->aborting = 1;
+}
+
+static const struct v4l2_m2m_ops m2m_ops = {
+	.device_run = device_run,
+	.job_ready = job_ready,
+	.job_abort = job_abort,
+};
+
+static const struct of_device_id vxd_dec_of_match[] = {
+	{.compatible = "img,d5500-vxd"},
+	{ /* end */},
+};
+MODULE_DEVICE_TABLE(of, vxd_dec_of_match);
+
+static int vxd_dec_probe(struct platform_device *pdev)
+{
+	struct vxd_dev *vxd;
+	struct resource *res;
+	const struct of_device_id *of_dev_id;
+	int ret;
+	int module_irq;
+	struct video_device *vfd;
+
+	struct heap_config *heap_configs;
+	int num_heaps;
+	unsigned int i_heap_id;
+	/* Protect structure fields */
+	spinlock_t **lock;
+
+	of_dev_id = of_match_device(vxd_dec_of_match, &pdev->dev);
+	if (!of_dev_id) {
+		dev_err(&pdev->dev, "%s: Unable to match device\n", __func__);
+		return -ENODEV;
+	}
+
+	dma_set_mask(&pdev->dev, DMA_BIT_MASK(40));
+
+	vxd = devm_kzalloc(&pdev->dev, sizeof(*vxd), GFP_KERNEL);
+	if (!vxd)
+		return -ENOMEM;
+
+	vxd->dev = &pdev->dev;
+	vxd->plat_dev = pdev;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	vxd->reg_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR_VALUE((unsigned long)vxd->reg_base))
+		return (long)(vxd->reg_base);
+
+	module_irq = platform_get_irq(pdev, 0);
+	if (module_irq < 0)
+		return -ENXIO;
+	vxd->module_irq = module_irq;
+#ifdef ERROR_RECOVERY_SIMULATION
+	g_module_irq = module_irq;
+#endif
+
+	heap_configs = vxd_dec_heap_configs;
+	num_heaps = ARRAY_SIZE(vxd_dec_heap_configs);
+
+	vxd->mutex = kzalloc(sizeof(*vxd->mutex), GFP_KERNEL);
+	if (!vxd->mutex)
+		return -ENOMEM;
+
+	mutex_init(vxd->mutex);
+	platform_set_drvdata(pdev, vxd);
+
+	pm_runtime_enable(&pdev->dev);
+	ret = pm_runtime_get_sync(&pdev->dev);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "%s: failed to enable clock, status = %d\n", __func__, ret);
+		goto exit;
+	}
+
+	/* Read HW properties */
+	ret = vxd_pvdec_get_props(vxd->dev, vxd->reg_base, &vxd->props);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: failed to fetch core properties!\n", __func__);
+		ret = -ENXIO;
+		goto out_put_sync;
+	}
+	vxd->mmu_config_addr_width = VXD_EXTRN_ADDR_WIDTH(vxd->props);
+#ifdef DEBUG_DECODER_DRIVER
+	dev_info(&pdev->dev, "hw:%u.%u.%u, num_pix: %d, num_ent: %d, mmu: %d, MTX RAM: %d\n",
+		 VXD_MAJ_REV(vxd->props),
+		 VXD_MIN_REV(vxd->props),
+		 VXD_MAINT_REV(vxd->props),
+		 VXD_NUM_PIX_PIPES(vxd->props),
+		 VXD_NUM_ENT_PIPES(vxd->props),
+		 VXD_EXTRN_ADDR_WIDTH(vxd->props),
+		 vxd->props.mtx_ram_size);
+#endif
+
+	INIT_LIST_HEAD(&vxd->msgs);
+	INIT_LIST_HEAD(&vxd->pend);
+
+	/* initialize memory manager */
+	ret = img_mem_init(&pdev->dev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to initialize memory\n");
+		ret = -ENOMEM;
+		goto out_put_sync;
+	}
+	vxd->streams = kzalloc(sizeof(*vxd->streams), GFP_KERNEL);
+	if (!vxd->streams) {
+		ret = -ENOMEM;
+		goto out_init;
+	}
+
+	idr_init(vxd->streams);
+
+	ret = vxd_init(&pdev->dev, vxd, heap_configs, num_heaps);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: main component initialisation failed!\n", __func__);
+		goto out_idr_init;
+	}
+
+	/* initialize core */
+	i_heap_id = vxd_g_internal_heap_id();
+	if (i_heap_id < 0) {
+		dev_err(&pdev->dev, "%s: Invalid internal heap id", __func__);
+		goto out_vxd_init;
+	}
+	ret = core_initialise(vxd, i_heap_id, vxd_return_resource);
+	if (ret) {
+		dev_err(&pdev->dev, "%s: core initialization failed!", __func__);
+		goto out_vxd_init;
+	}
+
+	vxd->fw_refcnt = 0;
+	vxd->hw_on = 0;
+
+#ifdef DEBUG_DECODER_DRIVER
+	vxd->hw_pm_delay = 10000;
+	vxd->hw_dwr_period = 10000;
+#else
+	vxd->hw_pm_delay = 1000;
+	vxd->hw_dwr_period = 1000;
+#endif
+	ret = vxd_prepare_fw(vxd);
+	if (ret) {
+		dev_err(&pdev->dev, "%s fw acquire failed!", __func__);
+		goto out_core_init;
+	}
+
+	if (vxd->no_fw) {
+		dev_err(&pdev->dev, "%s fw acquire failed!", __func__);
+		goto out_core_init;
+	}
+
+	 lock = (spinlock_t **)&vxd->lock;
+	*lock = kzalloc(sizeof(spinlock_t), GFP_KERNEL);
+
+	if (!(*lock)) {
+		pr_err("Memory allocation failed for spin-lock\n");
+		ret = ENOMEM;
+		goto out_core_init;
+	}
+	spin_lock_init(*lock);
+
+	ret = v4l2_device_register(&pdev->dev, &vxd->v4l2_dev);
+	if (ret)
+		goto out_clean_fw;
+
+#ifdef ERROR_RECOVERY_SIMULATION
+	/*
+	 * create a sysfs entry here, to debug firmware error recovery.
+	 */
+	vxd_dec_kobject = kobject_create_and_add("vxd_decoder", kernel_kobj);
+	if (!vxd_dec_kobject) {
+		dev_err(&pdev->dev, "Failed to create kernel object\n");
+		goto out_clean_fw;
+	}
+
+	ret = sysfs_create_group(vxd_dec_kobject, &attr_group);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to create sysfs files\n");
+		kobject_put(vxd_dec_kobject);
+	}
+#endif
+
+	vfd = video_device_alloc();
+	if (!vfd) {
+		dev_err(&pdev->dev, "Failed to allocate video device\n");
+		ret = -ENOMEM;
+		goto out_v4l2_device;
+	}
+
+	vxd->vfd_dec = vfd;
+	*vfd = vxd_dec_videodev;
+	vfd->v4l2_dev = &vxd->v4l2_dev;
+	vfd->device_caps = V4L2_CAP_VIDEO_M2M_MPLANE | V4L2_CAP_STREAMING;
+	vfd->lock = vxd->mutex;
+
+	video_set_drvdata(vfd, vxd);
+
+	snprintf(vfd->name, sizeof(vfd->name), "%s", vxd_dec_videodev.name);
+	ret = devm_request_threaded_irq(&pdev->dev, module_irq, (irq_handler_t)hard_isrcb,
+					(irq_handler_t)soft_thread_irq, IRQF_SHARED,
+					IMG_VXD_DEC_MODULE_NAME, pdev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to request irq\n");
+		goto out_vid_dev;
+	}
+
+	vxd->m2m_dev = v4l2_m2m_init(&m2m_ops);
+	if (IS_ERR_VALUE((unsigned long)vxd->m2m_dev)) {
+		dev_err(&pdev->dev, "Failed to init mem2mem device\n");
+		ret = -EINVAL;
+		goto out_vid_dev;
+	}
+
+	ret = video_register_device(vfd, VFL_TYPE_VIDEO, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register video device\n");
+		goto out_vid_reg;
+	}
+	v4l2_info(&vxd->v4l2_dev, "decoder registered as /dev/video%d\n", vfd->num);
+
+	return 0;
+
+out_vid_reg:
+	v4l2_m2m_release(vxd->m2m_dev);
+
+out_vid_dev:
+	video_device_release(vfd);
+
+out_v4l2_device:
+	v4l2_device_unregister(&vxd->v4l2_dev);
+
+out_clean_fw:
+	vxd_clean_fw_resources(vxd);
+
+out_core_init:
+	core_deinitialise();
+
+out_vxd_init:
+	vxd_deinit(vxd);
+
+out_idr_init:
+	idr_destroy(vxd->streams);
+	kfree(vxd->streams);
+
+out_init:
+	img_mem_exit();
+
+out_put_sync:
+	pm_runtime_put_sync(&pdev->dev);
+
+exit:
+	pm_runtime_disable(&pdev->dev);
+	mutex_destroy(vxd->mutex);
+	kfree(vxd->mutex);
+	vxd->mutex = NULL;
+
+	return ret;
+}
+
+static int vxd_dec_remove(struct platform_device *pdev)
+{
+	struct vxd_dev *vxd = platform_get_drvdata(pdev);
+
+	core_deinitialise();
+
+	vxd_clean_fw_resources(vxd);
+	vxd_deinit(vxd);
+	idr_destroy(vxd->streams);
+	kfree(vxd->streams);
+	get_delayed_work_buff(&vxd->dwork, TRUE);
+	kfree(&vxd->lock);
+	img_mem_exit();
+
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+	kfree(vxd->dwork);
+	mutex_destroy(vxd->mutex);
+	kfree(vxd->mutex);
+	vxd->mutex = NULL;
+
+	video_unregister_device(vxd->vfd_dec);
+	v4l2_m2m_release(vxd->m2m_dev);
+	v4l2_device_unregister(&vxd->v4l2_dev);
+
+	return 0;
+}
+
+static int __maybe_unused vxd_dec_suspend(struct device *dev)
+{
+	int ret = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = vxd_suspend_dev(dev);
+	if (ret)
+		dev_err(dev, "failed to suspend core hw!\n");
+
+	return ret;
+}
+
+static int __maybe_unused vxd_dec_resume(struct device *dev)
+{
+	int ret = 0;
+
+	dev_dbg(dev, "%s\n", __func__);
+
+	ret = vxd_resume_dev(dev);
+	if (ret)
+		dev_err(dev, "failed to resume core hw!\n");
+
+	return ret;
+}
+
+static UNIVERSAL_DEV_PM_OPS(vxd_dec_pm_ops,
+	vxd_dec_suspend, vxd_dec_resume, NULL);
+
+static struct platform_driver vxd_dec_driver = {
+	.probe = vxd_dec_probe,
+	.remove = vxd_dec_remove,
+	.driver = {
+		.name = "img_dec",
+		.pm = &vxd_dec_pm_ops,
+		.of_match_table = vxd_dec_of_match,
+	},
+};
+module_platform_driver(vxd_dec_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("IMG D5520 video decoder driver");
-- 
2.17.1

