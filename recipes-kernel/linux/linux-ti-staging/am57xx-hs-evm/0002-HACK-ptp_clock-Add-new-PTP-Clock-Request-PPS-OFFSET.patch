From 00429ce6a06da8bcc2df6ea48f316d99e4246101 Mon Sep 17 00:00:00 2001
From: Dharma B <dharma.b@ti.com>
Date: Tue, 30 Nov 2021 16:50:39 +0530
Subject: [PATCH 02/17] HACK: ptp_clock: Add new PTP Clock Request PPS OFFSET

PPS_OFFSET is used to adjust the 1PPS output signal timing to compensate
for the local I/O delay and/or for testing purpose

This patch adds the new PTP_CLK_REQ code, the PTP_PPS_OFFSET ioctl
definition. It also implements the PPS_OFFSET control through both
sysfs and ioctl.

Usage example:
echo -10 > /sys/devices/platform/pruss2_eth/ptp/ptp1/pps_offset
ioctl(CLOCKID_TO_FD(src), PTP_PPS_OFFSET, offset);

Signed-off-by: Dharma B <dharma.b@ti.com>
---
 drivers/ptp/ptp_chardev.c        | 12 ++++++++++++
 drivers/ptp/ptp_sysfs.c          | 31 +++++++++++++++++++++++++++++++
 include/linux/ptp_clock_kernel.h |  1 +
 include/uapi/linux/ptp_clock.h   |  1 +
 4 files changed, 45 insertions(+)

diff --git a/drivers/ptp/ptp_chardev.c b/drivers/ptp/ptp_chardev.c
index af3bc65c4595..bcb72a209849 100644
--- a/drivers/ptp/ptp_chardev.c
+++ b/drivers/ptp/ptp_chardev.c
@@ -264,6 +264,18 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
		mutex_unlock(&ptp->pincfg_mux);
 		break;
 
+	case PTP_PPS_OFFSET:
+		if (!capable(CAP_SYS_TIME))
+			return -EPERM;
+		req.type = PTP_CLK_REQ_PPS_OFFSET;
+		/* record pps offset */
+		enable = (int) arg;
+		if (mutex_lock_interruptible(&ptp->pincfg_mux))
+			return -ERESTARTSYS;
+		err = ops->enable(ops, &req, enable);
+		mutex_unlock(&ptp->pincfg_mux);
+		break;
+
 	case PTP_SYS_OFFSET_PRECISE:
 	case PTP_SYS_OFFSET_PRECISE2:
 		if (!ptp->info->getcrosststamp) {
diff --git a/drivers/ptp/ptp_sysfs.c b/drivers/ptp/ptp_sysfs.c
index be076a91e20e..1e63d3bf70cd 100644
--- a/drivers/ptp/ptp_sysfs.c
+++ b/drivers/ptp/ptp_sysfs.c
@@ -148,6 +148,33 @@ static ssize_t pps_enable_store(struct device *dev,
 }
 static DEVICE_ATTR(pps_enable, 0220, NULL, pps_enable_store);
 
+static ssize_t pps_offset_store(struct device *dev,
+		struct device_attribute *attr,
+		const char *buf, size_t count)
+{
+	struct ptp_clock *ptp = dev_get_drvdata(dev);
+	struct ptp_clock_info *ops = ptp->info;
+	struct ptp_clock_request req = { .type = PTP_CLK_REQ_PPS_OFFSET };
+	int rc, offset;
+	int err = -EINVAL;
+
+	if (!capable(CAP_SYS_TIME))
+		return -EPERM;
+
+	rc = kstrtoint(buf, 0, &offset);
+	if (rc)
+		goto out;
+
+	err = ops->enable(ops, &req, offset);
+	if (err)
+		goto out;
+
+	return count;
+out:
+	return err;
+}
+static DEVICE_ATTR(pps_offset,   0220, NULL, pps_offset_store);
+
 static struct attribute *ptp_attrs[] = {
 	&dev_attr_clock_name.attr,
 
@@ -162,6 +189,7 @@ static struct attribute *ptp_attrs[] = {
 	&dev_attr_fifo.attr,
 	&dev_attr_period.attr,
 	&dev_attr_pps_enable.attr,
+	&dev_attr_pps_offset.attr,
 	NULL
 };
 
@@ -183,6 +211,9 @@ static umode_t ptp_is_attribute_visible(struct kobject *kobj,
 	} else if (attr == &dev_attr_pps_enable.attr) {
 		if (!info->pps)
 			mode = 0;
+	} else if (attr == &dev_attr_pps_offset.attr) {
+		if (!info->pps)
+			mode = 0;
 	}
 
 	return mode;
diff --git a/include/linux/ptp_clock_kernel.h b/include/linux/ptp_clock_kernel.h
index 6d6b42143eff..6d7cd3c571d4 100644
--- a/include/linux/ptp_clock_kernel.h
+++ b/include/linux/ptp_clock_kernel.h
@@ -18,6 +18,7 @@ struct ptp_clock_request {
 		PTP_CLK_REQ_EXTTS,
 		PTP_CLK_REQ_PEROUT,
 		PTP_CLK_REQ_PPS,
+		PTP_CLK_REQ_PPS_OFFSET,
 	} type;
 	union {
 		struct ptp_extts_request extts;
diff --git a/include/uapi/linux/ptp_clock.h b/include/uapi/linux/ptp_clock.h
index 1d108d597f66..ccd9e7fe21e7 100644
--- a/include/uapi/linux/ptp_clock.h
+++ b/include/uapi/linux/ptp_clock.h
@@ -223,6 +223,7 @@ struct ptp_pin_desc {
 	_IOWR(PTP_CLK_MAGIC, 17, struct ptp_sys_offset_precise)
 #define PTP_SYS_OFFSET_EXTENDED2 \
 	_IOWR(PTP_CLK_MAGIC, 18, struct ptp_sys_offset_extended)
+#define PTP_PPS_OFFSET     _IOW(PTP_CLK_MAGIC, 19, int)
 
 struct ptp_extts_event {
 	struct ptp_clock_time t; /* Time event occured. */
-- 
2.17.0

