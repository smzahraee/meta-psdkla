From 3c89b84389d5a9a34a21a7c09d9dbd5c08998f8e Mon Sep 17 00:00:00 2001
From: Dharma B <dharma.b@ti.com>
Date: Tue, 30 Nov 2021 17:03:07 +0530
Subject: [PATCH 04/17] HACK: net: ethernet: ti: introduce ptp boundary clock
 internal sync monitor

On some of TI's platforms, more than one timing capable modules are
included. Consider, for example, the CPTS and the two IEP modules on
AM57xx platforms. When these timing modules participate in a PTP
boundary clock (BC) functionality, the PTP clocks implemented by these
modules need to be internally synchronized to the same PTP time of the
PTP domain in which the BC participates. If the internal sync is done
by using the 1PPS generated by the timing modules, it needs to make
sure that only one such module is generating 1PPS at any given
instant of time, for otherwise the SoC life may be damaged over time
when more than one timing module has output signal going against each
other. It is not suffice to rely on the application that implements
that PTP boundary clock software functionality to ensure the one
out-going PPS policy for user may "accidentally" issue PPS enablement
outside of the PTP BC application, for example, through sysfs.

This patch introduces a small driver so that the driver of each BC
participating timing module needs to get permission from this driver
before it can enable its PPS.

A gpio-controlled multiplexer is added to guarantee there will be only
one PPS signal output at any time. Two of the gpio control pins
pps_mux sel0 and pps_mux_sel1 will be maintained by this module.

This patch implements the gpio-based 1PPS output selection:
    - extract the pps_mux_sel0 and pps_mux_sel1 gpio from device tree
    - acquire and initialize those gpios
    - define and use clock type to determine the desired gpio values
    - update the ptp_bc_clock_register API to pass the clock type
    - update the cpts clock driver to pass clock type while invoking
      ptp_bc_clock_register
    - update the prueth (iep) clock driver to pass clock type while
      invoking ptp_bc_clock_register

    (PRU1 PPS)
      |pps-mux-sel0        ) out hi
      |pps-mux-sel1        ) out lo
      |pps-enable          ) out lo
    (PRU2 PPS)
      |pps-mux-sel0        ) out lo
      |pps-mux-sel1        ) out hi
      |pps-enable          ) out lo
    (CPTS PPS)
      |pps-mux-sel0        ) out lo
      |pps-mux-sel1        ) out lo
      |pps-enable          ) out hi
     - CPTS cfg pps-enable by itself
    (OFF PPS)
      |pps-mux-sel0        ) out lo
      |pps-mux-sel1        ) out lo
      |pps-enable          ) out hi

It will work only on modified am57xx IDK boards.

Signed-off-by: Dharma B <dharma.b@ti.com>
---
 drivers/net/ethernet/ti/Kconfig   |  11 ++
 drivers/net/ethernet/ti/Makefile  |   1 +
 drivers/net/ethernet/ti/ptp_bc.c  | 292 ++++++++++++++++++++++++++++++
 drivers/net/ethernet/ti/ptp_bc.h  |  52 ++++++
 ti_config_fragments/dra7_only.cfg |   2 +
 5 files changed, 358 insertions(+)
 create mode 100644 drivers/net/ethernet/ti/ptp_bc.c
 create mode 100644 drivers/net/ethernet/ti/ptp_bc.h

diff --git a/drivers/net/ethernet/ti/Kconfig b/drivers/net/ethernet/ti/Kconfig
index f66ae649bdb1..d1dbcc3d46dc 100644
--- a/drivers/net/ethernet/ti/Kconfig
+++ b/drivers/net/ethernet/ti/Kconfig
@@ -222,4 +222,15 @@ config TI_ICSSG_PRUETH
 	  Support dual Gigabit Ethernet ports over the ICSSG PRU Subsystem
 	  This subsystem is available starting with the AM65 platform.
 
+config TI_PTP_BC
+	tristate "TI Boundary Clock Support"
+	depends on TI_CPSW || TI_PRUETH
+	depends on PTP_1588_CLOCK
+	help
+	  This driver supports PTP boundary clock that includes more
+	  than one physical clock, such as CPTS and ICSS-IEP, as its
+	  constituent clocks with pps internal sync capability. It
+	  makes sure that no more than one constituent clock enables
+	  pps for internal sync purpose at any given instant of time.
+
 endif # NET_VENDOR_TI
diff --git a/drivers/net/ethernet/ti/Makefile b/drivers/net/ethernet/ti/Makefile
index 58a22d3c4676..279270417ead 100644
--- a/drivers/net/ethernet/ti/Makefile
+++ b/drivers/net/ethernet/ti/Makefile
@@ -14,6 +14,7 @@ ti_davinci_emac-y := davinci_emac.o davinci_cpdma.o
 obj-$(CONFIG_TI_DAVINCI_MDIO) += davinci_mdio.o
 obj-$(CONFIG_TI_CPSW_PHY_SEL) += cpsw-phy-sel.o
 obj-$(CONFIG_TI_CPTS) += cpts.o
+obj-$(CONFIG_TI_PTP_BC) += ptp_bc.o
 obj-$(CONFIG_TI_CPSW) += ti_cpsw.o
 ti_cpsw-y := cpsw.o davinci_cpdma.o cpsw_ale.o cpsw_priv.o cpsw_sl.o cpsw_ethtool.o
 obj-$(CONFIG_TI_CPSW_SWITCHDEV) += ti_cpsw_new.o
diff --git a/drivers/net/ethernet/ti/ptp_bc.c b/drivers/net/ethernet/ti/ptp_bc.c
new file mode 100644
index 000000000000..e20a2a756aa3
--- /dev/null
+++ b/drivers/net/ethernet/ti/ptp_bc.c
@@ -0,0 +1,292 @@
+// SPDX-License-Identifier: GPL-2.0
+/* TI PTP Boundary Clock Internal Sync Monitor
+ *
+ * Copyright (C) 2015-2017 Texas Instruments Incorporated - http://www.ti.com
+ */
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+
+#include "ptp_bc.h"
+
+#define PTP_BC_MAGIC 0x1ffffff
+#define MAX_CLKS 3
+
+static unsigned int bc_clocks_registered;
+static u32 bc_clk_sync_enabled;
+static spinlock_t bc_sync_lock; /* protects bc var */
+static bool ptp_bc_initialized;
+static int clock_type[MAX_CLKS];
+static int bc_clk_pps_mux_sel0_gpio;
+static int bc_clk_pps_mux_sel1_gpio;
+static ptp_bc_mux_ctrl_handle_t bc_mux_ctrl_handler;
+static void *bc_mux_ctrl_ctx;
+static spinlock_t *bc_mux_lock;
+
+static inline int bc_clock_is_registered(int clkid)
+{
+	return (bc_clocks_registered & BIT(clkid));
+}
+
+static int ptp_bc_alloc_clk_id(void)
+{
+	int i;
+
+	for (i = 0; i < MAX_CLKS; i++) {
+		if (!bc_clock_is_registered(i)) {
+			bc_clocks_registered |= BIT(i);
+			return i;
+		}
+	}
+
+	return -1;
+}
+
+static void ptp_bc_free_clk_id(int clkid)
+{
+	if (clkid >= 0 && clkid < MAX_CLKS)
+		bc_clocks_registered &= ~BIT(clkid);
+}
+
+static void ptp_bc_clock_pps_mux_reset(void)
+{
+	if (bc_clk_pps_mux_sel0_gpio < 0 ||
+			bc_clk_pps_mux_sel1_gpio < 0)
+		return;
+
+	if (bc_mux_ctrl_handler) {
+		spin_lock_bh(bc_mux_lock);
+		bc_mux_ctrl_handler(bc_mux_ctrl_ctx, false);
+	}
+
+	gpio_set_value(bc_clk_pps_mux_sel0_gpio, 0);
+	gpio_set_value(bc_clk_pps_mux_sel1_gpio, 0);
+
+	if (bc_mux_ctrl_handler)
+		spin_unlock_bh(bc_mux_lock);
+}
+
+static void ptp_bc_clock_pps_mux_sel(int clkid)
+{
+	bool en_mux = true;
+
+	if (clkid < 0 || clkid >= MAX_CLKS) {
+		pr_err("%s: invalid clkid: %d\n", __func__, clkid);
+		return;
+	}
+
+	if (bc_clk_pps_mux_sel0_gpio < 0 ||
+			bc_clk_pps_mux_sel1_gpio < 0)
+		return;
+
+	if (bc_mux_ctrl_handler) {
+		spin_lock_bh(bc_mux_lock);
+		bc_mux_ctrl_handler(bc_mux_ctrl_ctx, false);
+	}
+
+	switch (clock_type[clkid]) {
+		case PTP_BC_CLOCK_TYPE_GMAC:
+			gpio_set_value(bc_clk_pps_mux_sel0_gpio, 0);
+			gpio_set_value(bc_clk_pps_mux_sel1_gpio, 0);
+			en_mux = false;
+			break;
+
+		case PTP_BC_CLOCK_TYPE_PRUICSS1:
+			gpio_set_value(bc_clk_pps_mux_sel0_gpio, 1);
+			gpio_set_value(bc_clk_pps_mux_sel1_gpio, 0);
+			break;
+
+		case PTP_BC_CLOCK_TYPE_PRUICSS2:
+			gpio_set_value(bc_clk_pps_mux_sel0_gpio, 0);
+			gpio_set_value(bc_clk_pps_mux_sel1_gpio, 1);
+			break;
+
+		default:
+			pr_err("%s(%d): invalid type: %d\n", __func__,
+					clkid, clock_type[clkid]);
+			break;
+	}
+
+	if (bc_mux_ctrl_handler) {
+		if (en_mux)
+			bc_mux_ctrl_handler(bc_mux_ctrl_ctx, true);
+		spin_unlock_bh(bc_mux_lock);
+	}
+
+}
+
+bool ptp_bc_clock_sync_enable(int clkid, int enable)
+{
+	unsigned long flags;
+	bool allow = false;
+
+	if (!ptp_bc_initialized)
+		return true;
+
+	if (clkid < 0 || clkid >= MAX_CLKS)
+		return false;
+
+	spin_lock_irqsave(&bc_sync_lock, flags);
+
+	if (!bc_clock_is_registered(clkid)) {
+		spin_unlock_irqrestore(&bc_sync_lock, flags);
+		return false;
+	}
+
+	if (enable) {
+		if (bc_clk_sync_enabled) {
+			/* request to enable but someone has already enabled
+			 * regardless this someone is the requesting clkid
+			 * itself or not.
+			 */
+			allow = false;
+		} else {
+			/* request to enable and none is enabled */
+			ptp_bc_clock_pps_mux_sel(clkid);
+			bc_clk_sync_enabled |= BIT(clkid);
+			allow = true;
+		}
+	} else {
+		bc_clk_sync_enabled &= ~BIT(clkid);
+		allow = true;
+	}
+
+	if (!bc_clk_sync_enabled)
+		ptp_bc_clock_pps_mux_reset();
+
+	spin_unlock_irqrestore(&bc_sync_lock, flags);
+
+	pr_info("ptp_bc_clk_sync_enable: Req clk=%d, %s, %s. ClkSyncEn(mask): 0x%08x\n",
+			clkid,
+			(enable ? "on" : "off"),
+			(allow  ? "OK" : "Failed"),
+			bc_clk_sync_enabled);
+
+	return allow;
+}
+EXPORT_SYMBOL_GPL(ptp_bc_clock_sync_enable);
+
+int ptp_bc_clock_register(int clocktype)
+{
+	unsigned long flags;
+	int id = -1;
+
+	if (!ptp_bc_initialized) {
+		pr_debug("ptp_bc error: NOT initialized.\n");
+		return -1;
+	}
+
+	spin_lock_irqsave(&bc_sync_lock, flags);
+	id = ptp_bc_alloc_clk_id();
+	spin_unlock_irqrestore(&bc_sync_lock, flags);
+
+	if (id < 0)
+		pr_err("ptp_bc register error: max clocks allowed %d\n",
+				MAX_CLKS);
+
+	clock_type[id] = clocktype;
+
+	return id;
+}
+EXPORT_SYMBOL_GPL(ptp_bc_clock_register);
+
+void ptp_bc_clock_unregister(int clkid)
+{
+	unsigned long flags;
+
+	if (!ptp_bc_initialized)
+		return;
+
+	spin_lock_irqsave(&bc_sync_lock, flags);
+	ptp_bc_free_clk_id(clkid);
+	spin_unlock_irqrestore(&bc_sync_lock, flags);
+}
+EXPORT_SYMBOL_GPL(ptp_bc_clock_unregister);
+
+void ptp_bc_mux_ctrl_register(void *ctx, spinlock_t *lock,
+		ptp_bc_mux_ctrl_handle_t handler)
+{
+	if (!ptp_bc_initialized)
+		return;
+
+	if (ctx && lock && handler) {
+		bc_mux_ctrl_handler = handler;
+		bc_mux_ctrl_ctx = ctx;
+		bc_mux_lock = lock;
+	}
+}
+EXPORT_SYMBOL_GPL(ptp_bc_mux_ctrl_register);
+
+static int ptp_bc_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int ret = 0, gpio;
+
+	spin_lock_init(&bc_sync_lock);
+	bc_clk_sync_enabled = 0;
+	bc_clocks_registered = 0;
+	bc_clk_pps_mux_sel0_gpio = -1;
+	bc_clk_pps_mux_sel1_gpio = -1;
+	ptp_bc_initialized  = true;
+
+	gpio = of_get_named_gpio(np, "pps-sel0-gpios", 0);
+	if (!gpio_is_valid(gpio)) {
+		dev_dbg(&pdev->dev, "failed to parse pps-sel0 gpio\n");
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request(&pdev->dev, gpio, "pps-mux-sel0");
+	if (ret) {
+		dev_err(&pdev->dev, "failed to acquire pps-sel0 gpio\n");
+		return ret;
+	}
+	gpio_direction_output(gpio, 0);
+	bc_clk_pps_mux_sel0_gpio = gpio;
+
+	gpio = of_get_named_gpio(np, "pps-sel1-gpios", 0);
+	if (!gpio_is_valid(gpio)) {
+		dev_dbg(&pdev->dev, "failed to parse pps-sel1 gpio\n");
+		devm_gpio_free(&pdev->dev, bc_clk_pps_mux_sel0_gpio);
+		return -EINVAL;
+	}
+
+	ret = devm_gpio_request(&pdev->dev, gpio, "pps-mux-sel1");
+	if (ret) {
+		dev_err(&pdev->dev, "failed to acquire pps-sel1 gpio\n");
+		devm_gpio_free(&pdev->dev, bc_clk_pps_mux_sel0_gpio);
+		return ret;
+	}
+	gpio_direction_output(gpio, 0);
+	bc_clk_pps_mux_sel1_gpio = gpio;
+
+	return 0;
+}
+
+static int ptp_bc_remove(struct platform_device *pdev)
+{
+	ptp_bc_initialized = false;
+	return 0;
+}
+
+static const struct of_device_id ptp_bc_dt_match[] = {
+	{ .compatible = "ti,am57-bc", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, prueth_dt_match);
+
+static struct platform_driver ptp_bc_driver = {
+	.probe = ptp_bc_probe,
+	.remove = ptp_bc_remove,
+	.driver = {
+		.name = "ptp bc",
+		.of_match_table = ptp_bc_dt_match,
+	},
+};
+module_platform_driver(ptp_bc_driver);
+
+MODULE_AUTHOR("WingMan Kwok <w-kwok2@ti.com>");
+MODULE_DESCRIPTION("TI PTP Boundary Clock Internal Sync Monitor");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/net/ethernet/ti/ptp_bc.h b/drivers/net/ethernet/ti/ptp_bc.h
new file mode 100644
index 000000000000..b6f59878d04b
--- /dev/null
+++ b/drivers/net/ethernet/ti/ptp_bc.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Texas Instruments Ethernet Switch Driver
+ *
+ * Copyright (C) 2017 Texas Instruments
+ *
+ */
+#ifndef _TI_PTP_BC_H_
+#define _TI_PTP_BC_H_
+
+/* PTP_BC_CLOCK_TYPE is used to identify the clock for multiplexer
+ * output selection.
+ * The PTP clock should pass its clock type during clock registration
+ */
+#define PTP_BC_CLOCK_TYPE_GMAC		0
+#define PTP_BC_CLOCK_TYPE_PRUICSS1	1
+#define PTP_BC_CLOCK_TYPE_PRUICSS2	2
+
+typedef void (*ptp_bc_mux_ctrl_handle_t)(void *ctx, int enable);
+
+#if IS_ENABLED(CONFIG_TI_PTP_BC)
+int ptp_bc_clock_register(int clktype);
+void ptp_bc_clock_unregister(int clkid);
+bool ptp_bc_clock_sync_enable(int clkid, int enable);
+/* This function should be invoked by the PTP BC module in a pair
+ * to disable and then re-enable the BC pps clock multiplexer.
+ * And the spin lock bc_mux_lock should be invoked to protect
+ * the entire procedure.
+ */
+
+void ptp_bc_mux_ctrl_register(void *ctx, spinlock_t *lock,
+		ptp_bc_mux_ctrl_handle_t handler);
+#else
+static int ptp_bc_clock_register(int clktype)
+{
+	return -1;
+}
+
+static void ptp_bc_clock_unregister(int clkid)
+{
+}
+
+static bool ptp_bc_clock_sync_enable(int clkid, int enable)
+{
+	return true;
+}
+
+static void ptp_bc_mux_ctrl_register(void *ctx, spinlock_t *lock,
+		ptp_bc_mux_ctrl_handle_t handler)
+{
+}
+#endif
+#endif
diff --git a/ti_config_fragments/dra7_only.cfg b/ti_config_fragments/dra7_only.cfg
index db0d4ab8ddb8..64b51b02a4c9 100644
--- a/ti_config_fragments/dra7_only.cfg
+++ b/ti_config_fragments/dra7_only.cfg
@@ -23,3 +23,5 @@ CONFIG_SOC_DRA7XX=y
 CONFIG_ARCH_KEYSTONE=n
 
 CONFIG_ARM_LPAE=y
+
+CONFIG_TI_PTP_BC=y
-- 
2.17.0

