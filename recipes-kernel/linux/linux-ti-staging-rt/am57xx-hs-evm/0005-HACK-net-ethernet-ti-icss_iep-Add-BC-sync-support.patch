From a49a1bc3f580da7a5e5cf3c4c2fd9f5b70a2958f Mon Sep 17 00:00:00 2001
From: Dharma B <dharma.b@ti.com>
Date: Tue, 30 Nov 2021 18:53:48 +0530
Subject: [PATCH 05/17] HACK: net: ethernet: ti: icss_iep: Add BC sync support

Add BC sync support.
use aliases for iep id selection:
        aliases {
                pruss_iep1 = &pruss1_iep;
                pruss_iep2 = &pruss2_iep;
        };
which has to be added to DT.

Signed-off-by: Dharma B <dharma.b@ti.com>
---
 drivers/net/ethernet/ti/icss_iep.c | 189 ++++++++++++++++++++++++++++-
 drivers/net/ethernet/ti/icss_iep.h |  16 +++
 2 files changed, 201 insertions(+), 4 deletions(-)

diff --git a/drivers/net/ethernet/ti/icss_iep.c b/drivers/net/ethernet/ti/icss_iep.c
index 481dc366a7c2..926cd27a3540 100644
--- a/drivers/net/ethernet/ti/icss_iep.c
+++ b/drivers/net/ethernet/ti/icss_iep.c
@@ -16,8 +16,10 @@
 #include <linux/timekeeping.h>
 #include <linux/interrupt.h>
 #include <linux/of_irq.h>
+#include <linux/pinctrl/consumer.h>
 
 #include "icss_iep.h"
+#include "ptp_bc.h"
 
 #define IEP_MAX_DEF_INC		0xf
 #define IEP_MAX_COMPEN_INC		0xfff
@@ -124,6 +126,13 @@ struct icss_iep {
 	u64 period;
 	u32 latch_enable;
 	struct hrtimer sync_timer;
+
+	int bc_clkid;
+	int pruss_id;
+	bool bc_pps_sync;
+	struct pinctrl *pins;
+	struct extts extts[2];
+	struct pps pps[2];
 };
 
 static u32 icss_iep_readl(struct icss_iep *iep, int reg)
@@ -459,6 +468,7 @@ static void icss_iep_update_to_next_boundary(struct icss_iep *iep, u64 start_ns)
 	start_ns += p_ns - 1;
 	offset = do_div(start_ns, p_ns);
 	start_ns = start_ns * p_ns;
+	start_ns += iep->pps[0].offset;
 	/* If it is too close to update, shift to next boundary */
 	if (p_ns - offset < 10)
 		start_ns += p_ns;
@@ -539,11 +549,32 @@ static int icss_iep_perout_enable_hw(struct icss_iep *iep,
 static int icss_iep_perout_enable(struct icss_iep *iep,
 				  struct ptp_perout_request *req, int on)
 {
+	struct timespec64 ts;
 	unsigned long flags;
 	int ret = 0;
+	s64 ns;
 
 	mutex_lock(&iep->ptp_clk_mutex);
 
+	/* this enables a pps for external measurement */
+	if (req->index != 0) {
+		ret = -EOPNOTSUPP;
+		goto exit;
+	}
+
+	if (on) {
+		ts.tv_sec = req->period.sec;
+		ts.tv_nsec = req->period.nsec;
+		ns = timespec64_to_ns(&ts);
+		if (ns != NSEC_PER_SEC) {
+			dev_err(iep->dev,
+				"Unsupported period %llu ns. Device supports only 1 sec period.\n",
+				ns);
+			ret = -EOPNOTSUPP;
+			goto exit;
+		}
+	}
+
 	if (iep->pps_enabled) {
 		ret = -EBUSY;
 		goto exit;
@@ -552,6 +583,14 @@ static int icss_iep_perout_enable(struct icss_iep *iep,
 	if (iep->perout_enabled == !!on)
 		goto exit;
 
+	if (on) {
+		if (iep->pps[1].pin_on)
+			pinctrl_select_state(iep->pins, iep->pps[1].pin_on);
+	} else {
+		if (iep->pps[1].pin_off)
+			pinctrl_select_state(iep->pins, iep->pps[1].pin_off);
+	}
+
 	spin_lock_irqsave(&iep->irq_lock, flags);
	if (iep->cap_cmp_irq)
		hrtimer_cancel(&iep->sync_timer);
@@ -604,7 +643,7 @@ static irqreturn_t icss_iep_cap_cmp_handler(int irq, void *dev_id)
 		ptp_clock_event(iep->ptp_clock, &pevent);
 		dev_dbg(iep->dev, "IEP:pps ts: %llu next:%llu:\n", ns, ns_next);
 
-		hrtimer_start(&iep->sync_timer, ms_to_ktime(110), /* 100ms + buffer */
+		hrtimer_start(&iep->sync_timer, ms_to_ktime(30), /* 20ms + buffer */
 			      HRTIMER_MODE_REL);
 
 		ret = IRQ_HANDLED;
@@ -666,11 +705,15 @@ static int icss_iep_pps_enable(struct icss_iep *iep, int on)
 		rq.perout.period.nsec = 0;
 		rq.perout.start.sec = ts.tv_sec + 2;
 		rq.perout.start.nsec = 0;
+		if (iep->pps[0].pin_on)
+			pinctrl_select_state(iep->pins, iep->pps[0].pin_on);
 		ret = icss_iep_perout_enable_hw(iep, &rq.perout, on);
 	} else {
		if (iep->cap_cmp_irq)
			hrtimer_cancel(&iep->sync_timer);
 		ret = icss_iep_perout_enable_hw(iep, &rq.perout, on);
+		if (iep->pps[0].pin_off)
+			pinctrl_select_state(iep->pins, iep->pps[0].pin_off);
 	}
 
 	if (!ret)
@@ -678,6 +721,9 @@ static int icss_iep_pps_enable(struct icss_iep *iep, int on)
 
 	spin_unlock_irqrestore(&iep->irq_lock, flags);
 
+	if (!iep->pps_enabled && iep->pps[0].pin_on)
+		pinctrl_select_state(iep->pins, iep->pps[0].pin_off);
+
 exit:
 	mutex_unlock(&iep->ptp_clk_mutex);
 
@@ -703,9 +749,13 @@ static int icss_iep_extts_enable(struct icss_iep *iep, u32 index, int on)
 	if (on) {
 		val |= cap;
 		iep->latch_enable |= BIT(index);
+		if (iep->extts[index].pin_on)
+			pinctrl_select_state(iep->pins, iep->extts[index].pin_on);
 	} else {
 		val &= ~cap;
 		iep->latch_enable &= ~BIT(index);
+		if (iep->extts[index].pin_on)
+			pinctrl_select_state(iep->pins, iep->extts[index].pin_off);
 	}
 	regmap_write(iep->map, ICSS_IEP_CAPTURE_CFG_REG, val);
 
@@ -719,14 +769,26 @@ static int icss_iep_ptp_enable(struct ptp_clock_info *ptp,
 			       struct ptp_clock_request *rq, int on)
 {
 	struct icss_iep *iep = container_of(ptp, struct icss_iep, ptp_info);
+	bool ok;
 
 	switch (rq->type) {
 	case PTP_CLK_REQ_PEROUT:
 		return icss_iep_perout_enable(iep, &rq->perout, on);
 	case PTP_CLK_REQ_PPS:
+		/* command line only enables the one for internal sync */
+		if (iep->bc_pps_sync) {
+			ok = ptp_bc_clock_sync_enable(iep->bc_clkid, on);
+			if (!ok) {
+				pr_info("iep error: bc clk sync pps enable denied\n");
+				return -EBUSY;
+			}
+		}
 		return icss_iep_pps_enable(iep, on);
 	case PTP_CLK_REQ_EXTTS:
 		return icss_iep_extts_enable(iep, rq->extts.index, on);
+	case PTP_CLK_REQ_PPS_OFFSET:
+		iep->pps[0].offset = on;
+		return 0;
 	default:
 		break;
 	}
@@ -757,6 +819,101 @@ static enum hrtimer_restart icss_iep_sync0_work(struct hrtimer *timer)
 	return HRTIMER_NORESTART;
 }
 
+static int iep_get_pps_extts_pins(struct icss_iep *iep)
+{
+	struct pinctrl_state *on, *off;
+	u32 has_on_off;
+	struct pinctrl *pins;
+
+	pins = devm_pinctrl_get(iep->dev);
+	if (IS_ERR(pins)) {
+		iep->pins = NULL;
+		dev_dbg(iep->dev, "request for sync latch pins failed: %ld\n",
+				PTR_ERR(pins));
+		return PTR_ERR(pins);
+	}
+
+	iep->pins = pins;
+	has_on_off = 0;
+
+	on = pinctrl_lookup_state(iep->pins, "sync0_on");
+	if (!IS_ERR(on))
+		has_on_off |= BIT(1);
+
+	off = pinctrl_lookup_state(iep->pins, "sync0_off");
+	if (!IS_ERR(off))
+		has_on_off |= BIT(0);
+
+	if (has_on_off == 0x3) {
+		iep->pps[0].pin_on = on;
+		iep->pps[0].pin_off = off;
+		dev_err(iep->dev, "PPS pins configured\n");
+	}
+
+	has_on_off = 0;
+
+	on = pinctrl_lookup_state(iep->pins, "latch0_on");
+	if (!IS_ERR(on))
+		has_on_off |= BIT(1);
+
+	off = pinctrl_lookup_state(iep->pins, "latch0_off");
+	if (!IS_ERR(off))
+		has_on_off |= BIT(0);
+
+	if (has_on_off == 0x3) {
+		iep->extts[0].pin_on = on;
+		iep->extts[0].pin_off = off;
+		dev_err(iep->dev, "Latch pins configured\n");
+	}
+
+	has_on_off = 0;
+
+	if (iep->pps[0].pin_on && iep->extts[0].pin_on)
+		iep->bc_pps_sync = true;
+	else
+		iep->bc_pps_sync = false;
+
+	iep->bc_clkid = -1;
+
+	on = pinctrl_lookup_state(iep->pins, "sync1_on");
+	if (!IS_ERR(on))
+		has_on_off |= BIT(1);
+
+	off = pinctrl_lookup_state(iep->pins, "sync1_off");
+	if (!IS_ERR(off))
+		has_on_off |= BIT(0);
+
+	if (has_on_off == 0x3) {
+		iep->pps[1].pin_on = on;
+		iep->pps[1].pin_off = off;
+		iep->ptp_info.n_per_out = 1;
+	}
+
+	return 0;
+}
+
+#define MAX_PPS                      2
+#define MAX_EXTTS                    2
+static void iep_pps_pins_off(struct icss_iep *iep)
+{
+	int i;
+
+	for (i = 0; i < MAX_PPS; i++) {
+		if (iep->pps[i].pin_off)
+			pinctrl_select_state(iep->pins, iep->pps[i].pin_off);
+	}
+}
+
+static void iep_extts_pins_off(struct icss_iep *iep)
+{
+	int i;
+
+	for (i = 0; i < MAX_EXTTS; i++) {
+		if (iep->extts[i].pin_off)
+			pinctrl_select_state(iep->pins, iep->extts[i].pin_off);
+	}
+}
+
 struct icss_iep *icss_iep_get_idx(struct device_node *np, int idx)
 {
 	struct platform_device *pdev;
@@ -807,6 +964,8 @@ void icss_iep_put(struct icss_iep *iep)
	put_device(iep->dev);
	if (iep->cap_cmp_irq)
 		hrtimer_cancel(&iep->sync_timer);
+	if (iep->pins)
+		devm_pinctrl_put(iep->pins);
 }
 EXPORT_SYMBOL_GPL(icss_iep_put);
 
@@ -820,7 +979,7 @@ void icss_iep_init_fw(struct icss_iep *iep)
	icss_iep_set_default_inc(iep, iep->def_inc);
	icss_iep_set_compensation_inc(iep, iep->def_inc);
 	icss_iep_set_compensation_count(iep, 0);
-	regmap_write(iep->map, ICSS_IEP_SYNC_PWIDTH_REG, iep->refclk_freq / 10); /* 100 ms pulse */
+	regmap_write(iep->map, ICSS_IEP_SYNC_PWIDTH_REG, iep->refclk_freq / 50); /* 20 ms pulse */
 	regmap_write(iep->map, ICSS_IEP_SYNC0_PERIOD_REG, 0);
 	if (iep->plat_data->flags & ICSS_IEP_SLOW_COMPEN_REG_SUPPORT)
 		icss_iep_set_slow_compensation_count(iep, 0);
@@ -842,13 +1001,14 @@ int icss_iep_init(struct icss_iep *iep, const struct icss_iep_clockops *clkops,
	int ret = 0;
 
 	iep->cycle_time_ns = cycle_time_ns;
+	icss_iep_set_counter(iep, ktime_to_ns(ktime_get_real()));
	iep->clk_tick_time = iep->def_inc;
	iep->ops = clkops;
	iep->clockops_data = clockops_data;
	icss_iep_set_default_inc(iep, iep->def_inc);
	icss_iep_set_compensation_inc(iep, iep->def_inc);
	icss_iep_set_compensation_count(iep, 0);
-	regmap_write(iep->map, ICSS_IEP_SYNC_PWIDTH_REG, iep->refclk_freq / 10); /* 100 ms pulse */
+	regmap_write(iep->map, ICSS_IEP_SYNC_PWIDTH_REG, iep->refclk_freq / 50); /* 20 ms pulse */
	regmap_write(iep->map, ICSS_IEP_SYNC0_PERIOD_REG, 0);
	if (iep->plat_data->flags & ICSS_IEP_SLOW_COMPEN_REG_SUPPORT)
		icss_iep_set_slow_compensation_count(iep, 0);
@@ -857,6 +1017,8 @@ int icss_iep_init(struct icss_iep *iep, const struct icss_iep_clockops *clkops,
	    !(iep->plat_data->flags & ICSS_IEP_SLOW_COMPEN_REG_SUPPORT))
		goto skip_perout;
 
+	iep_get_pps_extts_pins(iep);
+
	if (iep->cap_cmp_irq || (iep->ops && iep->ops->perout_enable)) {
		iep->ptp_info.n_per_out = 1;
		iep->ptp_info.pps = 1;
@@ -865,6 +1027,12 @@ int icss_iep_init(struct icss_iep *iep, const struct icss_iep_clockops *clkops,
	if (iep->cap_cmp_irq || (iep->ops && iep->ops->extts_enable))
		iep->ptp_info.n_ext_ts = 2;
 
+	if (iep->ptp_info.pps)
+		iep_pps_pins_off(iep);
+
+	if (iep->ptp_info.n_ext_ts)
+		iep_extts_pins_off(iep);
+
 skip_perout:
	if (cycle_time_ns)
		icss_iep_enable_shadow_mode(iep);
@@ -879,6 +1047,19 @@ int icss_iep_init(struct icss_iep *iep, const struct icss_iep_clockops *clkops,
 		dev_err(iep->dev, "Failed to register ptp clk %d\n", ret);
 	}
 
+	if (iep->bc_pps_sync) {
+		ret = of_alias_get_id(dev_of_node(iep->dev), "pruss_iep");
+
+		dev_info(iep->dev, "ptp bc clktype %d\n", ret);
+
+		iep->bc_clkid = ptp_bc_clock_register(ret == 2 ? PTP_BC_CLOCK_TYPE_PRUICSS2 :
+				PTP_BC_CLOCK_TYPE_PRUICSS1);
+		ret = 0;
+	}
+
+	dev_info(iep->dev, "iep ptp bc clkid %d\n", iep->bc_clkid);
+	ptp_bc_mux_ctrl_register(NULL, NULL, NULL);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(icss_iep_init);
@@ -890,7 +1071,7 @@ int icss_iep_exit(struct icss_iep *iep)
 		iep->ptp_clock = NULL;
 	}
 	icss_iep_disable(iep);
-
+	ptp_bc_clock_unregister(iep->bc_clkid);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(icss_iep_exit);
diff --git a/drivers/net/ethernet/ti/icss_iep.h b/drivers/net/ethernet/ti/icss_iep.h
index 22bee0ad4565..4aae98030927 100644
--- a/drivers/net/ethernet/ti/icss_iep.h
+++ b/drivers/net/ethernet/ti/icss_iep.h
@@ -13,6 +13,22 @@
 #include <linux/regmap.h>
 
 struct icss_iep;
+struct pps {
+	struct pinctrl_state *pin_on;
+	struct pinctrl_state *pin_off;
+	int enable;
+	int offset;
+	int next_op;
+	enum {
+		OP_DISABLE_SYNC,
+		OP_ENABLE_SYNC,
+	} report_ops[4];
+};
+
+struct extts {
+	struct pinctrl_state *pin_on;
+	struct pinctrl_state *pin_off;
+};
 
 /* Firmware specific clock operations */
 struct icss_iep_clockops {
-- 
2.17.0

