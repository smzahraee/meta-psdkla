From 486bbb1c7a7596de0838c043809bf7079875bf2d Mon Sep 17 00:00:00 2001
From: Eric Ruei <e-ruei1@ti.com>
Date: Wed, 18 Apr 2018 10:28:58 -0400
Subject: [PATCH 11/35] HACK: ptp_clock: Add new PTP Clock Request PPS OFFSET

PPS_OFFSET is used to adjust the 1PPS output signal timing to compensate
for the local I/O delay and/or for testing purpose

This patch adds the new PTP_CLK_REQ code, the PTP_PPS_OFFSET ioctl
definition. It also implements the PPS_OFFSET control through both
sysfs and ioctl.

Usage example:
echo -10 > /sys/devices/platform/pruss2_eth/ptp/ptp1/pps_offset
ioctl(CLOCKID_TO_FD(src), PTP_PPS_OFFSET, offset);

Signed-off-by: Eric Ruei <e-ruei1@ti.com>
Signed-off-by: Vitaly Andrianov <vitalya@ti.com>
Signed-off-by: Lokesh Vutla <lokeshvutla@ti.com>
---
 drivers/ptp/ptp_chardev.c        |  9 +++++++++
 drivers/ptp/ptp_sysfs.c          | 31 +++++++++++++++++++++++++++++++
 include/linux/ptp_clock_kernel.h |  1 +
 include/uapi/linux/ptp_clock.h   |  1 +
 4 files changed, 42 insertions(+)

diff --git a/drivers/ptp/ptp_chardev.c b/drivers/ptp/ptp_chardev.c
index 9d72ab593f13..059678f28f2c 100644
--- a/drivers/ptp/ptp_chardev.c
+++ b/drivers/ptp/ptp_chardev.c
@@ -220,6 +220,15 @@ long ptp_ioctl(struct posix_clock *pc, unsigned int cmd, unsigned long arg)
 		err = ops->enable(ops, &req, enable);
 		break;
 
+	case PTP_PPS_OFFSET:
+		if (!capable(CAP_SYS_TIME))
+			return -EPERM;
+		req.type = PTP_CLK_REQ_PPS_OFFSET;
+		/* record pps offset */
+		enable = (int) arg;
+		err = ops->enable(ops, &req, enable);
+		break;
+
 	case PTP_SYS_OFFSET_PRECISE:
 	case PTP_SYS_OFFSET_PRECISE2:
 		if (!ptp->info->getcrosststamp) {
diff --git a/drivers/ptp/ptp_sysfs.c b/drivers/ptp/ptp_sysfs.c
index be076a91e20e..e756876c8f3a 100644
--- a/drivers/ptp/ptp_sysfs.c
+++ b/drivers/ptp/ptp_sysfs.c
@@ -148,6 +148,33 @@ static ssize_t pps_enable_store(struct device *dev,
 }
 static DEVICE_ATTR(pps_enable, 0220, NULL, pps_enable_store);
 
+static ssize_t pps_offset_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct ptp_clock *ptp = dev_get_drvdata(dev);
+	struct ptp_clock_info *ops = ptp->info;
+	struct ptp_clock_request req = { .type = PTP_CLK_REQ_PPS_OFFSET };
+	int rc, offset;
+	int err = -EINVAL;
+
+	if (!capable(CAP_SYS_TIME))
+		return -EPERM;
+
+	rc = kstrtoint(buf, 0, &offset);
+	if (rc)
+		goto out;
+
+	err = ops->enable(ops, &req, offset);
+	if (err)
+		goto out;
+
+	return count;
+out:
+	return err;
+}
+static DEVICE_ATTR(pps_offset,   0220, NULL, pps_offset_store);
+
 static struct attribute *ptp_attrs[] = {
 	&dev_attr_clock_name.attr,
 
@@ -162,6 +189,7 @@ static struct attribute *ptp_attrs[] = {
 	&dev_attr_fifo.attr,
 	&dev_attr_period.attr,
 	&dev_attr_pps_enable.attr,
+	&dev_attr_pps_offset.attr,
 	NULL
 };
 
@@ -183,6 +211,9 @@ static umode_t ptp_is_attribute_visible(struct kobject *kobj,
 	} else if (attr == &dev_attr_pps_enable.attr) {
 		if (!info->pps)
 			mode = 0;
+	} else if (attr == &dev_attr_pps_offset.attr) {
+		if (!info->pps)
+			mode = 0;
 	}
 
 	return mode;
diff --git a/include/linux/ptp_clock_kernel.h b/include/linux/ptp_clock_kernel.h
index 93cc4f1d444a..5c6d871ed17f 100644
--- a/include/linux/ptp_clock_kernel.h
+++ b/include/linux/ptp_clock_kernel.h
@@ -18,6 +18,7 @@ struct ptp_clock_request {
 		PTP_CLK_REQ_EXTTS,
 		PTP_CLK_REQ_PEROUT,
 		PTP_CLK_REQ_PPS,
+		PTP_CLK_REQ_PPS_OFFSET,
 	} type;
 	union {
 		struct ptp_extts_request extts;
diff --git a/include/uapi/linux/ptp_clock.h b/include/uapi/linux/ptp_clock.h
index 9dc9d0079e98..1cec38add3b8 100644
--- a/include/uapi/linux/ptp_clock.h
+++ b/include/uapi/linux/ptp_clock.h
@@ -195,6 +195,7 @@ struct ptp_pin_desc {
 	_IOWR(PTP_CLK_MAGIC, 17, struct ptp_sys_offset_precise)
 #define PTP_SYS_OFFSET_EXTENDED2 \
 	_IOWR(PTP_CLK_MAGIC, 18, struct ptp_sys_offset_extended)
+#define PTP_PPS_OFFSET     _IOW(PTP_CLK_MAGIC, 19, int)
 
 struct ptp_extts_event {
 	struct ptp_clock_time t; /* Time event occured. */
-- 
2.17.1

