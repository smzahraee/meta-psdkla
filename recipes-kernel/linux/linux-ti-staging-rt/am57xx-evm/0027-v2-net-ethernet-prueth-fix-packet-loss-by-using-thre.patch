From 06ed235d6ed4185a13d322e88db60494f0802f47 Mon Sep 17 00:00:00 2001
From: Grygorii Strashko <grygorii.strashko@ti.com>
Date: Wed, 3 Mar 2021 23:28:42 +0200
Subject: [PATCH 27/35] v2: net: ethernet: prueth: fix packet loss by using
 threaded irq handler

Currently using NAPI polling, overflow happens at the ingress queues
when iperf udp traffic is offered to the ingress port at 92Mbps with
MTU sized frames. As the ingress queues have limited buffers (only
6 MTU sized buffers), overflow happens as the NAPI polling is found
to be too slow. So fix this by processing the received frames as quickly
as possible using a threaded irq handler function.

This is an important requirement for supporting industrial Ethernet
such as the one used in substation automation as it requires a loss
free transfer of frames across the network.

Changes in v2:
- added one more queue check cycle

Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
Signed-off-by: Aaron Kramer <a-kramer@ti.com>
Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
---
 drivers/net/ethernet/ti/prueth.h      |   1 -
 drivers/net/ethernet/ti/prueth_core.c | 109 +++++++++-----------------
 2 files changed, 36 insertions(+), 74 deletions(-)

diff --git a/drivers/net/ethernet/ti/prueth.h b/drivers/net/ethernet/ti/prueth.h
index 42dc3000d278..a01147dcc7bb 100644
--- a/drivers/net/ethernet/ti/prueth.h
+++ b/drivers/net/ethernet/ti/prueth.h
@@ -338,7 +338,6 @@ struct prueth_emac {
 	struct prueth *prueth;
 	struct net_device *ndev;
 	u8 mac_addr[6];
-	struct napi_struct napi;
 	u32 msg_enable;
 
 	int link;
diff --git a/drivers/net/ethernet/ti/prueth_core.c b/drivers/net/ethernet/ti/prueth_core.c
index e2f4dc67166b..081b06869e0e 100644
--- a/drivers/net/ethernet/ti/prueth_core.c
+++ b/drivers/net/ethernet/ti/prueth_core.c
@@ -696,30 +696,6 @@ static irqreturn_t emac_tx_irq(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-/**
- * emac_rx_irq - EMAC Rx interrupt handler
- * @irq: interrupt number
- * @dev_id: pointer to net_device
- *
- * EMAC Interrupt handler - we only schedule NAPI and not process any packets
- * here.
- *
- * Returns interrupt handled condition
- */
-static irqreturn_t emac_rx_irq(int irq, void *dev_id)
-{
-	struct net_device *ndev = (struct net_device *)dev_id;
-	struct prueth_emac *emac = netdev_priv(ndev);
-
-	if (likely(netif_running(ndev))) {
-		/* disable Rx system event */
-		disable_irq_nosync(emac->rx_irq);
-		napi_schedule(&emac->napi);
-	}
-
-	return IRQ_HANDLED;
-}
-
 static u8 ptp_event_type(struct sk_buff *skb)
 {
 	unsigned int offset = 0, ptp_class = ptp_classify_raw(skb);
@@ -1353,7 +1329,9 @@ int emac_rx_packet(struct prueth_emac *emac, u16 *bd_rd_ptr,
 
 		/* send packet up the stack */
 		skb->protocol = eth_type_trans(skb, ndev);
+		local_bh_disable();
 		netif_receive_skb(skb);
+		local_bh_enable();
 	} else {
 		dev_kfree_skb_any(skb);
 	}
@@ -1366,9 +1344,27 @@ int emac_rx_packet(struct prueth_emac *emac, u16 *bd_rd_ptr,
 	return 0;
 }
 
-/* get upto quota number of packets */
-static int emac_rx_packets(struct prueth_emac *emac, int quota)
+/**
+ * emac_rx_thread - EMAC Rx interrupt thread handler
+ * @irq: interrupt number
+ * @dev_id: pointer to net_device
+ *
+ * EMAC Rx Interrupt thread handler - function to process the rx frames in a
+ * irq thread function. There is only limited buffer at the ingress to
+ * queue the frames. As the frames are to be emptied as quickly as
+ * possible to avoid overflow, irq thread is necessary. Current implementation
+ * based on NAPI poll results in packet loss due to overflow at
+ * the ingress queues. Industrial use case requires loss free packet
+ * processing. Tests shows that with threaded irq based processing,
+ * no overflow happens when receiving at ~92Mbps for MTU sized frames and thus
+ * meet the requirement for industrial use case.
+ *
+ * Returns interrupt handled condition
+ */
+static irqreturn_t emac_rx_thread(int irq, void *dev_id)
 {
+	struct net_device *ndev = (struct net_device *)dev_id;
+	struct prueth_emac *emac = netdev_priv(ndev);
 	struct prueth *prueth = emac->prueth;
 	int start_queue, end_queue;
 	struct prueth_queue_desc __iomem *queue_desc;
@@ -1392,6 +1388,7 @@ static int emac_rx_packets(struct prueth_emac *emac, int quota)
 		end_queue = emac->rx_queue_end;
 	}
 
+retry:
 	/* search host queues for packets */
 	for (i = start_queue; i <= end_queue; i++) {
 		queue_desc = emac->rx_queue_descs + i;
@@ -1448,8 +1445,7 @@ static int emac_rx_packets(struct prueth_emac *emac, int quota)
 				ret = emac_rx_packet(emac, &update_rd_ptr,
 						     pkt_info, rxqueue);
 				if (ret)
-					return ret;
-
+					return IRQ_HANDLED;
 				used++;
 			}
 
@@ -1462,14 +1458,15 @@ static int emac_rx_packets(struct prueth_emac *emac, int quota)
 			/* update read pointer in queue descriptor */
 			writew(update_rd_ptr, &queue_desc->rd_ptr);
 			bd_rd_ptr = update_rd_ptr;
-
-			/* all we have room for? */
-			if (used >= quota)
-				return used;
 		}
 	}
 
-	return used;
+	if (used) {
+		used = 0;
+		goto retry;
+	}
+
+	return IRQ_HANDLED;
 }
 
 /* get statistics maintained by the PRU firmware into @pstats */
@@ -1502,31 +1499,6 @@ static void emac_set_stats(struct prueth_emac *emac,
 			ICSS_EMAC_FW_MULTICAST_FILTER_DROP_CNT_OFFSET);
 }
 
-/**
- * emac_napi_poll - EMAC NAPI Poll function
- * @napi: ptr to napi instance associated with the emac
- * @budget: Number of receive packets to process (as told by NAPI layer)
- *
- * NAPI Poll function implemented to process packets as per budget. We check
- * the type of interrupt on the device and accordingly call the TX or RX
- * packet processing functions. We follow the budget for RX processing and
- * also put a cap on number of TX pkts processed through config param. The
- * NAPI schedule function is called if more packets pending.
- *
- * Returns number of packets received (in most cases; else TX pkts - rarely)
- */
-static int emac_napi_poll(struct napi_struct *napi, int budget)
-{
-	struct prueth_emac *emac = container_of(napi, struct prueth_emac, napi);
-	int num_rx_packets;
-
-	num_rx_packets = emac_rx_packets(emac, budget);
-	if (num_rx_packets < budget)
-		emac_finish_napi(emac, napi, emac->rx_irq);
-
-	return num_rx_packets;
-}
-
 static int emac_set_boot_pru(struct prueth_emac *emac, struct net_device *ndev)
 {
 	const struct prueth_firmware *pru_firmwares;
@@ -1563,9 +1535,9 @@ static int emac_request_irqs(struct prueth_emac *emac)
 	struct net_device *ndev = emac->ndev;
 	int ret = 0;
 
-	ret = request_irq(emac->rx_irq, emac_rx_irq,
-			  IRQF_TRIGGER_HIGH,
-			  ndev->name, ndev);
+	ret = request_threaded_irq(emac->rx_irq, NULL, emac_rx_thread,
+				   IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+				   ndev->name, ndev);
 	if (ret) {
 		netdev_err(ndev, "unable to request RX IRQ\n");
 		return ret;
@@ -1762,9 +1734,7 @@ static int emac_ndo_open(struct net_device *ndev)
 	if (ret)
 		goto rproc_shutdown;
 
-	if (PRUETH_IS_EMAC(prueth) || PRUETH_IS_SWITCH(prueth)) {
-		napi_enable(&emac->napi);
-	} else {
+	if (!PRUETH_IS_EMAC(prueth) && !PRUETH_IS_SWITCH(prueth)) {
 		/* HSR/PRP. Enable NAPI when first port is initialized */
 		if (!prueth->emac_configured) {
 			napi_enable(&prueth->napi_hpq);
@@ -1831,9 +1801,7 @@ static int emac_ndo_stop(struct net_device *ndev)
 
 	/* inform the upper layers. */
 	netif_stop_queue(ndev);
-	if (PRUETH_IS_EMAC(prueth) || PRUETH_IS_SWITCH(prueth)) {
-		napi_disable(&emac->napi);
-	} else {
+	if (!PRUETH_IS_EMAC(prueth) && !PRUETH_IS_SWITCH(prueth)) {
 		/* HSR/PRP. Disable NAPI when last port is down */
 		if (!prueth->emac_configured) {
 			hrtimer_cancel(&prueth->tbl_check_timer);
@@ -3037,9 +3005,6 @@ static int prueth_netdev_init(struct prueth *prueth,
 		ndev->lredev_ops = &prueth_lredev_ops;
 #endif
 
-	if (PRUETH_IS_EMAC(prueth) || PRUETH_IS_SWITCH(prueth))
-		netif_napi_add(ndev, &emac->napi, emac_napi_poll,
-			       EMAC_POLL_WEIGHT);
 	/* for HSR/PRP,  register napi for port 1 */
 	if (prueth->support_lre && emac->port_id == PRUETH_PORT_MII0) {
 		netif_napi_add(ndev, &prueth->napi_hpq,
@@ -3076,9 +3041,7 @@ static void prueth_netdev_exit(struct prueth *prueth,
 
 	phy_disconnect(emac->phydev);
 
-	if (PRUETH_IS_EMAC(prueth) || PRUETH_IS_SWITCH(prueth)) {
-		netif_napi_del(&emac->napi);
-	} else {
+	if (!PRUETH_IS_EMAC(prueth) && !PRUETH_IS_SWITCH(prueth)) {
 		if (prueth->support_lre &&
 		    emac->port_id == PRUETH_PORT_MII0) {
 			netif_napi_del(&prueth->napi_hpq);
-- 
2.17.1

