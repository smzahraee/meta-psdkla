From 38451ff72ee8b8a830c850140d80eb71f6f69f7d Mon Sep 17 00:00:00 2001
From: Grygorii Strashko <grygorii.strashko@ti.com>
Date: Fri, 9 Apr 2021 15:13:50 +0300
Subject: [PATCH 29/35] net: ethernet: ti: icss_iep: fix irq enabling

IEP irq requested before FW is loaded when mapping is not available yet.
Ensure the IRQ is requested and IEP initialized after PRU FW is loaded, so
it will be properly enabled on INTC level.

Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
---
 drivers/net/ethernet/ti/icss_iep.c    | 33 ++++++++++++---------------
 drivers/net/ethernet/ti/prueth_core.c | 30 ++++++++++++------------
 2 files changed, 30 insertions(+), 33 deletions(-)

diff --git a/drivers/net/ethernet/ti/icss_iep.c b/drivers/net/ethernet/ti/icss_iep.c
index 65cc5d8d464c..65905af507f0 100644
--- a/drivers/net/ethernet/ti/icss_iep.c
+++ b/drivers/net/ethernet/ti/icss_iep.c
@@ -657,7 +657,6 @@ static irqreturn_t icss_iep_cap_cmp_handler(int irq, void *dev_id)
 	sts = icss_iep_readl(iep, ICSS_IEP_CAPTURE_STAT_REG);
 	if (!sts)
 		goto cap_cmp_exit;
-
 	for (i = 0; i < iep->ptp_info.n_ext_ts; i++) {
 		if (sts & IEP_CAP_CFG_CAPNR_1ST_EVENT_EN(i * 2)) {
 			ns = icss_iep_readl(iep,
@@ -920,7 +919,6 @@ struct icss_iep *icss_iep_get(struct device_node *np)
 	struct platform_device *pdev;
 	struct device_node *iep_np;
 	struct icss_iep *iep;
-	int ret;
 
 	iep_np = of_parse_phandle(np, "iep", 0);
 	if (!iep_np || !of_device_is_available(iep_np))
@@ -951,15 +949,8 @@ struct icss_iep *icss_iep_get(struct device_node *np)
 	iep->cap_cmp_irq = of_irq_get_byname(np, "iep_cap_cmp");
 	if (iep->cap_cmp_irq < 0) {
 		iep->cap_cmp_irq = 0;
-	} else {
-		ret = request_irq(iep->cap_cmp_irq, icss_iep_cap_cmp_handler, IRQF_TRIGGER_HIGH,
-				  "iep_cap_cmp", iep);
-		if (ret) {
-			dev_err(iep->dev, "Request irq failed for cap_cmp %d\n", ret);
-			goto put_iep_device;
-		}
-		INIT_DELAYED_WORK(&iep->sync_work, icss_iep_sync0_work);
 	}
+	INIT_DELAYED_WORK(&iep->sync_work, icss_iep_sync0_work);
 
 	iep->ptp_info = icss_iep_ptp_info;
 
@@ -986,11 +977,6 @@ struct icss_iep *icss_iep_get(struct device_node *np)
 
 exit:
 	return iep;
-
-put_iep_device:
-	put_device(iep->dev);
-
-	return ERR_PTR(ret);
 }
 EXPORT_SYMBOL_GPL(icss_iep_get);
 
@@ -1001,10 +987,7 @@ void icss_iep_put(struct icss_iep *iep)
 	device_unlock(iep->dev);
 	put_device(iep->dev);
 	iep->cap_cmp_irq = 0;
-	if (iep->cap_cmp_irq) {
-		free_irq(iep->cap_cmp_irq, iep);
-		cancel_delayed_work(&iep->sync_work);
-	}
+
 	if (iep->pins)
 		devm_pinctrl_put(iep->pins);
 }
@@ -1061,12 +1044,24 @@ int icss_iep_init(struct icss_iep *iep, const struct icss_iep_clockops *clkops,
 	dev_info(iep->dev, "iep ptp bc clkid %d\n", iep->bc_clkid);
 	ptp_bc_mux_ctrl_register(NULL, NULL, NULL);
 
+	if (iep->cap_cmp_irq) {
+		ret = request_irq(iep->cap_cmp_irq, icss_iep_cap_cmp_handler, IRQF_TRIGGER_HIGH,
+				  "iep_cap_cmp", iep);
+		if (ret)
+			dev_err(iep->dev, "Request irq failed for cap_cmp %d\n", ret);
+	}
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(icss_iep_init);
 
 int icss_iep_exit(struct icss_iep *iep)
 {
+	if (iep->cap_cmp_irq) {
+		free_irq(iep->cap_cmp_irq, iep);
+		cancel_delayed_work(&iep->sync_work);
+	}
+
 	if (iep->ptp_clock) {
 		ptp_clock_unregister(iep->ptp_clock);
 		iep->ptp_clock = NULL;
diff --git a/drivers/net/ethernet/ti/prueth_core.c b/drivers/net/ethernet/ti/prueth_core.c
index 081b06869e0e..08963c73df27 100644
--- a/drivers/net/ethernet/ti/prueth_core.c
+++ b/drivers/net/ethernet/ti/prueth_core.c
@@ -1701,14 +1701,7 @@ static int emac_ndo_open(struct net_device *ndev)
 	if (PRUETH_IS_LRE(prueth))
 		prueth_lre_set_stats(prueth, prueth->lre_stats);
 
-	if (!prueth->emac_configured) {
-		icss_ptp_dram_init(emac);
-		ret = icss_iep_init(prueth->iep, NULL, NULL, 0);
-		if (ret) {
-			netdev_err(ndev, "Failed to initialize iep: %d\n", ret);
-			goto free_mem;
-		}
-	}
+
 
 	/* initialize ecap for interrupt pacing */
 	if (!IS_ERR(ecap))
@@ -1717,13 +1710,22 @@ static int emac_ndo_open(struct net_device *ndev)
 	if (!PRUETH_IS_EMAC(prueth)) {
 		ret = prueth_sw_boot_prus(prueth, ndev);
 		if (ret)
-			goto iep_exit;
+			goto free_mem;
 	} else {
 		/* boot the PRU */
 		ret = emac_set_boot_pru(emac, ndev);
 		if (ret) {
 			netdev_err(ndev, "failed to boot PRU: %d\n", ret);
-			goto iep_exit;
+			goto free_mem;
+		}
+	}
+
+	if (!prueth->emac_configured) {
+		icss_ptp_dram_init(emac);
+		ret = icss_iep_init(prueth->iep, NULL, NULL, 0);
+		if (ret) {
+			netdev_err(ndev, "Failed to initialize iep: %d\n", ret);
+			goto rproc_shutdown;
 		}
 	}
 
@@ -1732,7 +1734,7 @@ static int emac_ndo_open(struct net_device *ndev)
 	else
 		ret = prueth_lre_request_irqs(emac);
 	if (ret)
-		goto rproc_shutdown;
+		goto iep_exit;
 
 	if (!PRUETH_IS_EMAC(prueth) && !PRUETH_IS_SWITCH(prueth)) {
 		/* HSR/PRP. Enable NAPI when first port is initialized */
@@ -1763,14 +1765,14 @@ static int emac_ndo_open(struct net_device *ndev)
 
 	return 0;
 
+iep_exit:
+	if (!prueth->emac_configured)
+		icss_iep_exit(prueth->iep);
 rproc_shutdown:
 	if (!PRUETH_IS_EMAC(prueth))
 		prueth_sw_shutdown_prus(emac, ndev);
 	else
 		rproc_shutdown(emac->pru);
-iep_exit:
-	if (!prueth->emac_configured)
-		icss_iep_exit(prueth->iep);
 free_mem:
 	prueth_free_memory(emac->prueth);
 unlock_mutex:
-- 
2.17.1

