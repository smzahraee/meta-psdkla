From 4217ff917266da4df15eebb85a8145bb665fd06a Mon Sep 17 00:00:00 2001
From: Grygorii Strashko <grygorii.strashko@ti.com>
Date: Thu, 21 Jan 2021 15:25:23 +0200
Subject: [PATCH 22/35] HACK: net: ethernet: ti: cpts: fix race cpts_latch_proc
 vs cpts_fifo_read

There is shared data used between cpts_latch_proc and cpts_fifo_read
 - pps_latch_offset
 - pps_latch_receive
and on RT Kernel both function are called from threaded IRQ context with
the same priority and so can race.

Add spin_lock section in cpts_latch_proc() to protect shared data.

Signed-off-by: Grygorii Strashko <grygorii.strashko@ti.com>
---
 drivers/net/ethernet/ti/cpts.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/drivers/net/ethernet/ti/cpts.c b/drivers/net/ethernet/ti/cpts.c
index d0347ab5df4c..4c1d15cc08d6 100644
--- a/drivers/net/ethernet/ti/cpts.c
+++ b/drivers/net/ethernet/ti/cpts.c
@@ -1945,15 +1945,18 @@ static void cpts_latch_proc(struct cpts *cpts, u32 latch_cnt)
 {
 	u32 offset = 0xFFFFFFFFUL - latch_cnt + 1;
 	u32 reload_cnt = CPTS_LATCH_TMR_RELOAD_CNT;
+	unsigned long flags;
 	static bool skip;
 	static int init_cnt;
 
 	if (!cpts)
 		return;
 
+	spin_lock_irqsave(&cpts->lock, flags);
 	cpts->pps_latch_offset = offset * CPTS_TMR_CLK_PERIOD +
 				 CPTS_TMR_LATCH_DELAY;
 	cpts->pps_latch_receive = true;
+	spin_unlock_irqrestore(&cpts->lock, flags);
 
 	/* Timer poll state machine */
 	switch (cpts->pps_latch_state) {
-- 
2.17.1

